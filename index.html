<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Load master configuration file for easy text updates -->
  <script src="app-config.js"></script>
  <meta charset="UTF-8" />
  <title>Fire Interview Coach</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');
    
    :root {
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0a0a0f;
      color: #f9fafb;
      --fire-red: #ef4444;
      --fire-orange: #f97316;
      --fire-yellow: #fbbf24;
      --fire-dark: #7f1d1d;
      --fire-darker: #450a0a;
      --dark-bg: #0f172a;
      --card-bg: rgba(15, 23, 42, 0.85);
      --card-border: rgba(239, 68, 68, 0.2);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      background: 
        radial-gradient(circle at 20% 10%, rgba(239, 68, 68, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 80% 90%, rgba(249, 115, 22, 0.1) 0%, transparent 50%),
        linear-gradient(180deg, #0a0a0f 0%, #1a0a0f 50%, #0a0a0f 100%);
      background-attachment: fixed;
      position: relative;
      overflow-x: hidden;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(239, 68, 68, 0.03) 2px, rgba(239, 68, 68, 0.03) 4px);
      pointer-events: none;
      z-index: 0;
    }

    .app {
      max-width: 1400px;
      width: 100%;
      margin: 20px auto;
      padding: 24px;
      border-radius: 24px;
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.95) 0%, rgba(30, 41, 59, 0.9) 100%);
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      gap: 16px;
      position: relative;
      z-index: 1;
      backdrop-filter: blur(10px);
      box-sizing: border-box;
    }

    header {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 24px;
      padding: 40px 24px;
      border-bottom: 2px solid rgba(239, 68, 68, 0.2);
      margin: -24px -24px 24px -24px;
      background: #000000;
      border-radius: 12px 12px 0 0;
      min-height: 180px;
    }

    .title {
      display: flex;
      align-items: center;
      gap: 24px;
      flex: 1;
    }

    .badge {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      padding: 4px 12px;
      border-radius: 999px;
      border: 1px solid rgba(239, 68, 68, 0.5);
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.2) 0%, rgba(249, 115, 22, 0.15) 100%);
      color: #fecaca;
      font-weight: 600;
      box-shadow: 0 0 12px rgba(239, 68, 68, 0.3);
      animation: pulse-glow 2s ease-in-out infinite;
    }

    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 0 12px rgba(239, 68, 68, 0.3); }
      50% { box-shadow: 0 0 20px rgba(239, 68, 68, 0.5); }
    }

    h1 {
      margin: 0;
      font-size: 1.8rem;
      font-weight: 800;
      display: flex;
      align-items: center;
      gap: 12px;
      background: linear-gradient(135deg, #ffffff 0%, #fecaca 50%, #fbbf24 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 30px rgba(239, 68, 68, 0.3);
    }

    h1 span.logo {
      width: 40px;
      height: 40px;
      border-radius: 12px;
      background: linear-gradient(135deg, #f97316 0%, #ef4444 50%, #dc2626 100%);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      transform: rotate(-8deg);
      box-shadow: 
        0 4px 12px rgba(239, 68, 68, 0.4),
        0 0 20px rgba(249, 115, 22, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      animation: fire-flicker 3s ease-in-out infinite;
      position: relative;
    }

    h1 span.logo::after {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(135deg, #f97316, #ef4444, #f97316);
      border-radius: 12px;
      z-index: -1;
      opacity: 0.5;
      filter: blur(8px);
      animation: fire-flicker 3s ease-in-out infinite;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }

    @keyframes fire-flicker {
      0%, 100% { transform: rotate(-8deg) scale(1); }
      25% { transform: rotate(-6deg) scale(1.05); }
      50% { transform: rotate(-10deg) scale(0.98); }
      75% { transform: rotate(-7deg) scale(1.02); }
    }

    .subtitle {
      margin: 4px 0 0 0;
      font-size: 0.9rem;
      color: #cbd5e1;
      font-weight: 400;
      letter-spacing: 0.02em;
    }

    .layout {
      display: grid;
      grid-template-columns: 1.2fr 1fr;
      gap: 12px;
    }

    /* Responsive Styles */
    @media (max-width: 1280px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }

    /* Tablet Styles */
    @media (max-width: 1024px) {
      body {
        padding: 0;
      }
      
      .app {
        margin: 20px auto;
        padding: 20px;
        border-radius: 20px;
        width: 100%;
        box-sizing: border-box;
      }
      
      header {
        flex-direction: column;
        align-items: flex-start;
        gap: 16px;
        padding: 32px 20px;
        min-height: auto;
      }
      
      .title {
        flex-direction: row;
        align-items: center;
        gap: 16px;
        width: 100%;
      }
      
      h1 {
        font-size: 1.6rem;
        line-height: 1.2;
      }
      
      h1 span.logo {
        width: 44px;
        height: 44px;
        font-size: 22px;
        flex-shrink: 0;
      }
      
      .card {
        padding: 20px;
      }
      
      .feedback-grid {
        grid-template-columns: 1fr;
      }
      
      .question-controls {
        flex-wrap: wrap;
      }
      
      .video-wrapper {
        max-height: 400px;
      }
    }
    
    @media (max-width: 768px) {
      .app {
        margin: 8px;
        padding: 16px;
        border-radius: 16px;
      }
      
      header {
        padding: 20px 16px;
        gap: 16px;
        flex-wrap: wrap;
      }
      
      header .title {
        width: 100%;
        gap: 12px;
        flex-wrap: nowrap;
      }
      
      /* Logo - better scaling and presentation */
      header .title > div:first-child {
        flex-shrink: 0;
      }
      
      header .title img#logoImage {
        max-height: 90px;
        width: auto;
        height: auto;
        object-fit: contain;
        display: block;
      }
      
      header .title svg {
        max-height: 90px;
        width: auto;
      }
      
      h1 {
        font-size: 1.5rem;
        flex-wrap: nowrap;
      }
      
      .subtitle {
        font-size: 0.85rem;
      }
      
      /* Keep card headers horizontal */
      .card-header {
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
      }
      
      .card-title {
        font-size: 1rem;
      }
      
      button {
        font-size: 0.9rem;
        padding: 12px 18px;
        min-height: 44px;
      }
      
      /* Much larger, more visible checkboxes */
      input[type="checkbox"] {
        width: 28px !important;
        height: 28px !important;
        min-width: 28px !important;
        min-height: 28px !important;
        accent-color: #ef4444;
        cursor: pointer;
        flex-shrink: 0;
        margin-right: 12px !important;
        margin-top: 2px !important;
      }
      
      /* Better spacing for checkbox labels */
      label {
        display: flex;
        align-items: flex-start;
        gap: 10px;
      }
      
      .video-wrapper {
        max-height: 300px;
      }
      
      video, canvas {
        max-height: 300px;
      }
    }
    
    @media (max-width: 480px) {
      .app {
        margin: 4px;
        padding: 12px;
        border-radius: 12px;
      }
      
      header {
        padding: 16px 12px;
        gap: 12px;
      }
      
      /* Logo on small screens - still visible */
      header .title img#logoImage {
        max-height: 75px;
      }
      
      header .title svg {
        max-height: 75px;
      }
      
      h1 {
        font-size: 1.35rem;
      }
      
      .card {
        padding: 16px;
        border-radius: 14px;
      }
      
      /* Large checkboxes on small screens */
      input[type="checkbox"] {
        width: 30px !important;
        height: 30px !important;
        min-width: 30px !important;
        min-height: 30px !important;
      }
      
      button {
        font-size: 0.875rem;
        padding: 12px 16px;
        min-height: 44px;
      }
      
      .video-wrapper {
        max-height: 250px;
      }
      
      video, canvas {
        max-height: 250px;
      }
    }
    
    /* Extra small devices */
    @media (max-width: 360px) {
      .app {
        padding: 10px;
      }
      
      header {
        padding: 12px 10px;
      }
      
      header .title img#logoImage {
        max-height: 65px;
      }
      
      h1 {
        font-size: 1.2rem;
      }
      
      .card {
        padding: 14px;
      }
      
      input[type="checkbox"] {
        width: 28px !important;
        height: 28px !important;
      }
      
      button {
        font-size: 0.85rem;
        padding: 11px 14px;
      }
    }

    .card {
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.95) 0%, rgba(30, 41, 59, 0.9) 100%);
      border-radius: 20px;
      padding: 20px;
      border: 1px solid rgba(239, 68, 68, 0.15);
      display: flex;
      flex-direction: column;
      gap: 12px;
      box-shadow: 
        0 4px 16px rgba(0, 0, 0, 0.3),
        0 0 0 1px rgba(239, 68, 68, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.05);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, transparent, rgba(239, 68, 68, 0.5), transparent);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .card:hover {
      border-color: rgba(239, 68, 68, 0.3);
      box-shadow: 
        0 8px 24px rgba(0, 0, 0, 0.4),
        0 0 0 1px rgba(239, 68, 68, 0.2),
        0 0 30px rgba(239, 68, 68, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.08);
      transform: translateY(-2px);
    }

    .card:hover::before {
      opacity: 1;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
    }

    .card-title {
      font-size: 1rem;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 8px;
      color: #f9fafb;
      letter-spacing: 0.01em;
    }

    .card-title small {
      font-size: 0.75rem;
      font-weight: 400;
      color: #cbd5e1;
      opacity: 0.8;
    }

    .left, .right {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    label.file-label {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      cursor: pointer;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px dashed rgba(148, 163, 184, 0.5);
      font-size: 0.8rem;
      color: #e5e7eb;
    }

    label.file-label span.icon {
      font-size: 1rem;
    }

    input[type="file"] {
      display: none;
    }

    .resume-summary {
      font-size: 0.75rem;
      color: #9ca3af;
      max-height: 90px;
      overflow-y: auto;
      padding-right: 4px;
    }

    .resume-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 4px;
    }

    .tag {
      font-size: 0.7rem;
      padding: 4px 10px;
      border-radius: 999px;
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.2) 0%, rgba(249, 115, 22, 0.15) 100%);
      color: #fecaca;
      border: 1px solid rgba(239, 68, 68, 0.3);
      font-weight: 500;
      transition: all 0.2s ease;
    }

    .tag:hover {
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.3) 0%, rgba(249, 115, 22, 0.25) 100%);
      border-color: rgba(239, 68, 68, 0.5);
      transform: scale(1.05);
    }

    button {
      border-radius: 12px;
      border: none;
      padding: 12px 20px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      color: #fff;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 
        0 4px 12px rgba(239, 68, 68, 0.3),
        0 0 0 0 rgba(239, 68, 68, 0.5);
      position: relative;
      overflow: hidden;
      letter-spacing: 0.02em;
    }

    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s ease;
    }

    button:hover::before {
      left: 100%;
    }

    button:hover {
      background: linear-gradient(135deg, #f97316 0%, #ef4444 100%);
      transform: translateY(-2px);
      box-shadow: 
        0 8px 20px rgba(239, 68, 68, 0.5),
        0 0 30px rgba(249, 115, 22, 0.4),
        0 0 0 2px rgba(239, 68, 68, 0.3);
    }

    button.secondary {
      background: linear-gradient(135deg, rgba(55, 65, 81, 0.9) 0%, rgba(30, 41, 59, 0.9) 100%);
      color: #e5e7eb;
      border: 1px solid rgba(148, 163, 184, 0.2);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    button.secondary:hover {
      background: linear-gradient(135deg, rgba(75, 85, 99, 0.95) 0%, rgba(55, 65, 81, 0.95) 100%);
      border-color: rgba(239, 68, 68, 0.3);
      box-shadow: 
        0 4px 12px rgba(0, 0, 0, 0.3),
        0 0 20px rgba(239, 68, 68, 0.1);
    }

    button.ghost {
      background: transparent;
      color: #cbd5e1;
      padding: 6px 12px;
      border-radius: 8px;
      border: 1px solid rgba(148, 163, 184, 0.2);
      transition: all 0.2s ease;
    }

    button.ghost:hover {
      background: rgba(239, 68, 68, 0.1);
      border-color: rgba(239, 68, 68, 0.3);
      color: #fecaca;
    }

    button:active {
      transform: translateY(0);
      box-shadow: 
        0 2px 8px rgba(239, 68, 68, 0.4),
        0 0 0 1px rgba(239, 68, 68, 0.3);
    }

    button[disabled] {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .question-text {
      min-height: 40px;
      font-size: 0.9rem;
      line-height: 1.4;
      color: #e5e7eb;
    }

    .question-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      font-size: 0.7rem;
      color: #9ca3af;
    }

    .question-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-top: 4px;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #16a34a;
    }

    .status-dot.off {
      background: #991b1b;
    }

    .status {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.8rem;
      color: #9ca3af;
    }

    .transcript {
      background: rgba(15, 23, 42, 0.9);
      border-radius: 10px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      padding: 6px 8px;
      min-height: 52px;
      font-size: 0.75rem;
      color: #e5e7eb;
      overflow-y: auto;
      max-height: 110px;
    }

    .feedback-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
      font-size: 0.75rem;
    }

    @media (max-width: 600px) {
      .feedback-grid {
        grid-template-columns: 1fr;
      }
    }

    .feedback-block {
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.95) 0%, rgba(30, 41, 59, 0.9) 100%);
      border-radius: 12px;
      border: 1px solid rgba(239, 68, 68, 0.15);
      padding: 12px;
      transition: all 0.2s ease;
    }

    .feedback-block:hover {
      border-color: rgba(239, 68, 68, 0.3);
      box-shadow: 0 2px 8px rgba(239, 68, 68, 0.1);
    }

    .feedback-block h4 {
      margin: 0 0 8px 0;
      font-size: 0.85rem;
      font-weight: 700;
      color: #f9fafb;
      letter-spacing: 0.01em;
    }

    .feedback-block p {
      margin: 0;
      color: #cbd5e1;
      line-height: 1.5;
      font-size: 0.8rem;
    }

    .score-pill {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(34, 197, 94, 0.15);
      color: #bbf7d0;
    }

    .score-pill.mid {
      background: rgba(234, 179, 8, 0.15);
      color: #facc15;
    }

    .score-pill.low {
      background: rgba(248, 113, 113, 0.15);
      color: #fecaca;
    }

    .video-wrapper {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      background: #020617;
      border: 1px solid rgba(30, 64, 175, 0.7);
      aspect-ratio: 4 / 3;
    }

    video, canvas {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    canvas {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .video-overlay {
      position: absolute;
      inset: auto 8px 8px 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 6px;
      border-radius: 10px;
      background: linear-gradient(to right, rgba(15, 23, 42, 0.9), rgba(30, 64, 175, 0.8));
      font-size: 0.7rem;
      color: #e5e7eb;
    }

    .video-overlay span.label {
      text-transform: uppercase;
      font-size: 0.65rem;
      letter-spacing: 0.12em;
      color: #93c5fd;
    }

    .video-overlay span.value {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .metrics-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      font-size: 0.7rem;
      color: #9ca3af;
      margin-top: 4px;
    }

    .metric-chip {
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
    }

    .small-note {
      font-size: 0.7rem;
      color: #6b7280;
    }

    /* AI Feedback Modal */
    .ai-modal-overlay {
      display: none !important;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.9);
      z-index: 99999;
      align-items: center;
      justify-content: center;
      padding: 20px;
      overflow-y: auto;
      backdrop-filter: blur(5px);
      box-sizing: border-box;
    }

    .ai-modal-overlay.active {
      display: flex !important;
    }

    .ai-modal {
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.95) 100%);
      border-radius: 24px;
      padding: 32px;
      width: 90%;
      max-width: 900px;
      max-height: 85vh;
      overflow-y: auto;
      box-shadow: 0 24px 60px rgba(0, 0, 0, 0.9);
      border: none;
      position: relative;
      margin: 0;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-self: center;
    }

    .ai-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 16px;
      border-bottom: 1px solid rgba(239, 68, 68, 0.3);
    }

    .ai-modal-header h3 {
      margin: 0;
      font-size: 1.5rem;
      color: #fbbf24;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .ai-modal-close {
      background: none;
      border: none;
      color: #9ca3af;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      transition: all 0.2s;
    }

    .ai-modal-close:hover {
      background: rgba(239, 68, 68, 0.2);
      color: #fca5a5;
    }

    .ai-modal-content {
      font-size: 0.95rem;
      line-height: 1.7;
      color: #e5e7eb;
      flex: 1;
      overflow-y: auto;
      min-height: 0;
    }

    .ai-modal-content h4 {
      margin: 20px 0 12px 0;
      color: #fbbf24;
      font-size: 1.1rem;
      font-weight: 600;
    }

    .ai-modal-content div {
      margin-bottom: 12px;
    }

    .ai-modal-content .bullet-point {
      margin-left: 20px;
      margin-bottom: 8px;
      color: #e5e7eb;
    }

    .ai-modal-content .score-highlight {
      color: #fbbf24;
      font-weight: 600;
      font-size: 1.1rem;
    }

    /* General Modal Styles (for paywall, credit purchase, auth) */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.85);
      z-index: 99998;
      align-items: center;
      justify-content: center;
      padding: 20px;
      overflow-y: auto;
      backdrop-filter: blur(5px);
      box-sizing: border-box;
    }

    .modal-overlay.active {
      display: flex !important;
    }

    .modal {
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.95) 100%);
      border-radius: 16px;
      padding: 24px;
      width: 90%;
      max-width: 600px;
      max-height: 85vh;
      overflow-y: auto;
      box-shadow: 0 24px 60px rgba(0, 0, 0, 0.9);
      border: 1px solid rgba(239, 68, 68, 0.2);
      position: relative;
      box-sizing: border-box;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 16px;
      border-bottom: 1px solid rgba(239, 68, 68, 0.3);
    }

    .modal-header h3 {
      margin: 0;
      font-size: 1.3rem;
      color: #fbbf24;
    }

    .modal-close {
      background: none;
      border: none;
      color: #9ca3af;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      transition: all 0.2s;
    }

    .modal-close:hover {
      background: rgba(239, 68, 68, 0.2);
      color: #fca5a5;
    }

    .modal-content {
      color: #e5e7eb;
    }

    /* Credit Bundle Cards */
    .credit-bundle-card {
      padding: 20px;
      border: 2px solid rgba(148, 163, 184, 0.3);
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.5);
      cursor: pointer;
      transition: all 0.3s;
      text-align: center;
    }

    .credit-bundle-card:hover {
      border-color: #fbbf24;
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(251, 191, 36, 0.3);
    }

    .credit-bundle-card.selected {
      border-color: #fbbf24;
      background: rgba(251, 191, 36, 0.1);
    }

    .credit-bundle-card h4 {
      margin: 0 0 8px 0;
      color: #fbbf24;
      font-size: 1.1rem;
    }

    .credit-bundle-card .credits {
      font-size: 1.5rem;
      font-weight: 700;
      color: #fff;
      margin: 8px 0;
    }

    .credit-bundle-card .price {
      font-size: 1.2rem;
      color: #94a3b8;
      margin: 8px 0;
    }

    .credit-bundle-card .sessions {
      font-size: 0.85rem;
      color: #64748b;
      margin-top: 8px;
    }

    /* Autocomplete Suggestions */
    .suggestion-item {
      padding: 10px 12px;
      cursor: pointer;
      color: #e2e8f0;
      font-size: 0.9rem;
      border-bottom: 1px solid rgba(239, 68, 68, 0.1);
      transition: background 0.2s;
    }

    .suggestion-item:hover {
      background: rgba(239, 68, 68, 0.15);
    }

    .suggestion-item:last-child {
      border-bottom: none;
    }

    .suggestion-item .suggestion-main {
      font-weight: 500;
      color: #fca5a5;
    }

    .suggestion-item .suggestion-detail {
      font-size: 0.8rem;
      color: #94a3b8;
      margin-top: 2px;
    }

    .suggestion-loading {
      padding: 12px;
      text-align: center;
      color: #94a3b8;
      font-size: 0.85rem;
    }
    
    /* Range Slider Styling for Mobile-Friendly Feedback Form */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: rgba(148, 163, 184, 0.2);
      outline: none;
      cursor: pointer;
    }
    
    /* Webkit (Chrome, Safari, Edge) */
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(239, 68, 68, 0.4);
      transition: all 0.2s;
    }
    
    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.1);
      box-shadow: 0 3px 8px rgba(239, 68, 68, 0.6);
    }
    
    input[type="range"]::-webkit-slider-thumb:active {
      transform: scale(0.95);
    }
    
    /* Firefox */
    input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 6px rgba(239, 68, 68, 0.4);
      transition: all 0.2s;
    }
    
    input[type="range"]::-moz-range-thumb:hover {
      transform: scale(1.1);
      box-shadow: 0 3px 8px rgba(239, 68, 68, 0.6);
    }
    
    input[type="range"]::-moz-range-track {
      height: 8px;
      border-radius: 4px;
      background: rgba(148, 163, 184, 0.2);
    }
    
    /* Multi-select dropdown styling for mobile */
    select[multiple] {
      min-height: 120px;
      padding: 12px;
      border-radius: 8px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: #1e293b;
      color: #fff;
      font-size: 0.95rem;
      cursor: pointer;
    }
    
    select[multiple] option {
      padding: 8px;
      margin: 2px 0;
      border-radius: 4px;
      cursor: pointer;
    }
    
    select[multiple] option:checked {
      background: rgba(239, 68, 68, 0.3);
      color: #fca5a5;
    }
    
    select[multiple] option:hover {
      background: rgba(239, 68, 68, 0.2);
    }
    
    /* Disabled select options styling */
    select option:disabled {
      color: #64748b !important;
      background-color: rgba(100, 116, 139, 0.1) !important;
      cursor: not-allowed !important;
      opacity: 0.6;
    }
    
    /* Mobile-friendly select styling */
    select:not([multiple]) {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-image: url('data:image/svg+xml;utf8,<svg fill="%23cbd5e1" height="20" viewBox="0 0 24 24" width="20" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/></svg>');
      background-repeat: no-repeat;
      background-position: right 12px center;
      padding-right: 40px;
    }
  </style>
  <!-- PDF.js for PDF text extraction -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <script>
    // Configure PDF.js worker to fix deprecation warning
    if (typeof pdfjsLib !== 'undefined') {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    }
  </script>
</head>
<body>

<!-- Flagged Questions Modal -->
<div id="flaggedModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 10002; display: none; align-items: center; justify-content: center; padding: 20px; backdrop-filter: blur(5px);">
  <div style="background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.98) 100%); border: 2px solid rgba(239, 68, 68, 0.3); border-radius: 16px; padding: 24px; max-width: 700px; width: 100%; max-height: 80vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(239, 68, 68, 0.3);">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
      <h2 style="color: #ef4444; font-size: 1.5em; margin: 0;">üö© Flagged Questions</h2>
      <button id="closeFlaggedModal" style="background: transparent; border: none; color: #cbd5e1; font-size: 1.5rem; cursor: pointer; padding: 4px 8px; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(239, 68, 68, 0.2)'" onmouseout="this.style.background='transparent'">√ó</button>
    </div>
    <div id="flaggedQuestionsList" style="display: flex; flex-direction: column; gap: 12px;">
      <p style="color: #94a3b8; text-align: center; padding: 20px;">No flagged questions yet. Flag questions you find difficult to practice them later.</p>
    </div>
  </div>
</div>

<!-- Practice Insights Modal -->
<div id="areasToWorkOnModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 10003; display: none; align-items: center; justify-content: center; padding: 20px; backdrop-filter: blur(5px);">
  <div style="background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.98) 100%); border: 2px solid rgba(251, 191, 36, 0.3); border-radius: 16px; padding: 24px; max-width: 700px; width: 100%; max-height: 80vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(251, 191, 36, 0.3);">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
      <h2 style="color: #fbbf24; font-size: 1.5em; margin: 0;">üí° Practice Insights</h2>
      <button id="closeAreasToWorkOnModal" style="background: transparent; border: none; color: #cbd5e1; font-size: 1.5rem; cursor: pointer; padding: 4px 8px; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(251, 191, 36, 0.2)'" onmouseout="this.style.background='transparent'">√ó</button>
    </div>
    <div id="areasToWorkOnContent" style="color: #e5e7eb; line-height: 1.7; font-size: 1rem;">
      <div style="text-align: center; padding: 40px; color: #94a3b8;">
        <div style="font-size: 2rem; margin-bottom: 12px;">ü§ñ</div>
        <p>Analyzing your answers...</p>
        <p style="font-size: 0.9rem; margin-top: 8px;">This will update as you answer more questions</p>
      </div>
    </div>
  </div>
</div>

<!-- Terms & Privacy Acceptance Modal -->
<div id="termsModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 10000; display: none; align-items: center; justify-content: center; padding: 20px; backdrop-filter: blur(5px);">
  <div style="background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.98) 100%); border: 2px solid rgba(239, 68, 68, 0.3); border-radius: 16px; padding: 40px; max-width: 600px; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(239, 68, 68, 0.3);">
    <div style="text-align: center; margin-bottom: 30px;">
      <h2 style="color: #ef4444; font-size: 2em; margin-bottom: 10px;">üî• Welcome to Fire Interview Coach</h2>
      <p style="color: #cbd5e1; font-size: 1.1em;">Please review and accept our terms to continue</p>
    </div>
    
    <div style="background: rgba(239, 68, 68, 0.1); border-left: 4px solid #ef4444; padding: 15px; margin-bottom: 25px; border-radius: 4px;">
      <p style="color: #fca5a5; margin: 0; font-size: 0.95em;">
        <strong>Important:</strong> Fire Interview Coach is a practice tool only and does not guarantee job offers or employment.
      </p>
    </div>
    
    <div style="margin-bottom: 25px;">
      <label style="display: flex; align-items: flex-start; cursor: pointer; color: #e2e8f0; margin-bottom: 15px;">
        <input type="checkbox" id="acceptTerms" style="margin-right: 12px; margin-top: 4px; width: 20px; height: 20px; cursor: pointer; accent-color: #ef4444;">
        <span style="line-height: 1.6;">
          I have read and agree to the <a href="terms-of-service.html" target="_blank" style="color: #fca5a5; text-decoration: underline;">Terms of Service</a>
        </span>
      </label>
      
      <label style="display: flex; align-items: flex-start; cursor: pointer; color: #e2e8f0;">
        <input type="checkbox" id="acceptPrivacy" style="margin-right: 12px; margin-top: 4px; width: 20px; height: 20px; cursor: pointer; accent-color: #ef4444;">
        <span style="line-height: 1.6;">
          I have read and agree to the <a href="privacy-policy.html" target="_blank" style="color: #fca5a5; text-decoration: underline;">Privacy Policy</a>
        </span>
      </label>
    </div>
    
    <div style="display: flex; gap: 15px; justify-content: center;">
      <button id="acceptTermsBtn" style="padding: 14px 28px; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: #fff; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);" disabled>
        Accept & Continue
      </button>
    </div>
    
    <p style="text-align: center; margin-top: 20px; color: #94a3b8; font-size: 0.85em;">
      You must accept both terms to use Fire Interview Coach
    </p>
  </div>
</div>

<!-- Onboarding Modal -->
<div id="onboardingModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 10001; display: none; align-items: center; justify-content: center; padding: 20px; backdrop-filter: blur(5px); overflow-y: auto;">
  <div style="background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.98) 100%); border: 2px solid rgba(239, 68, 68, 0.3); border-radius: 16px; padding: 40px; max-width: 700px; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(239, 68, 68, 0.3);">
    <div style="text-align: center; margin-bottom: 30px;">
      <h2 style="color: #ef4444; font-size: 2em; margin-bottom: 10px;">üéØ Let's Get Started</h2>
      <p style="color: #cbd5e1; font-size: 1.1em;">Help us personalize your interview practice</p>
    </div>
    
    <!-- Login option for existing users - moved to top for visibility -->
    <div style="margin-bottom: 24px; padding: 16px; background: rgba(251, 191, 36, 0.1); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 8px; text-align: center;">
      <p style="color: #fbbf24; font-size: 0.95rem; margin: 0 0 10px 0; font-weight: 600;">üîê Already have an account?</p>
      <button id="onboardingLoginBtn" type="button" class="ghost" style="padding: 10px 24px; font-size: 0.95rem; border: 1px solid rgba(251, 191, 36, 0.5); color: #fbbf24;">Log in to restore your data</button>
    </div>
    
    <form id="onboardingForm" style="display: flex; flex-direction: column; gap: 20px;">
      <!-- Resume Upload (Optional) -->
      <div>
        <label style="display: block; color: #e2e8f0; font-weight: 600; margin-bottom: 8px; font-size: 0.95rem;" id="onboardingResumeLabel">
          1. Upload Resume <span style="color: #94a3b8; font-weight: 400;">(Optional)</span>
        </label>
        <label class="file-label" style="display: flex; align-items: center; gap: 8px; padding: 12px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(239, 68, 68, 0.2); border-radius: 8px; cursor: pointer; transition: all 0.2s;">
          <span class="icon">üìÑ</span>
          <span style="flex: 1; color: #cbd5e1;" id="onboardingResumeButtonText">Upload resume (.txt / PDF)</span>
          <input type="file" id="onboardingResumeInput" accept=".txt,.pdf,.doc,.docx,.rtf" style="display: none;" />
        </label>
        <div id="onboardingResumeStatus" style="margin-top: 8px; font-size: 0.85rem; color: #94a3b8; min-height: 20px;"></div>
      </div>

      <!-- Location Selection - Mapbox Autocomplete -->
      <div>
        <label style="display: block; color: #e2e8f0; font-weight: 600; margin-bottom: 8px; font-size: 0.95rem;" id="onboardingLocationLabel">
          2. What City are you applying to? <span style="color: #ef4444;">*</span>
        </label>
        <div style="position: relative;">
          <input type="text" id="onboardingCity" placeholder="Search for a city worldwide..." required autocomplete="off" style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px; color: #e2e8f0; font-size: 0.95rem;">
          <div id="mapboxSuggestions" style="position: absolute; top: 100%; left: 0; right: 0; background: rgba(15, 23, 42, 0.98); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px; margin-top: 4px; max-height: 250px; overflow-y: auto; z-index: 10002; display: none; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);"></div>
        </div>
        <input type="hidden" id="selectedCityData" />
        <p style="margin-top: 6px; font-size: 0.8rem; color: #94a3b8;">Start typing to search cities worldwide</p>
      </div>

      <!-- Job Type Selection -->
      <div>
        <label style="display: block; color: #e2e8f0; font-weight: 600; margin-bottom: 8px; font-size: 0.95rem;" id="onboardingJobTypeLabel">
          3. What are you applying for? <span style="color: #ef4444;">*</span>
        </label>
        <select id="onboardingJobType" required style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px; color: #e2e8f0; font-size: 0.95rem; cursor: pointer;">
          <option value="" id="onboardingJobTypePlaceholder">Select Position Type</option>
          <option value="Fire" id="onboardingJobTypeFire">Fire</option>
          <option value="Police" id="onboardingJobTypePolice" disabled style="color: #64748b; background: rgba(100, 116, 139, 0.1);">Police (Coming Soon)</option>
          <option value="Paramedic" id="onboardingJobTypeParamedic" disabled style="color: #64748b; background: rgba(100, 116, 139, 0.1);">Paramedic (Coming Soon)</option>
          <option value="First Responder" id="onboardingJobTypeFirstResponder" disabled style="color: #64748b; background: rgba(100, 116, 139, 0.1);">First Responder (Coming Soon)</option>
          <option value="Dispatcher" id="onboardingJobTypeDispatcher" disabled style="color: #64748b; background: rgba(100, 116, 139, 0.1);">Dispatcher (Coming Soon)</option>
        </select>
        <p style="margin-top: 6px; font-size: 0.8rem; color: #94a3b8;">Other position types will be available in future updates</p>
      </div>

      <!-- Department Name -->
      <div>
        <label style="display: block; color: #e2e8f0; font-weight: 600; margin-bottom: 8px; font-size: 0.95rem;" id="onboardingDepartmentLabel">
          4. Department Name <span style="color: #ef4444;">*</span>
        </label>
        <input type="text" id="onboardingDepartmentName" placeholder="e.g., Abbotsford Fire Department" required style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px; color: #e2e8f0; font-size: 0.95rem;">
        <p style="margin-top: 6px; font-size: 0.8rem; color: #94a3b8;" id="onboardingDepartmentHelper">This will be used to personalize your interview questions</p>
      </div>

      <!-- Name (Optional) -->
      <div>
        <label style="display: block; color: #e2e8f0; font-weight: 600; margin-bottom: 8px; font-size: 0.95rem;" id="onboardingNameLabel">
          5. Your Name <span style="color: #94a3b8; font-weight: 400;">(Optional)</span>
        </label>
        <input type="text" id="onboardingName" placeholder="e.g., John Smith" style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px; color: #e2e8f0; font-size: 0.95rem;">
        <p style="margin-top: 6px; font-size: 0.8rem; color: #94a3b8;">AI will address you by name in some questions</p>
      </div>

      <!-- Voice Selection -->
      <div>
        <label style="display: block; color: #e2e8f0; font-weight: 600; margin-bottom: 8px; font-size: 0.95rem;" id="onboardingVoiceLabel">
          6. Voice Preference <span style="color: #94a3b8; font-weight: 400;">(Optional)</span>
        </label>
        <select id="onboardingVoice" style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px; color: #e2e8f0; font-size: 0.95rem; cursor: pointer;">
          <option value="">Default (Auto)</option>
          <option value="male">Male Voice</option>
          <option value="female">Female Voice</option>
        </select>
        <p style="margin-top: 6px; font-size: 0.8rem; color: #94a3b8;">Choose your preferred voice for question narration</p>
      </div>

      <!-- Submit Button -->
      <div style="display: flex; gap: 15px; justify-content: center; margin-top: 10px;">
        <button type="submit" id="onboardingSubmitBtn" style="padding: 14px 28px; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: #fff; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);">Start Practice Session</button>
      </div>
      
      <p style="text-align: center; margin-top: 10px; color: #94a3b8; font-size: 0.85em;" id="onboardingRequiredFields">
        <span style="color: #ef4444;">*</span> Required fields
      </p>
    </form>
  </div>
</div>

<div class="app" id="mainApp" style="display: none;">
  <header>
    <div class="title" style="display: flex; align-items: center; justify-content: space-between; width: 100%; height: 100%; padding: 0 24px;">
      <!-- Logo - Left Side -->
      <div style="display: flex; align-items: center; justify-content: flex-start; flex: 1;">
        <img id="logoImage" src="banner-logo.png" alt="Interview Coach AI Logo" 
             style="height: auto; max-height: 120px; object-fit: contain; display: block;"
             onerror="console.error('Logo image failed to load:', this.src); this.style.display='none'; this.nextElementSibling.style.display='block';">
        <!-- Fallback SVG if logo image not found -->
        <svg width="500" height="120" viewBox="0 0 90 90" style="display: none; max-height: 120px;">
          <!-- Maltese Cross Background -->
          <path d="M45 12 L50 32 L70 32 L55 44 L60 64 L45 52 L30 64 L35 44 L20 32 L40 32 Z" 
                fill="none" 
                stroke="#94a3b8" 
                stroke-width="2.5" 
                stroke-linejoin="round"
                opacity="0.8"/>
          <!-- Flame Icon (center) -->
          <g transform="translate(45, 30)">
            <path d="M0 -5 L-2 5 L0 8 L2 5 Z" fill="#f97316"/>
            <path d="M0 -5 L-1.5 0 L0 3 L1.5 0 Z" fill="#fb923c"/>
            <circle cx="0" cy="-2" r="1.5" fill="#fbbf24"/>
          </g>
          <!-- Signal/WiFi Lines (below flame) -->
          <path d="M45 48 Q50 46 55 48" 
                fill="none" 
                stroke="#f97316" 
                stroke-width="2.5" 
                stroke-linecap="round"/>
          <path d="M45 51 Q53 48 61 51" 
                fill="none" 
                stroke="#f97316" 
                stroke-width="2.5" 
                stroke-linecap="round"/>
          <path d="M45 54 Q55 50 65 54" 
                fill="none" 
                stroke="#f97316" 
                stroke-width="2.5" 
                stroke-linecap="round"/>
          <!-- IH Letters (left arm) -->
          <text x="22" y="55" font-family="Arial, sans-serif" font-size="9" fill="#94a3b8" font-weight="bold" opacity="0.9">I</text>
          <text x="22" y="65" font-family="Arial, sans-serif" font-size="9" fill="#94a3b8" font-weight="bold" opacity="0.9">H</text>
          <!-- Asterisk (right arm) -->
          <text x="63" y="60" font-family="Arial, sans-serif" font-size="12" fill="#94a3b8" opacity="0.9">*</text>
        </svg>
      </div>
      
      <!-- Credits & Auth - Right Side -->
      <div id="headerAuthSection" style="display: flex; align-items: center; gap: 16px; flex-shrink: 0;">
        <!-- Credits Display (shown when logged in) -->
        <div id="creditsDisplay" style="display: none; padding: 8px 16px; background: rgba(251, 191, 36, 0.1); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 8px; font-size: 0.9rem; cursor: pointer; transition: all 0.2s;" 
             onmouseover="this.style.background='rgba(251, 191, 36, 0.15)'; this.style.borderColor='rgba(251, 191, 36, 0.5)'" 
             onmouseout="this.style.background='rgba(251, 191, 36, 0.1)'; this.style.borderColor='rgba(251, 191, 36, 0.3)'"
             onclick="showCreditPurchaseModal()">
          <span style="color: #fbbf24; font-weight: 600;">Credits: <span id="creditsCount">0</span></span>
        </div>
        
        <!-- Trial Credits Display (shown for anonymous users) -->
        <div id="trialCreditsDisplay" style="display: none; position: relative;">
          <div id="trialCreditsBtn" style="padding: 8px 16px; background: rgba(148, 163, 184, 0.1); border: 1px solid rgba(148, 163, 184, 0.3); border-radius: 8px; font-size: 0.9rem; cursor: pointer; transition: all 0.2s;" 
               onmouseover="this.style.background='rgba(148, 163, 184, 0.2)'" 
               onmouseout="this.style.background='rgba(148, 163, 184, 0.1)'">
            <span style="color: #94a3b8;">Free Questions: <span id="trialCreditsCount">3</span></span>
          </div>
          <div id="trialCreditsDropdown" style="display: none; position: absolute; top: 100%; right: 0; margin-top: 8px; background: #1e293b; border: 1px solid rgba(148, 163, 184, 0.3); border-radius: 8px; padding: 16px; min-width: 280px; z-index: 1000; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);">
            <p style="color: #cbd5e1; font-size: 0.9rem; margin: 0 0 12px 0; line-height: 1.5;">
              You have <strong style="color: #fbbf24;"><span id="trialCreditsCountDropdown">3</span> free questions</strong> to try the interview coach. Each question includes AI feedback on your answer.
            </p>
            <p style="color: #94a3b8; font-size: 0.85rem; margin: 0 0 16px 0; line-height: 1.4;">
              To unlock detailed feedback, 10/10 answers, and unlimited practice, purchase credits after signup.
            </p>
            <button class="primary" onclick="window.showCreditPurchaseModal(); document.getElementById('trialCreditsDropdown').style.display='none';" style="width: 100%; padding: 10px; font-size: 0.9rem; margin-top: 8px;">Buy More Credits</button>
          </div>
        </div>
        
        <!-- Auth Buttons -->
        <div id="authButtons" style="display: flex; gap: 8px;">
          <button id="loginBtn" class="ghost" style="padding: 8px 16px; font-size: 0.9rem;">Log in</button>
          <button id="signupBtn" class="primary" style="padding: 8px 16px; font-size: 0.9rem;">Sign up</button>
        </div>
        
        <!-- User Menu (shown when logged in) -->
        <div id="userMenu" style="display: none; position: relative;">
          <button id="userMenuBtn" class="ghost" style="padding: 8px 16px; font-size: 0.9rem; display: flex; align-items: center; gap: 8px;">
            <span id="userEmail">user@example.com</span>
            <span>‚ñº</span>
          </button>
          <div id="userMenuDropdown" style="display: none; position: absolute; top: 100%; right: 0; margin-top: 8px; background: #1e293b; border: 1px solid rgba(148, 163, 184, 0.3); border-radius: 8px; padding: 8px; min-width: 240px; z-index: 1000;">
            <!-- Redeem Referral Code Section -->
            <div style="padding: 12px; margin-bottom: 8px; border-bottom: 1px solid rgba(148, 163, 184, 0.2);">
              <h4 style="color: #fbbf24; margin: 0 0 8px 0; font-size: 0.85rem; font-weight: 600;">Redeem Referral Code</h4>
              <div style="display: flex; gap: 6px; align-items: center; margin-bottom: 6px;">
                <input type="text" id="dropdownRedeemReferralCode" placeholder="Enter code" style="flex: 1; padding: 8px; border-radius: 6px; border: 1px solid rgba(251, 191, 36, 0.5); background: #0f172a; color: #fff; font-size: 0.8rem; font-weight: 600; letter-spacing: 1px; text-transform: uppercase; text-align: center;" />
                <button id="dropdownRedeemReferralCodeBtn" class="secondary" style="padding: 8px 12px; font-size: 0.8rem; white-space: nowrap; border: 1px solid rgba(251, 191, 36, 0.5);">Redeem</button>
              </div>
              <p id="dropdownRedeemReferralStatus" style="color: #86efac; font-size: 0.75rem; margin: 4px 0 0 0; display: none; font-weight: 600;"></p>
              <p id="dropdownRedeemReferralError" style="color: #fca5a5; font-size: 0.75rem; margin: 4px 0 0 0; display: none;"></p>
            </div>
            <button id="settingsBtn" class="ghost" style="width: 100%; text-align: left; padding: 8px 12px; font-size: 0.9rem; margin-bottom: 4px;">Settings</button>
            <button id="logoutBtn" class="ghost" style="width: 100%; text-align: left; padding: 8px 12px; font-size: 0.9rem;">Log out</button>
          </div>
        </div>
      </div>
    </div>
  </header>

  <main class="layout">
    <!-- LEFT SIDE -->
    <section class="left">
      <!-- Resume card -->
      <div class="card">
        <div class="card-header">
          <div class="card-title">
            Resume
            <small>(tailors questions to your background)</small>
          </div>
          <button class="ghost" id="clearResumeBtn" type="button">Clear</button>
        </div>
        <div style="display: flex; flex-wrap: wrap; gap: 8px; align-items: center; margin-bottom: 6px;">
          <label class="file-label">
            <span class="icon">üìÑ</span>
            <span>Upload resume (PDF, DOC, DOCX, TXT, RTF)</span>
            <input type="file" id="resumeInput" accept=".txt,.pdf,.doc,.docx,.rtf" />
          </label>
        </div>
        <div style="padding: 12px; background: rgba(59, 130, 246, 0.1); border-radius: 8px; border: 1px solid rgba(59, 130, 246, 0.3); margin-bottom: 12px;">
          <div style="display: flex; align-items: flex-start; gap: 8px;">
            <span style="font-size: 1.2rem; flex-shrink: 0;">üîí</span>
            <div style="font-size: 0.85rem; line-height: 1.5; color: #cbd5e1;">
              <strong style="color: #93c5fd;">Your Privacy Matters:</strong> Your resume is processed locally in your browser and securely sent to our AI service only to generate personalized questions. We do not sell or share your data. 
              <a href="privacy-policy.html" target="_blank" style="color: #60a5fa; text-decoration: underline;">Read our Privacy Policy</a>
            </div>
          </div>
        </div>
        <div class="resume-summary" id="resumeSummary" style="padding: 16px; background: rgba(15, 23, 42, 0.6); border-radius: 8px; border: 1px solid rgba(239, 68, 68, 0.2); min-height: 120px;">
          <div style="color: #94a3b8; font-size: 0.9rem; text-align: center; padding: 20px;">
            No resume loaded yet. Upload a file to get personalized questions based on your experience.
          </div>
        </div>
        <div class="resume-tags" id="resumeTags" style="margin-top: 12px;"></div>
      </div>

      <!-- Question / mic card -->
      <div class="card">
        <div class="card-header">
          <div class="card-title">
            Interview Question
            <small id="questionCategoryLabel"></small>
          </div>
          <div class="question-controls">
            <button id="nextQuestionBtn" type="button">
              üé§ Start Interview
            </button>
            <button id="repeatQuestionBtn" class="secondary" type="button">
              üîÅ Repeat
            </button>
          </div>
        </div>
        
        <!-- Practice Mode Toggle -->
        <div style="padding: 12px; background: rgba(239, 68, 68, 0.1); border-radius: 8px; margin: 12px; border: 1px solid rgba(239, 68, 68, 0.2); position: relative;">
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
            <label style="display: block; font-size: 0.85rem; color: #cbd5e1; font-weight: 600; margin: 0;">Practice Mode:</label>
            <span style="background: rgba(251, 191, 36, 0.2); border: 1px solid rgba(251, 191, 36, 0.5); color: #fbbf24; padding: 2px 8px; border-radius: 8px; font-size: 0.7rem; font-weight: 600; letter-spacing: 0.5px;">V1</span>
          </div>
          <div style="display: flex; gap: 16px; margin-bottom: 8px; flex-wrap: wrap;">
            <label style="display: flex; align-items: center; cursor: pointer; color: #e2e8f0; font-size: 0.9rem;">
              <input type="checkbox" id="simulationMode" value="simulation" checked style="margin-right: 6px; accent-color: #ef4444; width: 16px; height: 16px; cursor: pointer;">
              <span>üé≤ Interview Simulation (Random)</span>
            </label>
            <label style="display: flex; align-items: center; cursor: pointer; color: #e2e8f0; font-size: 0.9rem;">
              <input type="checkbox" id="specificMode" value="specific" style="margin-right: 6px; accent-color: #ef4444; width: 16px; height: 16px; cursor: pointer;">
              <span>üéØ User-Specific Practice</span>
            </label>
            <label style="display: flex; align-items: center; cursor: pointer; color: #e2e8f0; font-size: 0.9rem;">
              <input type="checkbox" id="onlyFlaggedToggle" style="margin-right: 6px; accent-color: #ef4444; cursor: pointer; width: 16px; height: 16px;">
              <span>üö© Ask Only Flagged Questions</span>
            </label>
          </div>
          
          <!-- Category Selector (shown only in User-Specific mode) -->
          <div id="categorySelector" style="display: none; margin-top: 8px;">
            <label style="display: block; margin-bottom: 6px; font-size: 0.85rem; color: #cbd5e1;">Focus Category:</label>
            <select id="categorySelect" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid rgba(148, 163, 184, 0.3); background: #1e293b; color: #fff; font-size: 0.9rem; cursor: pointer;">
              <option value="">All Categories (Mixed)</option>
              <option value="Situational">Situational (Hypothetical scenarios - "How would you handle...")</option>
              <option value="Behavioral">Behavioral (Past experiences - "Tell us about a time...")</option>
              <option value="Chain of Command">Chain of Command</option>
              <option value="Ethics & Integrity">Ethics & Integrity</option>
              <option value="Safety & Accountability">Safety & Accountability</option>
              <option value="Teamwork & Collaboration">Teamwork & Collaboration</option>
              <option value="Conflict Resolution">Conflict Resolution</option>
              <option value="Decision Making">Decision Making</option>
              <option value="Communication">Communication</option>
              <option value="Stress Management">Stress Management</option>
              <option value="Leadership">Leadership</option>
              <option value="Medical / EMR">Medical / EMR</option>
              <option value="Technical ‚Äì Fireground">Technical ‚Äì Fireground</option>
              <option value="Resume-Based" id="resumeBasedOption">Resume-Based Questions</option>
              <option value="City & Department Specific">City & Department Specific</option>
            </select>
          </div>
          
          <!-- Flagged Questions Controls -->
          <div style="margin-top: 8px; display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
            <button id="viewFlaggedBtn" style="padding: 4px 10px; background: transparent; border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 6px; color: #cbd5e1; font-size: 0.8rem; cursor: pointer; transition: all 0.2s;" title="View flagged questions" onmouseover="this.style.background='rgba(239, 68, 68, 0.1)'; this.style.borderColor='rgba(239, 68, 68, 0.5)'" onmouseout="this.style.background='transparent'; this.style.borderColor='rgba(239, 68, 68, 0.3)'">
              üö© <span id="flaggedCount">0</span>
            </button>
            <!-- Practice Insights Button (appears after 5 questions) -->
            <button id="areasToWorkOnBtn" style="padding: 4px 10px; background: transparent; border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 6px; color: #cbd5e1; font-size: 0.8rem; cursor: pointer; transition: all 0.2s; display: none; font-weight: 500;" title="View personalized practice insights" onmouseover="this.style.background='rgba(251, 191, 36, 0.1)'; this.style.borderColor='rgba(251, 191, 36, 0.5)'" onmouseout="this.style.background='transparent'; this.style.borderColor='rgba(251, 191, 36, 0.3)'">
              üí° Practice Insights
            </button>
          </div>
        </div>
        
        <div style="position: relative;">
          <div class="question-text" id="questionText" style="padding-right: 100px;">
            Click <strong>Start Interview</strong> to begin. AI will generate personalized questions based on your resume and conversation history.
          </div>
          <button id="flagQuestionBtn" style="position: absolute; top: 0; right: 0; background: rgba(239, 68, 68, 0.15); border: 1px solid rgba(239, 68, 68, 0.4); border-radius: 6px; cursor: pointer; padding: 6px 10px; display: none; opacity: 0.8; transition: all 0.2s; z-index: 10; font-size: 0.85rem; color: #fca5a5; font-weight: 600;" title="Flag this question as difficult" onmouseover="this.style.background='rgba(239, 68, 68, 0.25)'; this.style.opacity='1';" onmouseout="this.style.background='rgba(239, 68, 68, 0.15)'; this.style.opacity='0.8';">
            <span id="flagIcon" style="font-size: 1rem; margin-right: 4px;">üö©</span>
            <span id="flagText">Flag</span>
          </button>
        </div>
        <div id="questionSubtitles" style="margin-top: 8px; padding: 8px; background: rgba(15, 23, 42, 0.6); border-radius: 8px; font-size: 0.9rem; color: #cbd5e1; min-height: 24px; display: none;"></div>
        <div class="question-meta">
          <span>Question #<span id="questionIndex">0</span></span>
          <span>‚Ä¢</span>
          <span>Mode: AI-Powered Dynamic Panel (behavioural + technical + contextual followups)</span>
        </div>
        <div id="followupButtonContainer" style="margin-top: 12px;"></div>
        <div class="question-controls" style="margin-top: 10px;">
          <button id="startAnswerBtn" class="secondary" type="button">
            üé§ Answer Question
          </button>
          <button id="stopAnswerBtn" class="secondary" type="button" disabled>
            ‚úÖ Finish Answering Question
          </button>
          <div class="status">
            <span class="status-dot off" id="micStatusDot"></span>
            <span id="micStatusText"><!-- Loaded from config.js --></span>
          </div>
        </div>
        <p style="margin-top: 6px; font-size: 0.8rem; color: #94a3b8;">
          After each question is read aloud, recording will start automatically. Just begin speaking, then click
          <strong>Finish Answering Question</strong> when you‚Äôre done.
        </p>
        <div style="position: relative;">
          <div class="transcript" id="transcriptBox" style="min-height: 80px; padding: 12px; position: relative; cursor: text;">
            Your live transcript will show here if your browser supports speech recognition.
          </div>
          <div id="transcriptEditHint" style="position: absolute; bottom: 8px; right: 12px; font-size: 0.7rem; color: #94a3b8; pointer-events: none; opacity: 0.7;">
            ‚úèÔ∏è Click to edit
          </div>
        </div>
        <div style="margin-top: 8px; padding: 8px; background: rgba(251, 191, 36, 0.1); border-left: 3px solid #fbbf24; border-radius: 4px; font-size: 0.8rem; color: #fbbf24;">
          üí° <strong>Tip:</strong> Speech recognition may mis-transcribe names. You can click the transcript above to edit any errors before analyzing!
        </div>
      </div>

    </section>

    <!-- RIGHT SIDE -->
    <section class="right">
      <!-- Video card -->
      <div class="card">
        <div class="card-header">
          <div class="card-title">
            Camera & Presence
            <small>(just like sitting in front of a hiring panel)</small>
          </div>
          <button id="cameraBtn" type="button" class="secondary">
            üì∑ Start Camera
          </button>
        </div>
        <div class="video-wrapper">
          <video id="camera" autoplay playsinline muted></video>
          <canvas id="motionCanvas"></canvas>
          <div class="video-overlay">
            <span class="label">Body Language</span>
            <span class="value">
              Motion score:
              <strong id="motionScore">‚Äì</strong>
            </span>
          </div>
        </div>
        <div class="metrics-row">
          <span class="metric-chip">Environment: Aim for chest-up framing, neutral background, good light.</span>
          <span class="metric-chip">Goal: calm but engaged, limited fidgeting.</span>
        </div>
      </div>

      <!-- Feedback card - moved under camera -->
      <div class="card">
        <div class="card-header">
          <div class="card-title">
            Feedback on This Answer
          </div>
        </div>
        
        <!-- Progress bar for AI analysis -->
        <div id="aiProgressContainer" style="display: none; margin-bottom: 12px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
            <span style="font-size: 0.85rem; color: #cbd5e1;">ü§ñ AI Analyzing...</span>
            <span id="aiProgressPercent" style="font-size: 0.85rem; color: #f97316; font-weight: 600;">0%</span>
          </div>
          <div style="width: 100%; height: 8px; background: rgba(15, 23, 42, 0.6); border-radius: 4px; overflow: hidden;">
            <div id="aiProgressBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #f97316, #ef4444); border-radius: 4px; transition: width 0.3s ease; box-shadow: 0 0 10px rgba(249, 115, 22, 0.5);"></div>
          </div>
        </div>
        
        <div class="feedback-grid">
          <div class="feedback-block">
            <h4>Content & Structure <span id="contentScore" class="score-pill low">‚Äì</span></h4>
            <p id="contentFeedback">
              After you finish answering, feedback will appear here automatically.
            </p>
          </div>
          <div class="feedback-block">
            <h4>Voice & Filler Words <span id="voiceScore" class="score-pill low">‚Äì</span></h4>
            <p id="voiceFeedback">
              "Um, uh, like‚Ä¶" will be detected and summarized here based on your transcript.
            </p>
          </div>
          <div class="feedback-block">
            <h4>Body Language (Camera) <span id="bodyScore" class="score-pill low">‚Äì</span></h4>
            <p id="bodyFeedback">
              Movement and stability from the webcam feed will be scored as "steady / moderate / fidgety".
            </p>
          </div>
          <div class="feedback-block">
            <h4>Fire-Specific Tips / AI Coach</h4>
            <p id="fireTips">
              We'll highlight if you're hitting key themes: safety, teamwork, accountability, medical care, community, and learning from mistakes.
            </p>
            <button id="viewAIFeedbackBtn" type="button" style="margin-top: 8px; padding: 8px 12px; border-radius: 6px; border: 1px solid rgba(239, 68, 68, 0.5); background: rgba(239, 68, 68, 0.1); color: #fca5a5; cursor: pointer; font-size: 0.85rem; display: none;">
              üìñ View Detailed AI Feedback
            </button>
          </div>
        </div>
      </div>

    </section>
  </main>
</div>

<!-- Onscreen Console (Debug) -->
<!-- Debug console removed to avoid overlap with feedback button -->

  <!-- Footer with Legal Links -->
  <footer style="text-align: center; padding: 30px 20px; margin-top: auto; border-top: 1px solid rgba(239, 68, 68, 0.2); color: #94a3b8; font-size: 0.9em; width: 100%; clear: both; display: block; flex-shrink: 0;">
    <div style="max-width: 1200px; margin: 0 auto;">
      <p style="margin-bottom: 10px; color: #94a3b8;" id="footerCopyright"><!-- Loaded from config.js --></p>
      <p style="margin: 0;">
        <a href="terms-of-service.html" style="color: #fca5a5; text-decoration: none; margin: 0 15px; transition: color 0.2s;" id="footerTermsLink"><!-- Loaded from config.js --></a>
        <span style="color: rgba(239, 68, 68, 0.5);">|</span>
        <a href="privacy-policy.html" style="color: #fca5a5; text-decoration: none; margin: 0 15px; transition: color 0.2s;" id="footerPrivacyLink"><!-- Loaded from config.js --></a>
      </p>
      <p style="margin-top: 10px; font-size: 0.85em; color: #64748b;" id="footerDisclaimer"><!-- Loaded from config.js --></p>
    </div>
  </footer>
</div>

<!-- AI Feedback Modal - Outside app container for proper fixed positioning -->
<div id="aiModalOverlay" class="ai-modal-overlay">
  <div class="ai-modal">
    <div class="ai-modal-header">
      <h3>ü§ñ AI Interview Coach Feedback</h3>
      <button class="ai-modal-close" id="closeAIModal" type="button">√ó</button>
    </div>
    <div class="ai-modal-content" id="aiModalContent">
      <!-- AI feedback will be inserted here -->
    </div>
  </div>
</div>

<!-- Paywall Modal -->
<div id="paywallModal" class="modal-overlay" style="display: none;">
  <div class="modal" style="max-width: 500px;">
    <div class="modal-header">
      <h3>You've used your 3 free questions</h3>
      <button class="modal-close" id="closePaywallModal" type="button">√ó</button>
    </div>
    <div class="modal-content">
      <p style="color: #cbd5e1; margin-bottom: 20px; line-height: 1.6;">
        To keep practicing and unlock full panel ready answers and detailed feedback, you'll need credits.
      </p>
      <div style="display: flex; gap: 12px; margin-top: 24px;">
        <button class="primary" id="buyCreditsFromPaywall" style="flex: 1; padding: 12px;">Buy Credits</button>
        <button class="secondary" id="cancelPaywall" style="flex: 1; padding: 12px;">Maybe Later</button>
      </div>
    </div>
  </div>
</div>

<!-- Credit Purchase Modal -->
<div id="creditPurchaseModal" class="modal-overlay" style="display: none;">
  <div class="modal" style="max-width: 700px;">
    <div class="modal-header">
      <h3>Choose Your Credit Pack</h3>
      <button class="modal-close" id="closeCreditPurchaseModal" type="button">√ó</button>
    </div>
    <div class="modal-content">
      <div id="creditBundlesContainer" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 16px; margin-top: 20px;">
        <!-- Credit bundles will be loaded here -->
      </div>
      
      <!-- Referral Section -->
      <div id="referralSection" style="margin-top: 30px; padding: 20px; background: rgba(251, 191, 36, 0.1); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 12px;">
        <h4 style="color: #fbbf24; margin: 0 0 12px 0; font-size: 1.1rem;">Refer a Friend</h4>
        <p style="color: #cbd5e1; font-size: 0.9rem; margin: 0 0 16px 0; line-height: 1.5;">
          Share your referral code with friends. When they sign up and complete their first question, you'll get <strong style="color: #fbbf24;">3 full access credits</strong>!
        </p>
        <div style="display: flex; gap: 8px; align-items: center;">
          <input type="text" id="referralCodeDisplay" readonly style="flex: 1; padding: 10px; border-radius: 6px; border: 1px solid rgba(148, 163, 184, 0.3); background: #1e293b; color: #fff; font-size: 0.9rem; font-weight: 600; letter-spacing: 1px; text-align: center;" />
          <button id="shareReferralCode" class="primary" style="padding: 10px 16px; font-size: 0.9rem; display: flex; align-items: center; gap: 6px;">
            <span>üì§</span>
            <span>Share</span>
          </button>
        </div>
        <p id="referralCodeStatus" style="color: #86efac; font-size: 0.85rem; margin: 8px 0 0 0; display: none;"></p>
      </div>
    </div>
  </div>
</div>

<!-- Signup Modal -->
<div id="signupModal" class="modal-overlay" style="display: none;">
  <div class="modal" style="max-width: 450px;">
    <div class="modal-header">
      <h3>Create Account</h3>
      <button class="modal-close" id="closeSignupModal" type="button">√ó</button>
    </div>
    <div class="modal-content">
      <form id="signupForm" style="display: flex; flex-direction: column; gap: 16px;">
        <div>
          <label style="display: block; color: #cbd5e1; font-size: 0.9rem; margin-bottom: 6px;">Name</label>
          <input type="text" id="signupName" placeholder="Your name" required style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid rgba(148, 163, 184, 0.3); background: #1e293b; color: #fff; font-size: 0.9rem;" />
        </div>
        <div>
          <label style="display: block; color: #cbd5e1; font-size: 0.9rem; margin-bottom: 6px;">Email</label>
          <input type="email" id="signupEmail" placeholder="your@email.com" required style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid rgba(148, 163, 184, 0.3); background: #1e293b; color: #fff; font-size: 0.9rem;" />
        </div>
        <div>
          <label style="display: block; color: #cbd5e1; font-size: 0.9rem; margin-bottom: 6px;">Password</label>
          <input type="password" id="signupPassword" placeholder="At least 8 characters" required minlength="8" style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid rgba(148, 163, 184, 0.3); background: #1e293b; color: #fff; font-size: 0.9rem;" />
        </div>
        <div id="signupError" style="color: #fca5a5; font-size: 0.85rem; display: none;"></div>
        <button type="submit" class="primary" style="padding: 12px; margin-top: 8px;">Sign Up</button>
        
        <!-- Referral Code Section -->
        <div style="margin-top: 16px; padding: 16px; background: rgba(251, 191, 36, 0.1); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 8px;">
          <p style="color: #cbd5e1; font-size: 0.85rem; margin: 0 0 12px 0; line-height: 1.4;">
            If you have a referral code, enter it here.
          </p>
          <div style="display: flex; gap: 8px; align-items: center;">
            <input type="text" id="signupReferralCode" placeholder="Enter referral code" style="flex: 1; padding: 10px; border-radius: 6px; border: 1px solid rgba(251, 191, 36, 0.5); background: #1e293b; color: #fff; font-size: 0.9rem; font-weight: 600; letter-spacing: 1px; text-transform: uppercase; text-align: center;" />
            <button type="button" id="applySignupReferralCode" class="secondary" style="padding: 10px 16px; font-size: 0.9rem; white-space: nowrap; border: 1px solid rgba(251, 191, 36, 0.5);">Apply</button>
          </div>
          <p id="signupReferralStatus" style="color: #86efac; font-size: 0.85rem; margin: 8px 0 0 0; display: none; font-weight: 600;"></p>
        </div>
        
        <div style="display: flex; align-items: center; gap: 12px; margin: 16px 0;">
          <div style="flex: 1; height: 1px; background: rgba(148, 163, 184, 0.3);"></div>
          <span style="color: #94a3b8; font-size: 0.85rem;">or</span>
          <div style="flex: 1; height: 1px; background: rgba(148, 163, 184, 0.3);"></div>
        </div>
        
        <button type="button" id="googleSignupBtn" style="width: 100%; padding: 12px; background: #fff; color: #333; border: 1px solid rgba(148, 163, 184, 0.3); border-radius: 6px; font-size: 0.9rem; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; transition: all 0.2s;" onmouseover="this.style.background='#f3f4f6'" onmouseout="this.style.background='#fff'">
          <svg width="18" height="18" viewBox="0 0 18 18"><path fill="#4285F4" d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.616z"/><path fill="#34A853" d="M9 18c2.43 0 4.467-.806 5.96-2.184l-2.908-2.258c-.806.54-1.837.86-3.052.86-2.347 0-4.33-1.585-5.04-3.715H.957v2.332C2.438 15.983 5.482 18 9 18z"/><path fill="#FBBC05" d="M3.96 10.703c-.18-.54-.282-1.117-.282-1.703s.102-1.163.282-1.703V4.965H.957C.348 6.175 0 7.55 0 9s.348 2.825.957 4.035l3.003-2.332z"/><path fill="#EA4335" d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0 5.482 0 2.438 2.017.957 4.965L3.96 7.297C4.67 5.167 6.653 3.58 9 3.58z"/></svg>
          Continue with Google
        </button>
        
        <div style="text-align: center; margin-top: 8px;">
          <span style="color: #94a3b8; font-size: 0.85rem;">Already have an account? </span>
          <button type="button" id="switchToLogin" class="ghost" style="padding: 0; text-decoration: underline;">Log in</button>
        </div>
      </form>
    </div>
  </div>
</div>

<!-- Login Modal -->
<div id="loginModal" class="modal-overlay" style="display: none;">
  <div class="modal" style="max-width: 450px;">
    <div class="modal-header">
      <h3>Log In</h3>
      <button class="modal-close" id="closeLoginModal" type="button">√ó</button>
    </div>
    <div class="modal-content">
      <form id="loginForm" style="display: flex; flex-direction: column; gap: 16px;">
        <div>
          <label style="display: block; color: #cbd5e1; font-size: 0.9rem; margin-bottom: 6px;">Email</label>
          <input type="email" id="loginEmail" placeholder="your@email.com" required style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid rgba(148, 163, 184, 0.3); background: #1e293b; color: #fff; font-size: 0.9rem;" />
        </div>
        <div>
          <label style="display: block; color: #cbd5e1; font-size: 0.9rem; margin-bottom: 6px;">Password</label>
          <input type="password" id="loginPassword" placeholder="Your password" required style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid rgba(148, 163, 184, 0.3); background: #1e293b; color: #fff; font-size: 0.9rem;" />
        </div>
        <div id="loginError" style="color: #fca5a5; font-size: 0.85rem; display: none;"></div>
        <button type="submit" class="primary" style="padding: 12px; margin-top: 8px;">Log In</button>
        
        <!-- Referral Code Section for Login -->
        <div style="margin-top: 16px; padding: 16px; background: rgba(251, 191, 36, 0.1); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 8px;">
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
            <span style="color: #fbbf24; font-size: 1.2rem;">üéÅ</span>
            <h4 style="color: #fbbf24; margin: 0; font-size: 1rem; font-weight: 600;">Redeem Referral Code</h4>
          </div>
          <p style="color: #cbd5e1; font-size: 0.85rem; margin: 0 0 12px 0; line-height: 1.4;">
            Have a referral code? Enter it here.
          </p>
          <p style="color: #94a3b8; font-size: 0.75rem; margin: 0 0 12px 0; font-style: italic;">
            üí° Test codes: TEST, UNLIMITED, or DEV (for testing)
          </p>
          <div style="display: flex; gap: 8px; align-items: center;">
            <input type="text" id="loginReferralCode" placeholder="Enter referral code" style="flex: 1; padding: 10px; border-radius: 6px; border: 1px solid rgba(251, 191, 36, 0.5); background: #1e293b; color: #fff; font-size: 0.9rem; font-weight: 600; letter-spacing: 1px; text-transform: uppercase; text-align: center;" />
            <button type="button" id="applyLoginReferralCode" class="secondary" style="padding: 10px 16px; font-size: 0.9rem; white-space: nowrap; border: 1px solid rgba(251, 191, 36, 0.5);">Apply</button>
          </div>
          <p id="loginReferralStatus" style="color: #86efac; font-size: 0.85rem; margin: 8px 0 0 0; display: none; font-weight: 600;"></p>
        </div>
        
        <div style="display: flex; align-items: center; gap: 12px; margin: 16px 0;">
          <div style="flex: 1; height: 1px; background: rgba(148, 163, 184, 0.3);"></div>
          <span style="color: #94a3b8; font-size: 0.85rem;">or</span>
          <div style="flex: 1; height: 1px; background: rgba(148, 163, 184, 0.3);"></div>
        </div>
        
        <button type="button" id="googleLoginBtn" style="width: 100%; padding: 12px; background: #fff; color: #333; border: 1px solid rgba(148, 163, 184, 0.3); border-radius: 6px; font-size: 0.9rem; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; transition: all 0.2s;" onmouseover="this.style.background='#f3f4f6'" onmouseout="this.style.background='#fff'">
          <svg width="18" height="18" viewBox="0 0 18 18"><path fill="#4285F4" d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.616z"/><path fill="#34A853" d="M9 18c2.43 0 4.467-.806 5.96-2.184l-2.908-2.258c-.806.54-1.837.86-3.052.86-2.347 0-4.33-1.585-5.04-3.715H.957v2.332C2.438 15.983 5.482 18 9 18z"/><path fill="#FBBC05" d="M3.96 10.703c-.18-.54-.282-1.117-.282-1.703s.102-1.163.282-1.703V4.965H.957C.348 6.175 0 7.55 0 9s.348 2.825.957 4.035l3.003-2.332z"/><path fill="#EA4335" d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0 5.482 0 2.438 2.017.957 4.965L3.96 7.297C4.67 5.167 6.653 3.58 9 3.58z"/></svg>
          Continue with Google
        </button>
        
        <div style="text-align: center; margin-top: 8px;">
          <span style="color: #94a3b8; font-size: 0.85rem;">Don't have an account? </span>
          <button type="button" id="switchToSignup" class="ghost" style="padding: 0; text-decoration: underline;">Sign up</button>
        </div>
      </form>
    </div>
  </div>
</div>

<!-- Settings Modal -->
<div id="settingsModal" class="modal-overlay" style="display: none;">
  <div class="modal" style="max-width: 600px; max-height: 90vh; overflow-y: auto;">
    <div class="modal-header">
      <h3>Settings</h3>
      <button class="modal-close" id="closeSettingsModal" type="button">√ó</button>
    </div>
    <div class="modal-content">
      <!-- Profile Section -->
      <div style="margin-bottom: 32px;">
        <h4 style="color: #fbbf24; margin-bottom: 16px; font-size: 1.1rem;">Profile</h4>
        <form id="profileForm" style="display: flex; flex-direction: column; gap: 16px;">
          <div>
            <label style="display: block; color: #cbd5e1; font-size: 0.9rem; margin-bottom: 6px;">Name</label>
            <input type="text" id="settingsName" placeholder="Your name" required style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid rgba(148, 163, 184, 0.3); background: #1e293b; color: #fff; font-size: 0.9rem;" />
          </div>
          <div>
            <label style="display: block; color: #cbd5e1; font-size: 0.9rem; margin-bottom: 6px;">Email</label>
            <input type="email" id="settingsEmail" disabled style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid rgba(148, 163, 184, 0.3); background: #0f172a; color: #64748b; font-size: 0.9rem; cursor: not-allowed;" />
            <small style="color: #94a3b8; font-size: 0.8rem;">Email cannot be changed</small>
          </div>
          <div id="passwordSection" style="display: none;">
            <h5 style="color: #cbd5e1; margin: 16px 0 8px 0; font-size: 0.95rem;">Change Password</h5>
            <div>
              <label style="display: block; color: #cbd5e1; font-size: 0.9rem; margin-bottom: 6px;">Current Password</label>
              <input type="password" id="settingsCurrentPassword" placeholder="Current password" style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid rgba(148, 163, 184, 0.3); background: #1e293b; color: #fff; font-size: 0.9rem;" />
            </div>
            <div>
              <label style="display: block; color: #cbd5e1; font-size: 0.9rem; margin-bottom: 6px;">New Password</label>
              <input type="password" id="settingsNewPassword" placeholder="New password (min 8 characters)" minlength="8" style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid rgba(148, 163, 184, 0.3); background: #1e293b; color: #fff; font-size: 0.9rem;" />
            </div>
            <div>
              <label style="display: block; color: #cbd5e1; font-size: 0.9rem; margin-bottom: 6px;">Confirm New Password</label>
              <input type="password" id="settingsConfirmPassword" placeholder="Confirm new password" minlength="8" style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid rgba(148, 163, 184, 0.3); background: #1e293b; color: #fff; font-size: 0.9rem;" />
            </div>
          </div>
          <div id="profileError" style="color: #fca5a5; font-size: 0.85rem; display: none;"></div>
          <div id="profileSuccess" style="color: #86efac; font-size: 0.85rem; display: none;"></div>
          <button type="submit" class="primary" style="padding: 12px; margin-top: 8px;">Save Changes</button>
        </form>
      </div>
      
      <!-- Purchase History Section -->
      <div style="margin-bottom: 32px;">
        <h4 style="color: #fbbf24; margin-bottom: 16px; font-size: 1.1rem;">Purchase History</h4>
        <div id="purchaseHistory" style="min-height: 100px;">
          <div style="color: #94a3b8; text-align: center; padding: 20px;">Loading...</div>
        </div>
      </div>
      
      <!-- Credit History Section -->
      <div style="margin-bottom: 32px;">
        <h4 style="color: #fbbf24; margin-bottom: 16px; font-size: 1.1rem;">Credit History</h4>
        <div id="creditHistory" style="min-height: 100px;">
          <div style="color: #94a3b8; text-align: center; padding: 20px;">Loading...</div>
        </div>
      </div>
      
      <!-- Delete Account Section -->
      <div style="border-top: 1px solid rgba(239, 68, 68, 0.3); padding-top: 32px; margin-top: 32px;">
        <h4 style="color: #ef4444; margin-bottom: 16px; font-size: 1.1rem;">‚ö†Ô∏è Danger Zone</h4>
        <p style="color: #94a3b8; font-size: 0.9rem; margin-bottom: 16px; line-height: 1.6;">
          Deleting your account will permanently remove all your data, including your profile, resume, conversation history, credits, and purchase history. This action cannot be undone.
        </p>
        <button id="deleteAccountBtn" type="button" style="padding: 12px 24px; background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%); color: #fff; border: none; border-radius: 8px; font-size: 0.95rem; font-weight: 600; cursor: pointer; transition: all 0.2s; box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(220, 38, 38, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(220, 38, 38, 0.3)'">
          üóëÔ∏è Delete My Account
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Delete Account Confirmation Modal -->
<div id="deleteAccountModal" class="modal-overlay" style="display: none;">
  <div class="modal" style="max-width: 500px;">
    <div class="modal-header">
      <h3 style="color: #ef4444;">‚ö†Ô∏è Delete Account</h3>
      <button class="modal-close" id="closeDeleteAccountModal" type="button">√ó</button>
    </div>
    <div class="modal-content">
      <div style="background: rgba(239, 68, 68, 0.1); border-left: 4px solid #ef4444; padding: 16px; margin-bottom: 20px; border-radius: 4px;">
        <p style="color: #fca5a5; margin: 0; font-size: 0.95rem; line-height: 1.6;">
          <strong>This action cannot be undone.</strong> All of your data will be permanently deleted:
        </p>
        <ul style="color: #fca5a5; margin: 12px 0 0 20px; font-size: 0.9rem; line-height: 1.8;">
          <li>Your profile and account information</li>
          <li>Your resume and resume analysis</li>
          <li>All conversation history and practice sessions</li>
          <li>Your credits balance and purchase history</li>
          <li>All flagged questions and practice insights</li>
        </ul>
      </div>
      <p style="color: #cbd5e1; font-size: 0.95rem; margin-bottom: 20px; line-height: 1.6;">
        Are you absolutely sure you want to delete your account? Type <strong style="color: #ef4444;">DELETE</strong> to confirm.
      </p>
      <div style="margin-bottom: 20px;">
        <input type="text" id="deleteConfirmInput" placeholder="Type DELETE to confirm" style="width: 100%; padding: 12px; border-radius: 6px; border: 2px solid rgba(239, 68, 68, 0.3); background: #1e293b; color: #fff; font-size: 0.95rem; text-transform: uppercase;" />
        <div id="deleteAccountError" style="color: #fca5a5; font-size: 0.85rem; margin-top: 8px; display: none;"></div>
      </div>
      <div style="display: flex; gap: 12px; justify-content: flex-end;">
        <button id="cancelDeleteBtn" type="button" class="secondary" style="padding: 12px 24px;">Cancel</button>
        <button id="confirmDeleteBtn" type="button" style="padding: 12px 24px; background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%); color: #fff; border: none; border-radius: 8px; font-size: 0.95rem; font-weight: 600; cursor: pointer; transition: all 0.2s;" disabled>Delete Account</button>
      </div>
    </div>
  </div>
</div>

<script>
  // ========== CRITICAL: Declare all variables FIRST before any code uses them ==========
  // These must be declared at the very top to avoid "Cannot access before initialization" errors
  
  // Backend URL - declared first
  const BACKEND_URL = (() => {
    const hostname = window.location.hostname;
    if (hostname === 'localhost' || hostname === '127.0.0.1') {
      return 'http://localhost:3001';
    }
    return 'https://fire-interview-coach-api.onrender.com';
  })();
  
  // Basic state variables
  let onboardingData = {
    country: "",
    stateProvince: "",
    city: "",
    jobType: "",
    departmentName: "",
    name: null,
    voicePreference: null,
    cityResearch: null
  };
  
  let resumeText = "";
  let resumeKeywords = [];
  let resumeAnalysis = null;
  let currentUser = null;
  let authToken = null;
  let onboardingComplete = false; // Will be updated from localStorage
  
  // Question state
  let questionCount = 0;
  let currentQuestion = null;
  let conversationHistory = [];
  let isFollowupQuestion = false;
  let askedQuestions = new Set();
  let askedCategories = new Set();
  let resumeTopicsCovered = new Set();
  let flaggedQuestions = [];
  let onlyFlaggedMode = false;
  
  // Practice mode
  let practiceMode = "simulation";
  let selectedCategory = "";
  
  // Trial credits constants (must be declared early)
  const TRIAL_CREDITS_MAX = 3;
  const TRIAL_CREDITS_KEY = 'trial_credits_remaining';
  
  // ========== LOAD CONFIGURATION TEXT ==========
  // Update all text elements from config.js
  document.addEventListener('DOMContentLoaded', function() {
    if (typeof APP_CONFIG !== 'undefined') {
      // Update buttons
      const nextQuestionBtn = document.getElementById('nextQuestionBtn');
      if (nextQuestionBtn) {
        // Only update if not the first question (Start Interview)
        // Use typeof check to avoid ReferenceError if questionCount not yet initialized
        const currentQuestionCount = (typeof questionCount !== 'undefined') ? questionCount : 0;
        if (currentQuestionCount > 0) {
          nextQuestionBtn.textContent = APP_CONFIG.buttons.nextQuestion;
        } else {
          // Ensure it says "Start Interview" for first question
          nextQuestionBtn.textContent = "üé§ Start Interview";
        }
      }
      
      const startAnswerBtn = document.getElementById('startAnswerBtn');
      if (startAnswerBtn) startAnswerBtn.textContent = APP_CONFIG.buttons.answerQuestion;
      
      const stopAnswerBtn = document.getElementById('stopAnswerBtn');
      if (stopAnswerBtn) stopAnswerBtn.textContent = APP_CONFIG.buttons.finishAnswering;
      
      const repeatQuestionBtn = document.getElementById('repeatQuestionBtn');
      if (repeatQuestionBtn) repeatQuestionBtn.textContent = APP_CONFIG.buttons.repeatQuestion;
      
      // Update footer
      const footerCopyright = document.getElementById('footerCopyright');
      if (footerCopyright) {
        footerCopyright.textContent = APP_CONFIG.footer.copyright
          .replace('{year}', APP_CONFIG.copyrightYear)
          .replace('{company}', APP_CONFIG.companyName);
      }
      
      const footerTermsLink = document.getElementById('footerTermsLink');
      if (footerTermsLink) footerTermsLink.textContent = APP_CONFIG.footer.termsLink;
      
      const footerPrivacyLink = document.getElementById('footerPrivacyLink');
      if (footerPrivacyLink) footerPrivacyLink.textContent = APP_CONFIG.footer.privacyLink;
      
      const footerDisclaimer = document.getElementById('footerDisclaimer');
      if (footerDisclaimer) {
        footerDisclaimer.textContent = APP_CONFIG.footer.disclaimer
          .replace('{appName}', APP_CONFIG.appName);
      }
      
      // Update modal titles
      const aiModalTitle = document.querySelector('.ai-modal-header h3');
      if (aiModalTitle) aiModalTitle.textContent = APP_CONFIG.modals.aiFeedback;
      
      // Update status text
      const micStatusText = document.getElementById('micStatusText');
      if (micStatusText) micStatusText.textContent = APP_CONFIG.status.micIdle;
      
      // Update question instruction text
      const questionTextEl = document.getElementById('questionText');
      if (questionTextEl && questionTextEl.textContent.includes('Click')) {
        questionTextEl.innerHTML = APP_CONFIG.instructions.getStarted;
      }
    }
  });

  // ========== TERMS & PRIVACY ACCEPTANCE ==========
  const termsModal = document.getElementById("termsModal");
  const acceptTermsCheckbox = document.getElementById("acceptTerms");
  const acceptPrivacyCheckbox = document.getElementById("acceptPrivacy");
  const acceptTermsBtn = document.getElementById("acceptTermsBtn");
  const onboardingModal = document.getElementById("onboardingModal");
  const mainApp = document.getElementById("mainApp");
  
  // Hide main app by default
  if (mainApp) {
    mainApp.style.display = "none";
  }
  
  // Update onboardingComplete from localStorage (variable already declared at top)
  onboardingComplete = localStorage.getItem("onboardingComplete") === "true";
  
  // Check if user just logged in - if so, don't interfere with login handler
  if (window.justLoggedIn) {
    console.log('User just logged in - skipping page load modal logic');
    // Still ensure main app is visible
    const mainAppCheck = document.getElementById('mainApp');
    if (mainAppCheck && mainAppCheck.style.display !== 'block') {
      mainAppCheck.style.display = 'block';
    }
    // Update onboardingComplete flag
    onboardingComplete = localStorage.getItem("onboardingComplete") === "true";
  } else {
    // Normal page load logic
    // Check if user has already accepted terms
    const termsAccepted = localStorage.getItem("termsAccepted") === "true";
    const privacyAccepted = localStorage.getItem("privacyAccepted") === "true";
    onboardingComplete = localStorage.getItem("onboardingComplete") === "true";
    
    // Check if user is authenticated (has token or currentUser in localStorage)
    // Check cookie directly (getAuthToken might not be defined yet)
    const cookieToken = document.cookie.split('; ').find(row => row.startsWith('authToken='))?.split('=')[1];
    const hasAuthToken = cookieToken || localStorage.getItem('authToken');
    const hasStoredUser = localStorage.getItem('currentUser');
    const isAuthenticated = hasAuthToken || hasStoredUser;
    
    // Show modal if terms not accepted
    if (!termsAccepted || !privacyAccepted) {
      if (termsModal) {
        termsModal.style.display = "flex";
        // Disable all interactions until accepted
        document.body.style.overflow = "hidden";
        console.log("Terms modal displayed - terms not yet accepted");
      } else {
        console.error("Terms modal element not found!");
        // Fallback: show main app if modal doesn't exist
        if (mainApp) mainApp.style.display = "block";
      }
    } else if (isAuthenticated) {
    // User is authenticated - always show main app (they can access onboarding from settings if needed)
    // Set onboardingComplete to true if authenticated (they've logged in, so onboarding is complete)
    if (!onboardingComplete) {
      localStorage.setItem('onboardingComplete', 'true');
      console.log("User authenticated - setting onboardingComplete to true");
    }
    if (mainApp) {
      mainApp.style.display = "block";
      console.log("User authenticated - showing main app");
    } else {
      console.error("Main app element not found!");
    }
  } else if (!onboardingComplete) {
    // Terms accepted but onboarding not complete and user not authenticated - show onboarding modal
    if (onboardingModal) {
      onboardingModal.style.display = "flex";
      document.body.style.overflow = "hidden";
      console.log("Onboarding modal displayed - onboarding not yet complete");
    } else {
      console.error("Onboarding modal element not found!");
      // Fallback: show main app if modal doesn't exist
      if (mainApp) mainApp.style.display = "block";
    }
  } else {
    // Both terms and onboarding complete - show main app
    if (mainApp) {
      mainApp.style.display = "block";
      console.log("Terms and onboarding already complete - showing main app");
    } else {
      console.error("Main app element not found!");
    }
  }
  } // End of else block for normal page load
  
  // Update accept button state
  function updateAcceptButton() {
    if (acceptTermsBtn && acceptTermsCheckbox && acceptPrivacyCheckbox) {
      acceptTermsBtn.disabled = !(acceptTermsCheckbox.checked && acceptPrivacyCheckbox.checked);
      if (acceptTermsBtn.disabled) {
        acceptTermsBtn.style.opacity = "0.5";
        acceptTermsBtn.style.cursor = "not-allowed";
      } else {
        acceptTermsBtn.style.opacity = "1";
        acceptTermsBtn.style.cursor = "pointer";
      }
    }
  }
  
  // Listen for checkbox changes
  if (acceptTermsCheckbox) {
    acceptTermsCheckbox.addEventListener("change", updateAcceptButton);
  }
  if (acceptPrivacyCheckbox) {
    acceptPrivacyCheckbox.addEventListener("change", updateAcceptButton);
  }
  
  // Handle accept button click
  if (acceptTermsBtn) {
    acceptTermsBtn.addEventListener("click", () => {
      if (acceptTermsCheckbox.checked && acceptPrivacyCheckbox.checked) {
        // Save acceptance to localStorage
        localStorage.setItem("termsAccepted", "true");
        localStorage.setItem("privacyAccepted", "true");
        localStorage.setItem("termsAcceptedDate", new Date().toISOString());
        
        // Hide terms modal
        if (termsModal) {
          termsModal.style.display = "none";
        }
        
        // Check if onboarding is complete
        const onboardingCompleteCheck = localStorage.getItem("onboardingComplete") === "true";
        if (!onboardingCompleteCheck) {
          // Show onboarding modal
          if (onboardingModal) {
            onboardingModal.style.display = "flex";
            document.body.style.overflow = "hidden";
          }
        } else {
          // Show main app
          if (mainApp) {
            mainApp.style.display = "block";
          }
          document.body.style.overflow = "auto";
        }
        
        console.log("Terms and Privacy Policy accepted");
      }
    });
  }
  
  // Prevent closing modal by clicking outside (user must accept)
  if (termsModal) {
    termsModal.addEventListener("click", (e) => {
      if (e.target === termsModal) {
        // Optionally show a message that they must accept
        alert("You must accept the Terms of Service and Privacy Policy to use Fire Interview Coach.");
      }
    });
  }

  // Load onboarding config on page load
  // Function to load onboarding data into the form
  function loadOnboardingDataIntoForm(data) {
    if (!data) return;
    
    try {
      // Load city
      if (data.city && document.getElementById('onboardingCity')) {
        document.getElementById('onboardingCity').value = data.city;
      }
      
      // Load state/province and country (store in hidden field for Mapbox)
      if (data.stateProvince && document.getElementById('selectedCityData')) {
        const cityData = {
          city: data.city,
          stateProvince: data.stateProvince,
          country: data.country
        };
        document.getElementById('selectedCityData').value = JSON.stringify(cityData);
      }
      
      // Load job type
      if (data.jobType && document.getElementById('onboardingJobType')) {
        document.getElementById('onboardingJobType').value = data.jobType;
      }
      
      // Load department name
      if (data.departmentName && document.getElementById('onboardingDepartmentName')) {
        document.getElementById('onboardingDepartmentName').value = data.departmentName;
      }
      
      // Load name
      if (data.name && document.getElementById('onboardingName')) {
        document.getElementById('onboardingName').value = data.name;
      }
      
      // Load voice preference
      if (data.voicePreference && document.getElementById('onboardingVoice')) {
        document.getElementById('onboardingVoice').value = data.voicePreference;
        selectedVoicePreference = data.voicePreference;
      }
      
      // Load resume text if available
      if (data.resumeText) {
        resumeText = data.resumeText;
        resumeAnalysis = data.resumeAnalysis || null;
        if (document.getElementById('onboardingResumeStatus')) {
          document.getElementById('onboardingResumeStatus').textContent = `‚úì Resume loaded from your account (${data.resumeText.length} characters)`;
          document.getElementById('onboardingResumeStatus').style.color = "#10b981";
        }
        updateResumeBasedOption();
      }
      
      // Load city research if available
      if (data.cityResearch) {
        onboardingData = onboardingData || {};
        onboardingData.cityResearch = data.cityResearch;
      }
      
      console.log('Onboarding data loaded into form');
    } catch (error) {
      console.error('Error loading onboarding data into form:', error);
    }
  }
  
  // Handler for onboarding login button
  const onboardingLoginBtn = document.getElementById('onboardingLoginBtn');
  if (onboardingLoginBtn) {
    onboardingLoginBtn.addEventListener('click', () => {
      // Mark that we're opening login from onboarding (so we can restore onboarding if user closes login)
      window.loginOpenedFromOnboarding = true;
      // Close onboarding modal
      if (onboardingModal) {
        onboardingModal.style.display = 'none';
      }
      // Open login modal
      const loginModal = document.getElementById('loginModal');
      if (loginModal) {
        loginModal.style.display = 'flex';
      }
    });
  }
  
  function loadOnboardingConfig() {
    if (typeof ONBOARDING_CONFIG === 'undefined') {
      console.warn('Onboarding config not loaded');
      return;
    }
    
    // Update title and subtitle
    const titleEl = document.getElementById('onboardingTitle');
    const subtitleEl = document.getElementById('onboardingSubtitle');
    if (titleEl) titleEl.textContent = ONBOARDING_CONFIG.title;
    if (subtitleEl) subtitleEl.textContent = ONBOARDING_CONFIG.subtitle;
    
    // Update resume section
    const resumeLabelEl = document.getElementById('onboardingResumeLabel');
    const resumeButtonEl = document.getElementById('onboardingResumeButtonText');
    if (resumeLabelEl) {
      resumeLabelEl.innerHTML = ONBOARDING_CONFIG.resume.label + ' <span style="color: #94a3b8; font-weight: 400;">' + ONBOARDING_CONFIG.resume.optional + '</span>';
    }
    if (resumeButtonEl) resumeButtonEl.textContent = ONBOARDING_CONFIG.resume.uploadButtonText;
    
    // Update location section
    const locationLabelEl = document.getElementById('onboardingLocationLabel');
    const countryLabelEl = document.getElementById('onboardingCountryLabel');
    const stateLabelEl = document.getElementById('onboardingStateLabel');
    const cityLabelEl = document.getElementById('onboardingCityLabel');
    const stateInputEl = document.getElementById('onboardingStateProvince');
    const cityInputEl = document.getElementById('onboardingCity');
    
    if (locationLabelEl) {
      locationLabelEl.innerHTML = ONBOARDING_CONFIG.location.mainLabel + ' <span style="color: #ef4444;">' + ONBOARDING_CONFIG.location.required + '</span>';
    }
    if (countryLabelEl) countryLabelEl.textContent = ONBOARDING_CONFIG.location.country.label;
    if (stateLabelEl) stateLabelEl.textContent = ONBOARDING_CONFIG.location.stateProvince.label;
    if (cityLabelEl) cityLabelEl.textContent = ONBOARDING_CONFIG.location.city.label;
    if (stateInputEl) stateInputEl.placeholder = ONBOARDING_CONFIG.location.stateProvince.placeholder;
    if (cityInputEl) cityInputEl.placeholder = ONBOARDING_CONFIG.location.city.placeholder;
    
    // Update country dropdown
    const countrySelectEl = document.getElementById('onboardingCountry');
    if (countrySelectEl) {
      const placeholderEl = document.getElementById('onboardingCountryPlaceholder');
      if (placeholderEl) placeholderEl.textContent = ONBOARDING_CONFIG.location.country.placeholder;
      // Update option texts
      const usEl = document.getElementById('onboardingCountryUS');
      const canadaEl = document.getElementById('onboardingCountryCanada');
      const ukEl = document.getElementById('onboardingCountryUK');
      const ausEl = document.getElementById('onboardingCountryAustralia');
      const nzEl = document.getElementById('onboardingCountryNZ');
      const otherEl = document.getElementById('onboardingCountryOther');
      if (usEl) usEl.textContent = ONBOARDING_CONFIG.location.country.options.unitedStates;
      if (canadaEl) canadaEl.textContent = ONBOARDING_CONFIG.location.country.options.canada;
      if (ukEl) ukEl.textContent = ONBOARDING_CONFIG.location.country.options.unitedKingdom;
      if (ausEl) ausEl.textContent = ONBOARDING_CONFIG.location.country.options.australia;
      if (nzEl) nzEl.textContent = ONBOARDING_CONFIG.location.country.options.newZealand;
      if (otherEl) otherEl.textContent = ONBOARDING_CONFIG.location.country.options.other;
    }
    
    // Update job type section
    const jobTypeLabelEl = document.getElementById('onboardingJobTypeLabel');
    const jobTypeSelectEl = document.getElementById('onboardingJobType');
    if (jobTypeLabelEl) {
      jobTypeLabelEl.innerHTML = ONBOARDING_CONFIG.jobType.label + ' <span style="color: #ef4444;">' + ONBOARDING_CONFIG.jobType.required + '</span>';
    }
    if (jobTypeSelectEl) {
      const placeholderEl = document.getElementById('onboardingJobTypePlaceholder');
      if (placeholderEl) placeholderEl.textContent = ONBOARDING_CONFIG.jobType.placeholder;
      // Update option texts (only Fire is enabled, others are disabled with "Coming Soon")
      const fireEl = document.getElementById('onboardingJobTypeFire');
      const policeEl = document.getElementById('onboardingJobTypePolice');
      const paramedicEl = document.getElementById('onboardingJobTypeParamedic');
      const firstResponderEl = document.getElementById('onboardingJobTypeFirstResponder');
      const dispatcherEl = document.getElementById('onboardingJobTypeDispatcher');
      if (fireEl) fireEl.textContent = ONBOARDING_CONFIG.jobType.options.fire;
      if (policeEl) {
        policeEl.textContent = ONBOARDING_CONFIG.jobType.options.police + ' (Coming Soon)';
        policeEl.disabled = true;
      }
      if (paramedicEl) {
        paramedicEl.textContent = ONBOARDING_CONFIG.jobType.options.paramedic + ' (Coming Soon)';
        paramedicEl.disabled = true;
      }
      if (firstResponderEl) {
        firstResponderEl.textContent = ONBOARDING_CONFIG.jobType.options.firstResponder + ' (Coming Soon)';
        firstResponderEl.disabled = true;
      }
      if (dispatcherEl) {
        dispatcherEl.textContent = ONBOARDING_CONFIG.jobType.options.dispatcher + ' (Coming Soon)';
        dispatcherEl.disabled = true;
      }
    }
    
    // Update department section
    const deptLabelEl = document.getElementById('onboardingDepartmentLabel');
    const deptInputEl = document.getElementById('onboardingDepartmentName');
    const deptHelperEl = document.getElementById('onboardingDepartmentHelper');
    if (deptLabelEl) {
      deptLabelEl.innerHTML = ONBOARDING_CONFIG.department.label + ' <span style="color: #ef4444;">' + ONBOARDING_CONFIG.department.required + '</span>';
    }
    if (deptInputEl) deptInputEl.placeholder = ONBOARDING_CONFIG.department.placeholder;
    if (deptHelperEl) deptHelperEl.textContent = ONBOARDING_CONFIG.department.helperText;
    
    // Update name section
    const nameLabelEl = document.getElementById('onboardingNameLabel');
    const nameInputEl = document.getElementById('onboardingName');
    if (nameLabelEl) {
      nameLabelEl.innerHTML = ONBOARDING_CONFIG.name.label + ' <span style="color: #94a3b8; font-weight: 400;">' + ONBOARDING_CONFIG.name.optional + '</span>';
    }
    if (nameInputEl) {
      nameInputEl.placeholder = ONBOARDING_CONFIG.name.placeholder;
      const nameHelper = nameInputEl.nextElementSibling;
      if (nameHelper && nameHelper.tagName === 'P') {
        nameHelper.textContent = ONBOARDING_CONFIG.name.helperText;
      }
    }
    
    // Update voice section
    const voiceLabelEl = document.getElementById('onboardingVoiceLabel');
    const voiceSelectEl = document.getElementById('onboardingVoice');
    if (voiceLabelEl) {
      voiceLabelEl.innerHTML = ONBOARDING_CONFIG.voice.label + ' <span style="color: #94a3b8; font-weight: 400;">' + ONBOARDING_CONFIG.voice.optional + '</span>';
    }
    if (voiceSelectEl) {
      const defaultOpt = voiceSelectEl.querySelector('option[value=""]');
      const maleOpt = voiceSelectEl.querySelector('option[value="male"]');
      const femaleOpt = voiceSelectEl.querySelector('option[value="female"]');
      if (defaultOpt) defaultOpt.textContent = ONBOARDING_CONFIG.voice.options.default;
      if (maleOpt) maleOpt.textContent = ONBOARDING_CONFIG.voice.options.male;
      if (femaleOpt) femaleOpt.textContent = ONBOARDING_CONFIG.voice.options.female;
      const voiceHelper = voiceSelectEl.nextElementSibling;
      if (voiceHelper && voiceHelper.tagName === 'P') {
        voiceHelper.textContent = ONBOARDING_CONFIG.voice.helperText;
      }
    }
    
    // Update submit button
    const submitBtnEl = document.getElementById('onboardingSubmitBtn');
    if (submitBtnEl) submitBtnEl.textContent = ONBOARDING_CONFIG.submit.buttonText;
    
    // Update footer
    const requiredFieldsEl = document.getElementById('onboardingRequiredFields');
    if (requiredFieldsEl) {
      requiredFieldsEl.innerHTML = '<span style="color: #ef4444;">' + ONBOARDING_CONFIG.footer.requiredFields.split(' ')[0] + '</span> ' + ONBOARDING_CONFIG.footer.requiredFields.split(' ').slice(1).join(' ');
    }
  }
  
  // Load onboarding config on page load
  loadOnboardingConfig();
  
  // ========== ONBOARDING MODAL ==========
  const onboardingForm = document.getElementById("onboardingForm");
  const onboardingResumeInput = document.getElementById("onboardingResumeInput");
  const onboardingResumeStatus = document.getElementById("onboardingResumeStatus");
  
  // Check if onboarding is already complete (onboardingModal and mainApp already defined above)
  if (onboardingComplete) {
    // Load saved onboarding data
    const savedData = localStorage.getItem("onboardingData");
    if (savedData) {
      try {
        onboardingData = JSON.parse(savedData);
        console.log("Loaded onboarding data:", onboardingData);
      } catch (e) {
        console.error("Failed to parse saved onboarding data:", e);
      }
    }
    // Show main app if terms are accepted
    const termsAccepted = localStorage.getItem("termsAccepted") === "true";
    const privacyAccepted = localStorage.getItem("privacyAccepted") === "true";
    if (termsAccepted && privacyAccepted && mainApp) {
      mainApp.style.display = "block";
      // If resume was loaded during onboarding, display it
      if (resumeText && resumeText.length > 10 && resumeSummaryEl) {
        if (resumeAnalysis) {
          formatResumeSummary(resumeSummaryEl, resumeAnalysis, resumeText);
        } else {
          // Re-analyze if we have text but no analysis
          parseResumeWithAI(resumeText).catch(err => {
            console.error("Failed to re-analyze resume:", err);
            resumeSummaryEl.innerHTML = `<div style="color: #94a3b8; font-size: 0.9rem; padding: 20px;">üìÑ Resume loaded (${resumeText.length} characters). Analysis pending.</div>`;
          });
        }
        // Update Resume-Based option state
        updateResumeBasedOption();
      }
    }
  } else {
    // Show onboarding modal if terms are accepted but onboarding is not
    const termsAccepted = localStorage.getItem("termsAccepted") === "true";
    const privacyAccepted = localStorage.getItem("privacyAccepted") === "true";
    if (termsAccepted && privacyAccepted && onboardingModal) {
      onboardingModal.style.display = "flex";
      document.body.style.overflow = "hidden";
    }
  }
  
  // ========== MAPBOX LOCATION AUTCOMPLETE ==========
  const cityInput = document.getElementById("onboardingCity");
  const mapboxSuggestions = document.getElementById("mapboxSuggestions");
  const selectedCityDataInput = document.getElementById("selectedCityData");
  
  // Generate UUID for session token
  function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
  
  let mapboxSessionToken = generateUUID();
  let mapboxSearchTimeout = null;
  
  // Mapbox token - will be fetched from backend
  let MAPBOX_TOKEN = null;
  
  // Get Mapbox token from backend
  async function getMapboxToken() {
    if (MAPBOX_TOKEN) return MAPBOX_TOKEN;
    try {
      const response = await fetch(`${BACKEND_URL}/api/mapbox-token`);
      if (response.ok) {
        const data = await response.json();
        MAPBOX_TOKEN = data.token;
        return MAPBOX_TOKEN;
      }
    } catch (e) {
      console.error("Failed to get Mapbox token:", e);
    }
    return null;
  }
  
  // Mapbox city autocomplete (replaces old city/state/country autocomplete)
  if (cityInput && mapboxSuggestions) {
    cityInput.addEventListener("input", async (e) => {
      const query = e.target.value.trim();
      
      // Clear previous timeout
      if (mapboxSearchTimeout) {
        clearTimeout(mapboxSearchTimeout);
      }
      
      // Hide suggestions if query is too short (3+ chars required)
      if (query.length < 3) {
        mapboxSuggestions.style.display = "none";
        mapboxSuggestions.innerHTML = "";
        return;
      }
      
      // Get Mapbox token
      const token = await getMapboxToken();
      if (!token) {
        console.error("Mapbox token not available");
        mapboxSuggestions.innerHTML = '<div style="padding: 12px; color: #ef4444;">Mapbox search not configured</div>';
        mapboxSuggestions.style.display = "block";
        return;
      }
      
      // Show loading state
      mapboxSuggestions.style.display = "block";
      mapboxSuggestions.innerHTML = '<div style="padding: 12px; color: #94a3b8;">üîç Searching...</div>';
      
      // Debounce search (400ms)
      mapboxSearchTimeout = setTimeout(async () => {
        try {
          // Use backend proxy to avoid CORS issues
          const params = new URLSearchParams({
            q: query,
            types: 'place,locality',
            limit: '5',
            session_token: mapboxSessionToken
          });
          
          const response = await fetch(`${BACKEND_URL}/api/mapbox-search?${params.toString()}`, {
            method: 'GET',
            headers: {
              'Accept': 'application/json'
            }
          });
          
          if (!response.ok) {
            throw new Error(`Mapbox API error: ${response.status}`);
          }
          
          const data = await response.json();
          const suggestions = data.suggestions || [];
          
          if (suggestions.length === 0) {
            mapboxSuggestions.innerHTML = '<div style="padding: 12px; color: #94a3b8;">No cities found</div>';
            return;
          }
          
          // Render suggestions with city, state, country format
          mapboxSuggestions.innerHTML = suggestions.map((s, index) => {
            // Extract city, state, and country from Mapbox response context
            // City can be in context.locality, context.place, or name for locality/place features
            const cityName = s.context?.locality?.name || 
                            s.context?.place?.name || 
                            (s.feature_type === 'locality' || s.feature_type === 'place' ? s.name : '') ||
                            s.name || '';
            
            const stateProvince = s.context?.region?.name || s.context?.postcode?.name || '';
            const country = s.context?.country?.name || '';
            
            // Build display text: City, State/Province, Country
            const locationParts = [];
            if (cityName) locationParts.push(cityName);
            if (stateProvince) locationParts.push(stateProvince);
            if (country) locationParts.push(country);
            
            let displayText = locationParts.join(', ');
            
            // Fallback to place_formatted if we don't have proper location parts
            if (!displayText || (!cityName && locationParts.length < 2)) {
              displayText = s.place_formatted || s.full_address || s.name || 'Location';
            }
            
            return `
              <div class="suggestion-item" data-index="${index}" style="padding: 12px; cursor: pointer; border-bottom: 1px solid rgba(239, 68, 68, 0.1); transition: background 0.2s;" onmouseover="this.style.background='rgba(239, 68, 68, 0.1)'" onmouseout="this.style.background='transparent'">
                <div style="color: #e2e8f0; font-size: 0.95rem; font-weight: 500;">${displayText}</div>
              </div>
            `;
          }).join("");
          
          // Store suggestions data for click handler
          window.mapboxCurrentSuggestions = suggestions;
          
          // Add click handlers
          mapboxSuggestions.querySelectorAll(".suggestion-item").forEach(item => {
            item.addEventListener("click", () => {
              const index = parseInt(item.dataset.index);
              const suggestion = window.mapboxCurrentSuggestions[index];
              
              if (suggestion) {
                // Extract city, state, and country from Mapbox response context
                // City can be in context.locality, context.place, or name for locality/place features
                const cityName = suggestion.context?.locality?.name || 
                                suggestion.context?.place?.name || 
                                (suggestion.feature_type === 'locality' || suggestion.feature_type === 'place' ? suggestion.name : '') ||
                                suggestion.name || '';
                
                const stateProvince = suggestion.context?.region?.name || suggestion.context?.postcode?.name || '';
                const country = suggestion.context?.country?.name || '';
                
                // Store full suggestion data
                const cityData = {
                  place_formatted: suggestion.place_formatted,
                  full_address: suggestion.full_address,
                  mapbox_id: suggestion.mapbox_id,
                  feature_type: suggestion.feature_type,
                  // Extract city, state, and country from context
                  city: cityName,
                  country: country,
                  stateProvince: stateProvince
                };
                
                // Fill input with formatted location: City, State, Country
                const locationParts = [];
                if (cityName) locationParts.push(cityName);
                if (stateProvince) locationParts.push(stateProvince);
                if (country) locationParts.push(country);
                
                if (locationParts.length > 0) {
                  cityInput.value = locationParts.join(', ');
                } else {
                  cityInput.value = suggestion.place_formatted || suggestion.full_address || '';
                }
                
                if (selectedCityDataInput) {
                  selectedCityDataInput.value = JSON.stringify(cityData);
                }
                
                // Close dropdown
                mapboxSuggestions.style.display = "none";
              }
            });
          });
        } catch (error) {
          console.error("Mapbox search error:", error);
          mapboxSuggestions.innerHTML = '<div style="padding: 12px; color: #ef4444;">Search error. Please try again.</div>';
        }
      }, 400); // 400ms debounce
    });
    
    // Hide suggestions when clicking outside
    document.addEventListener("click", (e) => {
      if (cityInput && !cityInput.contains(e.target) && mapboxSuggestions && !mapboxSuggestions.contains(e.target)) {
        mapboxSuggestions.style.display = "none";
      }
    });
  }
  
  // Old state/Province autocomplete - REMOVED (no longer needed with Mapbox)
  
  // Handle resume upload in onboarding
  if (onboardingResumeInput) {
    onboardingResumeInput.addEventListener("change", async (event) => {
      const file = event.target.files[0];
      if (!file) return;
      
      onboardingResumeStatus.textContent = "Reading resume file...";
      onboardingResumeStatus.style.color = "#94a3b8";
      
      try {
        // Check if it's a PDF
        if (file.type === "application/pdf" || file.name.toLowerCase().endsWith(".pdf")) {
          if (typeof pdfjsLib === "undefined") {
            onboardingResumeStatus.textContent = "PDF.js library is loading... Please wait.";
            await new Promise(resolve => setTimeout(resolve, 1000));
            if (typeof pdfjsLib === "undefined") {
              onboardingResumeStatus.textContent = "PDF.js failed to load. Please refresh.";
              onboardingResumeStatus.style.color = "#ef4444";
              return;
            }
          }
          
          const arrayBuffer = await file.arrayBuffer();
          const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
          
          let fullText = "";
          for (let i = 1; i <= pdf.numPages; i++) {
            const page = await pdf.getPage(i);
            const textContent = await page.getTextContent();
            const pageText = textContent.items.map(item => item.str).join(" ");
            fullText += pageText + " ";
          }
          
          resumeText = fullText.replace(/\s+/g, " ").trim();
          
          if (!resumeText || resumeText.length < 10) {
            onboardingResumeStatus.textContent = "Could not extract text from PDF. Try a .txt file.";
            onboardingResumeStatus.style.color = "#ef4444";
            return;
          }
          
          onboardingResumeStatus.textContent = `‚úì Resume loaded (${resumeText.length} characters)`;
          onboardingResumeStatus.style.color = "#10b981";
        } else {
          // Text file
          const text = await file.text();
          resumeText = text.replace(/\s+/g, " ").trim();
          
          if (!resumeText || resumeText.length < 10) {
            onboardingResumeStatus.textContent = "Resume file appears to be empty.";
            onboardingResumeStatus.style.color = "#ef4444";
            return;
          }
          
          onboardingResumeStatus.textContent = `‚úì Resume loaded (${resumeText.length} characters)`;
          onboardingResumeStatus.style.color = "#10b981";
        }
        
        // Parse resume with AI if we have text
        if (resumeText && resumeText.length > 10) {
          onboardingResumeStatus.textContent = "ü§ñ Analyzing resume with AI...";
          try {
            const analysis = await parseResumeWithAI(resumeText);
            if (analysis) {
              resumeAnalysis = analysis;
              onboardingResumeStatus.textContent = `‚úì Resume analyzed successfully`;
              updateResumeBasedOption(); // Enable Resume-Based option after resume is analyzed
            }
          } catch (e) {
            console.error("Resume analysis error:", e);
            onboardingResumeStatus.textContent = `‚úì Resume loaded (analysis skipped)`;
            // Even if analysis fails, if we have resume text, enable the option
            if (resumeText && resumeText.length > 10) {
              updateResumeBasedOption();
            }
          }
        }
      } catch (error) {
        console.error("Resume upload error:", error);
        onboardingResumeStatus.textContent = "Error loading resume: " + error.message;
        onboardingResumeStatus.style.color = "#ef4444";
      }
    });
  }
  
  // Handle onboarding form submission
  // FIXED: Removed duplicate country/stateProvince declarations (2024-11-27)
  if (onboardingForm) {
    onboardingForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      
      const city = document.getElementById("onboardingCity").value.trim();
      const jobType = document.getElementById("onboardingJobType").value;
      const departmentName = document.getElementById("onboardingDepartmentName").value.trim();
      const name = document.getElementById("onboardingName") ? document.getElementById("onboardingName").value.trim() : "";
      const voicePreference = document.getElementById("onboardingVoice") ? document.getElementById("onboardingVoice").value : "";
      
      // Get selected city data from Mapbox
      const selectedCityData = document.getElementById("selectedCityData").value;
      let cityData = null;
      if (selectedCityData) {
        try {
          cityData = JSON.parse(selectedCityData);
        } catch (e) {
          console.error("Failed to parse city data:", e);
        }
      }
      
      // Validate required fields
      if (!city || !jobType || !departmentName) {
        alert("Please fill in all required fields (marked with *)");
        return;
      }
      
      // Extract location info from Mapbox data or use form values as fallback
      const country = cityData?.country || document.getElementById("onboardingCountry")?.value || "";
      const stateProvince = cityData?.stateProvince || document.getElementById("onboardingStateProvince")?.value || "";
      const cityName = city;
      
      // Save onboarding data
      onboardingData = {
        country,
        stateProvince,
        city: cityName,
        cityData: cityData, // Store full Mapbox data
        jobType,
        departmentName,
        name: name || null,
        voicePreference: voicePreference || null,
        cityResearch: null // Will be populated by backend
      };
      
      localStorage.setItem("onboardingData", JSON.stringify(onboardingData));
      localStorage.setItem("onboardingComplete", "true");
      
      // Log visit to analytics
      try {
        const sessionId = getSessionId();
        await fetch(`${BACKEND_URL}/api/analytics/visit`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({
            sessionId,
            city: cityName,
            stateProvince,
            country,
            departmentName,
            jobType
          })
        });
      } catch (analyticsError) {
        console.error('Analytics logging error:', analyticsError);
        // Don't block user flow if analytics fails
      }
      
      // Set voice preference immediately
      if (onboardingData.voicePreference) {
        selectedVoicePreference = onboardingData.voicePreference;
      }
      
      // Update user profile on backend with onboarding data (without city research for now)
      await updateUserProfile();
      
      // Hide onboarding modal and show main app immediately
      if (onboardingModal) {
        onboardingModal.style.display = "none";
      }
      if (mainApp) {
        mainApp.style.display = "block";
      }
      document.body.style.overflow = "auto";
      
      // Research city information in the background (fire-and-forget)
      // This won't block the user from proceeding
      (async () => {
        try {
          console.log("Starting background city research...");
          
          // Call backend to research city information (no await - runs in background)
          const response = await fetch(`${BACKEND_URL}/api/research-city`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              country,
              stateProvince,
              city,
              jobType,
              departmentName
            })
          });
          
          if (!response.ok) {
            throw new Error(`Backend error: ${response.status}`);
          }
          
          const data = await response.json();
          onboardingData.cityResearch = data.research;
          localStorage.setItem("onboardingData", JSON.stringify(onboardingData));
          
          // Update user profile with city research
          await updateUserProfile();
          
          console.log("Background city research completed:", data.research);
          
          // Show a subtle notification that research is complete
          const notification = document.createElement("div");
          notification.style.cssText = "position: fixed; top: 20px; right: 20px; background: #10b981; color: white; padding: 12px 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 10000; font-size: 14px; animation: slideIn 0.3s ease;";
          notification.textContent = "‚úì City research completed";
          document.body.appendChild(notification);
          
          setTimeout(() => {
            notification.style.animation = "slideOut 0.3s ease";
            setTimeout(() => notification.remove(), 300);
          }, 3000);
        } catch (error) {
          console.error("Background city research error:", error);
          // Silently fail - user can still use the app
        }
      })();
      
      // Resume will be processed by the main app when it loads
      // The resumeText and resumeAnalysis variables are already set
    });
  }

  // Debug console removed - no longer needed

  // ========== API CONFIGURATION ==========
  // Note: BACKEND_URL and all state variables are declared in the FIRST script tag (line 1996)
  // to ensure they're available before any code tries to use them
  
  // Always use backend service (API keys are hidden on the server)
  const USE_BACKEND = true;
  
  // ========== CREDIT SYSTEM ==========
  // Trial credits tracking (localStorage for anonymous users)
  // Trial credits management - CRITICAL: Preserve on page refresh
  function getTrialCreditsRemaining() {
    const stored = localStorage.getItem('trial_credits_remaining');
    if (stored === null || stored === undefined) {
      // Only initialize if truly missing (first visit)
      localStorage.setItem('trial_credits_remaining', '3');
      console.log('[TRIAL CREDITS] First visit - initialized with 3 credits');
      return 3;
    }
    const credits = parseInt(stored, 10);
    console.log('[TRIAL CREDITS] Retrieved from localStorage:', credits);
    return isNaN(credits) ? 0 : credits;
  }
  
  function setTrialCreditsRemaining(count) {
    const safeCount = Math.max(0, Math.min(3, parseInt(count, 10) || 0));
    localStorage.setItem('trial_credits_remaining', safeCount.toString());
    console.log('[TRIAL CREDITS] Updated to:', safeCount);
    updateTrialCreditsDisplay();
  }
  
  function consumeTrialCredit() {
    const current = getTrialCreditsRemaining();
    if (current > 0) {
      setTrialCreditsRemaining(current - 1);
      return true;
    }
    return false;
  }
  
  // User authentication state (already declared above)
  
  // Helper function to handle 401 errors globally
  function handleAuthError() {
    console.log('[AUTH] Authentication error detected - clearing user state');
    currentUser = null;
    authToken = null;
    setAuthToken(null);
    // Clear stored user backup
    localStorage.removeItem('currentUser');
    // Clear cookie
    document.cookie = 'authToken=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; domain=.onrender.com;';
    document.cookie = 'authToken=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
    updateAuthUI();
    updateTrialCreditsDisplay();
  }
  
  // Helper to get auth token (from cookie or localStorage)
  function getAuthToken() {
    // Try cookie first
    const cookieToken = document.cookie.split('; ').find(row => row.startsWith('authToken='))?.split('=')[1];
    if (cookieToken) return cookieToken;
    
    // Fallback to localStorage
    const storedToken = localStorage.getItem('authToken');
    if (storedToken) return storedToken;
    
    return null;
  }
  
  // Helper to set auth token in localStorage as fallback
  function setAuthToken(token) {
    if (token) {
      localStorage.setItem('authToken', token);
    } else {
      localStorage.removeItem('authToken');
    }
  }
  
  // Helper to make authenticated fetch requests
  async function authenticatedFetch(url, options = {}) {
    const token = getAuthToken();
    
    // Add Authorization header if we have a token
    if (token && !options.headers) {
      options.headers = {};
    }
    if (token) {
      options.headers = options.headers || {};
      options.headers['Authorization'] = `Bearer ${token}`;
    }
    
    // Always include credentials for cookies
    options.credentials = 'include';
    
    return fetch(url, options);
  }
  
  // Check authentication on page load
  async function checkAuth() {
    // Ensure BACKEND_URL is available
    if (typeof BACKEND_URL === 'undefined') {
      console.error('[AUTH] BACKEND_URL not defined - cannot check auth');
      return;
    }
    
    try {
      const response = await authenticatedFetch(`${BACKEND_URL}/api/auth/me`);
      
      if (response.ok) {
        currentUser = await response.json();
        // Store user in localStorage as backup for network errors
        localStorage.setItem('currentUser', JSON.stringify(currentUser));
        // Update token from cookie or keep existing
        authToken = getAuthToken();
        
        // If user is authenticated, ensure onboardingComplete is set and load onboarding data if available
        const savedOnboardingData = localStorage.getItem('onboardingData');
        if (savedOnboardingData) {
          try {
            onboardingData = JSON.parse(savedOnboardingData);
            localStorage.setItem('onboardingComplete', 'true');
            console.log('[AUTH] Loaded onboarding data from localStorage for authenticated user');
          } catch (e) {
            console.error('[AUTH] Failed to parse saved onboarding data:', e);
          }
        } else {
          // User is authenticated but no onboarding data - still mark onboarding as complete
          // (they can access onboarding from settings if needed)
          localStorage.setItem('onboardingComplete', 'true');
          console.log('[AUTH] User authenticated - setting onboardingComplete to true');
        }
        
        updateAuthUI();
        await updateCreditsDisplay();
        console.log('[AUTH] Successfully authenticated user:', currentUser.email);
      } else {
        // Only clear user state on actual auth errors (401/403), not network errors
        if (response.status === 401 || response.status === 403) {
          console.log('[AUTH] Token invalid or expired - clearing auth state');
          handleAuthError();
        } else {
          // Other errors (500, network issues) - don't clear auth, just log
          console.warn('[AUTH] Auth check failed with status:', response.status, '- preserving existing auth state');
          // Try to preserve existing user state from localStorage if available
          const storedUser = localStorage.getItem('currentUser');
          if (storedUser) {
            try {
              currentUser = JSON.parse(storedUser);
              console.log('[AUTH] Using stored user data due to network error');
              updateAuthUI();
            } catch (e) {
              console.error('[AUTH] Failed to parse stored user:', e);
            }
          }
        }
      }
    } catch (error) {
      // Network errors or other exceptions - don't clear auth state
      console.error('[AUTH] Auth check error (network/exception):', error.message);
      console.log('[AUTH] Preserving existing auth state due to network error');
      
      // Try to restore from localStorage if we have a token
      const token = getAuthToken();
      if (token) {
        const storedUser = localStorage.getItem('currentUser');
        if (storedUser) {
          try {
            currentUser = JSON.parse(storedUser);
            console.log('[AUTH] Restored user from localStorage due to network error');
            updateAuthUI();
          } catch (e) {
            console.error('[AUTH] Failed to restore user from localStorage:', e);
          }
        }
      } else {
        // No token at all - user is truly not logged in
        currentUser = null;
        updateAuthUI();
        updateTrialCreditsDisplay();
      }
    }
  }
  
  // Update authentication UI
  function updateAuthUI() {
    const authButtons = document.getElementById('authButtons');
    const userMenu = document.getElementById('userMenu');
    const userEmail = document.getElementById('userEmail');
    
    if (currentUser) {
      // Logged in - show user menu, hide login/signup
      if (authButtons) authButtons.style.display = 'none';
      if (userMenu) {
        userMenu.style.display = 'block';
        if (userEmail) {
          userEmail.textContent = currentUser.name || currentUser.email || 'User';
        }
      }
    } else {
      // Not logged in - show login/signup, hide user menu
      if (authButtons) authButtons.style.display = 'flex';
      if (userMenu) userMenu.style.display = 'none';
    }
    
    // Update credits display
    updateCreditsDisplay();
  }
  
  // Update credits display
  async function updateCreditsDisplay() {
    if (!currentUser) {
      updateTrialCreditsDisplay();
      return;
    }
    
    // For logged-in users, fetch latest balance
    try {
      const response = await authenticatedFetch(`${BACKEND_URL}/api/credits/balance`);
      
      if (response.ok) {
        const data = await response.json();
        currentUser.credits_balance = data.credits_balance || 0;
      }
    } catch (error) {
      console.error('Error updating credits display:', error);
    }
    
    // Update credits display
    const creditsCountEl = document.getElementById('creditsCount');
    const creditsDisplay = document.getElementById('creditsDisplay');
    const trialCreditsDisplay = document.getElementById('trialCreditsDisplay');
    
    if (currentUser) {
      if (creditsCountEl) {
        creditsCountEl.textContent = currentUser.credits_balance || 0;
      }
      if (creditsDisplay) creditsDisplay.style.display = 'flex';
      if (trialCreditsDisplay) trialCreditsDisplay.style.display = 'none';
    }
  }
  
  // Update trial credits display
  function updateTrialCreditsDisplay() {
    if (!currentUser) {
      const remaining = getTrialCreditsRemaining();
      const trialCreditsCountEl = document.getElementById('trialCreditsCount');
      const creditsDisplay = document.getElementById('creditsDisplay');
      const trialCreditsDisplay = document.getElementById('trialCreditsDisplay');
      
      if (trialCreditsCountEl) {
        trialCreditsCountEl.textContent = remaining;
      }
      // Update dropdown count too
      const trialCreditsCountDropdown = document.getElementById('trialCreditsCountDropdown');
      if (trialCreditsCountDropdown) {
        trialCreditsCountDropdown.textContent = remaining;
      }
      if (creditsDisplay) creditsDisplay.style.display = 'none';
      if (trialCreditsDisplay) trialCreditsDisplay.style.display = 'flex';
    }
  }
  
  // Check if user can use a question (has credits or trial)
  function canUseQuestion() {
    if (currentUser) {
      // Authenticated user - need paid credits
      return (currentUser.credits_balance || 0) > 0;
    } else {
      // Anonymous user - check trial credits
      return getTrialCreditsRemaining() > 0;
    }
  }
  
  // Show paywall if no credits
  function showPaywallIfNeeded() {
    if (!canUseQuestion()) {
      const paywallModal = document.getElementById('paywallModal');
      if (paywallModal) {
        paywallModal.style.display = 'flex';
      }
      return true;
    }
    return false;
  }
  
  // Initialize practice mode toggle listeners (run immediately, not on DOMContentLoaded)
  function initializePracticeModeToggle() {
    const simulationModeEl = document.getElementById("simulationMode");
    const specificModeEl = document.getElementById("specificMode");
    const categorySelectorEl = document.getElementById("categorySelector");
    const categorySelectEl = document.getElementById("categorySelect");
    
    if (simulationModeEl && specificModeEl) {
      simulationModeEl.addEventListener("change", (e) => {
        if (e.target.checked) {
          practiceMode = "simulation";
          // Uncheck the other practice mode
          if (specificModeEl) specificModeEl.checked = false;
          if (categorySelectorEl) categorySelectorEl.style.display = "none";
          selectedCategory = "";
          if (categorySelectEl) categorySelectEl.value = "";
          console.log("Practice mode: Interview Simulation (Random)");
        } else {
          // If unchecking, ensure at least one is checked
          if (!specificModeEl.checked) {
            e.target.checked = true;
          }
        }
      });
      
      specificModeEl.addEventListener("change", (e) => {
        if (e.target.checked) {
          practiceMode = "specific";
          // Uncheck the other practice mode
          if (simulationModeEl) simulationModeEl.checked = false;
          if (categorySelectorEl) {
            categorySelectorEl.style.display = "block";
            console.log("Category selector shown");
          }
          console.log("Practice mode: User-Specific Practice");
        } else {
          // If unchecking, ensure at least one is checked
          if (!simulationModeEl.checked) {
            e.target.checked = true;
          }
        }
      });
      
      // Sync initial state
      if (simulationModeEl.checked) {
        practiceMode = "simulation";
        if (categorySelectorEl) categorySelectorEl.style.display = "none";
      } else if (specificModeEl.checked) {
        practiceMode = "specific";
        if (categorySelectorEl) categorySelectorEl.style.display = "block";
      }
    } else {
      console.warn("Practice mode toggle elements not found");
    }
    
    if (categorySelectEl) {
      categorySelectEl.addEventListener("change", () => {
        selectedCategory = categorySelectEl.value;
        console.log("Selected category:", selectedCategory || "All Categories");
        
        // Check if City & Department Specific is selected and research is not ready
        if (selectedCategory === "City & Department Specific") {
          const savedOnboarding = localStorage.getItem("onboardingData");
          // onboardingData is already declared in first script tag
          if (savedOnboarding) {
            try {
              onboardingData = JSON.parse(savedOnboarding);
            } catch (e) {
              console.error("Failed to parse onboarding data:", e);
            }
          }
          
          if (!onboardingData || !onboardingData.cityResearch) {
            alert("City research is still in progress. Please wait a moment for the research to complete, or select a different category. You'll see a notification when research is ready.");
            categorySelectEl.value = "";
            selectedCategory = "";
          }
        }
      });
    } else {
      console.warn("Category select element not found");
    }
  }
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializePracticeModeToggle);
  } else {
    // DOM already loaded
    initializePracticeModeToggle();
  }

  // API configuration removed - always using backend service

  // Voice preference for TTS
  let selectedVoicePreference = null;
  
  // Generate or retrieve session ID for user profile
  function getSessionId() {
    let sessionId = localStorage.getItem('userSessionId');
    if (!sessionId) {
      sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      localStorage.setItem('userSessionId', sessionId);
    }
    return sessionId;
  }
  
  // Update user profile on backend
  async function updateUserProfile() {
    const sessionId = getSessionId();
    try {
      await fetch(`${BACKEND_URL}/api/user-profile`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          sessionId: sessionId,
          name: onboardingData.name,
          city: onboardingData.city,
          stateProvince: onboardingData.stateProvince,
          country: onboardingData.country,
          departmentName: onboardingData.departmentName,
          jobType: onboardingData.jobType,
          voicePreference: onboardingData.voicePreference,
          resumeText: resumeText || null,
          resumeAnalysis: resumeAnalysis || null,
          cityResearch: onboardingData.cityResearch || null
        })
      });
    } catch (error) {
      console.error('Failed to update user profile:', error);
      // Non-critical, continue without profile update
    }
  }

  const questionBank = [
    {
      category: "Behavioural ‚Äì High Stress",
      template: "Tell me about a time you responded to a high-stress emergency. How did you keep scene control and communicate clearly with your team?",
      tags: ["stress", "communication", "teamwork"]
    },
    {
      category: "Behavioural ‚Äì Conflict",
      template: "Describe a situation where you disagreed with a decision from a senior firefighter, officer, or supervisor. How did you handle it?",
      tags: ["conflict", "professionalism", "chain of command"]
    },
    {
      category: "Safety & Accountability",
      template: "Tell me about a mistake you made on a call or during training. What did you do in the moment and what did you change afterwards?",
      tags: ["safety", "accountability", "learning"]
    },
    {
      category: "Medical / EMR",
      template: "Walk me through how you would approach a call for a patient in respiratory distress. Assume you‚Äôre responding as an EMR or first responder.",
      tags: ["medical", "EMR", "assessment"]
    },
    {
      category: "Teamwork",
      template: "Give me an example of when you had to rely heavily on your crew or teammates to get a task done safely.",
      tags: ["teamwork", "trust", "communication"]
    },
    {
      category: "Community Focus",
      template: "Why do you want to serve in this community specifically, and what have you already done that shows commitment to serving others?",
      tags: ["community", "motivation"]
    },
    {
      category: "Resilience",
      template: "Tell me about a time outside the fire service where you had to push through fatigue or setbacks to reach a goal.",
      tags: ["resilience", "fitness", "discipline"]
    },
    {
      category: "Technical ‚Äì Fireground",
      template: "Explain your approach when you arrive first on scene to a structure fire with smoke showing but no flames visible.",
      tags: ["size-up", "fireground", "command"]
    }
  ];

  const firefighterKeywords = [
    "firefighter", "fire service", "POC", "paid on call", "EMR", "first responder",
    "ICS", "incident command", "medical", "patient", "scene safety",
    "hoseline", "ladder", "SCBA", "BA", "RIT", "rapid intervention",
    "construction", "glazing", "windows", "leadership", "team lead",
    "training", "drill", "community", "volunteer", "rescue"
  ];

  // Additional state variables (resumeKeywords, currentQuestion, etc. declared here)
  let currentQuestion = null;
  let questionCount = 0;
  let conversationHistory = []; // Track Q&A for context-aware followups
  let isFollowupQuestion = false; // Track if current question is a followup
  let askedQuestions = new Set(); // Track all asked questions (by text) to prevent duplicates
  let askedCategories = new Set(); // Track question categories to ensure diversity
  let resumeTopicsCovered = new Set(); // Track resume topics/questions covered
  let flaggedQuestions = []; // Track flagged questions
  let onlyFlaggedMode = false; // Toggle for practicing only flagged questions

  let cameraStream = null;
  let motionCtx = null;
  let lastFrameData = null;
  let motionSamples = [];
  let motionIntervalId = null;

  let recognition = null;
  let recognizing = false;
  let liveTranscriptText = "";
  let lastAnswerTranscript = "";
  let motionScoreForAnswer = null;

  // ========== CREDIT SYSTEM ==========
  // Note: currentUser, onboardingData, resumeText, etc. are all declared in the FIRST script tag
  const TRIAL_CREDITS_MAX = 3;
  const TRIAL_CREDITS_KEY = 'trial_credits_remaining';
  
  // Initialize trial credits - only if not already set (preserve existing credits)
  function initializeTrialCredits() {
    const existing = localStorage.getItem(TRIAL_CREDITS_KEY);
    if (existing === null || existing === undefined) {
      // Only initialize if truly missing
      localStorage.setItem(TRIAL_CREDITS_KEY, TRIAL_CREDITS_MAX.toString());
      console.log('[TRIAL CREDITS] Initialized with', TRIAL_CREDITS_MAX, 'credits');
    } else {
      console.log('[TRIAL CREDITS] Preserved existing credits:', existing);
    }
  }
  
  // Note: getTrialCreditsRemaining, setTrialCreditsRemaining, consumeTrialCredit 
  // are defined earlier in this script tag (around line 2844)
  
  // Check if user can use a question
  function canUseQuestion() {
    // If logged in with paid credits, yes
    if (currentUser && currentUser.credits_balance > 0) {
      return true;
    }
    // If not logged in, check trial credits
    if (!currentUser) {
      return getTrialCreditsRemaining() > 0;
    }
    // Logged in but no credits
    return false;
  }
  
  // Update trial credits display
  function updateTrialCreditsDisplay() {
    if (!currentUser) {
      const remaining = getTrialCreditsRemaining();
      const trialCreditsCountEl = document.getElementById('trialCreditsCount');
      const creditsDisplay = document.getElementById('creditsDisplay');
      const trialCreditsDisplay = document.getElementById('trialCreditsDisplay');
      
      if (trialCreditsCountEl) {
        trialCreditsCountEl.textContent = remaining;
      }
      // Update dropdown count too
      const trialCreditsCountDropdown = document.getElementById('trialCreditsCountDropdown');
      if (trialCreditsCountDropdown) {
        trialCreditsCountDropdown.textContent = remaining;
      }
      if (creditsDisplay) creditsDisplay.style.display = 'none';
      if (trialCreditsDisplay) trialCreditsDisplay.style.display = 'flex';
    }
  }
  
  
  // Get current user from backend
  async function fetchCurrentUser() {
    try {
      const response = await authenticatedFetch(`${BACKEND_URL}/api/auth/me`);
      
      if (response.ok) {
        const user = await response.json();
        currentUser = user;
        await updateCreditsDisplay();
        return user;
      } else {
        currentUser = null;
        await updateCreditsDisplay();
        return null;
      }
    } catch (error) {
      console.error('Error fetching current user:', error);
      currentUser = null;
      return null;
    }
  }
  
  // Show paywall modal
  function showPaywall() {
    const modal = document.getElementById('paywallModal');
    if (modal) {
      modal.style.display = 'flex';
      modal.classList.add('active');
    }
  }
  
  // Hide paywall modal
  function hidePaywall() {
    const modal = document.getElementById('paywallModal');
    if (modal) {
      modal.style.display = 'none';
      modal.classList.remove('active');
    }
  }
  
  // Show paywall if needed (checks credits) - duplicate removed, using the one above
  
  // Initialize on page load
  initializeTrialCredits();
  
  // Check user status on load (checkAuth already handles this)
  // checkAuth() is called in DOMContentLoaded event listener below
  
  // ========== VOICE SELECTION ==========
  let selectedVoice = null;
  
  // Find and cache the best available voice
  function initializeVoice() {
    if (selectedVoice) return selectedVoice;
    
    const voices = window.speechSynthesis.getVoices();
    if (!voices || voices.length === 0) {
      // Voices might not be loaded yet, try again after a short delay
      setTimeout(() => {
        const voices = window.speechSynthesis.getVoices();
        if (voices && voices.length > 0) {
          selectedVoice = selectBestVoice(voices);
        }
      }, 100);
      return null;
    }
    
    selectedVoice = selectBestVoice(voices);
    return selectedVoice;
  }
  
  function selectBestVoice(voices) {
    // Prioritize premium/neural voices that sound most like ChatGPT (natural, conversational)
    const premiumVoices = [
      "Google US English", "Google UK English", "Microsoft Zira", "Microsoft David",
      "Samantha", "Alex", "Victoria", "Daniel", "Karen", "Microsoft Mark", "Microsoft Hazel",
      "Alloy", "Echo", "Fable", "Onyx", "Nova", "Shimmer" // OpenAI-style names
    ];
    
    // First, try premium voices (most natural)
    for (const premium of premiumVoices) {
      const voice = voices.find(v => {
        const name = v.name.toLowerCase();
        return name.includes(premium.toLowerCase()) || 
               name.includes("neural") ||
               name.includes("premium") ||
               (premium === "Google US English" && (name.includes("google") && name.includes("us"))) ||
               (premium === "Google UK English" && (name.includes("google") && name.includes("uk")));
      });
      if (voice && voice.lang.startsWith("en")) {
        return voice;
      }
    }
    
    // Try to find voices that sound conversational (not robotic)
    const conversationalVoices = voices.filter(v => {
      const name = v.name.toLowerCase();
      return v.lang.startsWith("en") && 
             !name.includes("novelty") &&
             !name.includes("compact") &&
             !name.includes("robotic") &&
             (name.includes("female") || 
              name.includes("zira") || 
              name.includes("samantha") || 
              name.includes("victoria") ||
              name.includes("alex") ||
              name.includes("daniel") ||
              name.includes("karen"));
    });
    
    if (conversationalVoices.length > 0) {
      return conversationalVoices[0];
    }
    
    // Fallback: any English voice
    const englishVoices = voices.filter(v => 
      v.lang.startsWith("en") && 
      !v.name.toLowerCase().includes("novelty") &&
      !v.name.toLowerCase().includes("compact")
    );
    
    if (englishVoices.length > 0) {
      return englishVoices[0];
    }
    
    // Last resort: any voice
    return voices[0] || null;
  }
  
  // Load voices when they become available
  if (window.speechSynthesis) {
    window.speechSynthesis.onvoiceschanged = () => {
      initializeVoice();
    };
    // Try to initialize immediately
    initializeVoice();
  }

  // ========== RESUME HANDLING ==========

  const resumeInput = document.getElementById("resumeInput");
  const resumeSummaryEl = document.getElementById("resumeSummary");
  const resumeTagsEl = document.getElementById("resumeTags");
  const clearResumeBtn = document.getElementById("clearResumeBtn");

  // Function to update Resume-Based option state based on resume availability
  function updateResumeBasedOption() {
    const resumeBasedOption = document.getElementById('resumeBasedOption');
    const categorySelectEl = document.getElementById('categorySelect');
    
    if (resumeBasedOption && categorySelectEl) {
      const hasResume = (resumeText && resumeText.length > 10) || (resumeAnalysis !== null);
      
      if (hasResume) {
        resumeBasedOption.disabled = false;
        resumeBasedOption.style.color = '';
        resumeBasedOption.style.opacity = '1';
      } else {
        resumeBasedOption.disabled = true;
        resumeBasedOption.style.color = '#64748b';
        resumeBasedOption.style.opacity = '0.6';
        
        // If Resume-Based is currently selected, clear the selection
        if (categorySelectEl.value === 'Resume-Based') {
          categorySelectEl.value = '';
          selectedCategory = '';
        }
      }
    }
  }
  
  // Initialize Resume-Based option state on page load
  updateResumeBasedOption();

  resumeInput.addEventListener("change", handleResumeUpload);
  clearResumeBtn.addEventListener("click", () => {
    resumeInput.value = "";
    resumeText = "";
    resumeKeywords = [];
    resumeSummaryEl.textContent =
      "No resume loaded yet. Upload a file to extract keywords like ‚ÄúPOC firefighter‚Äù, ‚ÄúEMR‚Äù, ‚Äúconstruction‚Äù, etc.";
    resumeTagsEl.innerHTML = "";
    updateResumeBasedOption(); // Update option state when resume is cleared
  });

  async function handleResumeUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    resumeSummaryEl.textContent = "Reading resume file...";

    // Check if it's a PDF
    if (file.type === "application/pdf" || file.name.toLowerCase().endsWith(".pdf")) {
      try {
        // Check if PDF.js is loaded
        if (typeof pdfjsLib === "undefined") {
          resumeSummaryEl.textContent = "PDF.js library is loading... Please wait a moment and try again.";
          // Wait a bit and retry
          await new Promise(resolve => setTimeout(resolve, 1000));
          if (typeof pdfjsLib === "undefined") {
            resumeSummaryEl.textContent = "PDF.js failed to load. Please refresh the page or convert your PDF to .txt format.";
            return;
          }
        }
        
        // Use PDF.js to extract text from PDF
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        
        let fullText = "";
        // Extract text from all pages
        for (let i = 1; i <= pdf.numPages; i++) {
          const page = await pdf.getPage(i);
          const textContent = await page.getTextContent();
          const pageText = textContent.items.map(item => item.str).join(" ");
          fullText += pageText + " ";
        }
        
        resumeText = fullText.replace(/\s+/g, " ").trim();
        
        if (!resumeText || resumeText.length < 10) {
          resumeSummaryEl.textContent =
            "Could not extract text from PDF. The PDF might be image-based or corrupted. Try exporting as .txt or .docx.";
          return;
        }
        
        // Show loading state
        resumeSummaryEl.innerHTML = '<div style="text-align: center; color: #94a3b8; padding: 20px;">üìÑ Resume loaded. Analyzing...</div>';
        resumeKeywords = extractResumeKeywords(resumeText);
        renderResumeTags();
        
        // AI-powered resume analysis
        // Always use backend for AI analysis
        resumeSummaryEl.innerHTML = '<div style="text-align: center; color: #94a3b8; padding: 20px;">ü§ñ Analyzing resume with AI...</div>';
        await parseResumeWithAI(resumeText);
        updateResumeBasedOption(); // Enable Resume-Based option after resume is analyzed
      } catch (err) {
        console.error("PDF parsing error:", err);
        resumeSummaryEl.textContent =
          "Error reading PDF. Try converting to .txt or .docx format, or ensure the PDF contains selectable text (not just images).";
      }
    } else {
      // Handle text files (txt, doc, etc.)
      const reader = new FileReader();
      reader.onload = async (e) => {
        resumeText = String(e.target.result || "").replace(/\s+/g, " ").trim();
        if (!resumeText) {
          resumeSummaryEl.textContent =
            "Could not read text from this file. Try exporting your resume as .txt or .pdf.";
          return;
        }

        // Show loading state
        resumeSummaryEl.innerHTML = '<div style="text-align: center; color: #94a3b8; padding: 20px;">üìÑ Resume loaded. Analyzing...</div>';
        resumeKeywords = extractResumeKeywords(resumeText);
        renderResumeTags();
        
        // AI-powered resume analysis
        // Always use backend for AI analysis
        resumeSummaryEl.innerHTML = '<div style="text-align: center; color: #94a3b8; padding: 20px;">ü§ñ Analyzing resume with AI...</div>';
        await parseResumeWithAI(resumeText);
        updateResumeBasedOption(); // Enable Resume-Based option after resume is analyzed
      };

      reader.readAsText(file);
    }
  }
  
  // Format resume summary with clean, structured display
  function formatResumeSummary(element, analysis, rawText) {
    if (!element) return;
    
    if (analysis) {
      // Use AI analysis for clean summary
      const experience = analysis.experience || analysis.yearsOfExperience || "Not specified";
      const certifications = Array.isArray(analysis.certifications) ? analysis.certifications : [];
      const skills = Array.isArray(analysis.skills) ? analysis.skills : [];
      const workHistory = Array.isArray(analysis.workHistory) ? analysis.workHistory : [];
      const achievements = Array.isArray(analysis.achievements) ? analysis.achievements : [];
      const focusAreas = Array.isArray(analysis.interviewFocus) ? analysis.interviewFocus : [];
      
      let html = '<div style="color: #e2e8f0;">';
      
      // Experience
      html += `<div style="margin-bottom: 12px;">
        <div style="color: #fca5a5; font-weight: 600; font-size: 0.85rem; margin-bottom: 4px;">üìä Experience</div>
        <div style="color: #cbd5e1; font-size: 0.9rem;">${experience}</div>
      </div>`;
      
      // Certifications
      if (certifications.length > 0) {
        html += `<div style="margin-bottom: 12px;">
          <div style="color: #fca5a5; font-weight: 600; font-size: 0.85rem; margin-bottom: 4px;">üèÜ Certifications</div>
          <div style="color: #cbd5e1; font-size: 0.9rem;">${certifications.join(" ‚Ä¢ ")}</div>
        </div>`;
      }
      
      // Key Skills
      if (skills.length > 0) {
        html += `<div style="margin-bottom: 12px;">
          <div style="color: #fca5a5; font-weight: 600; font-size: 0.85rem; margin-bottom: 4px;">üíº Key Skills</div>
          <div style="color: #cbd5e1; font-size: 0.9rem;">${skills.slice(0, 6).join(" ‚Ä¢ ")}${skills.length > 6 ? "..." : ""}</div>
        </div>`;
      }
      
      // Interview Focus Areas
      if (focusAreas.length > 0) {
        html += `<div style="margin-bottom: 12px;">
          <div style="color: #fca5a5; font-weight: 600; font-size: 0.85rem; margin-bottom: 4px;">üéØ Interview Focus</div>
          <div style="color: #cbd5e1; font-size: 0.9rem;">${focusAreas.slice(0, 4).join(" ‚Ä¢ ")}</div>
        </div>`;
      }
      
      html += '</div>';
      element.innerHTML = html;
    } else if (rawText) {
      // Fallback: show basic info from raw text
      const preview = rawText.slice(0, 200).replace(/\s+/g, " ").trim();
      element.innerHTML = `<div style="color: #cbd5e1; font-size: 0.9rem; line-height: 1.6;">
        <div style="color: #fca5a5; font-weight: 600; margin-bottom: 8px;">üìÑ Resume Loaded</div>
        <div>${preview}${rawText.length > 200 ? "..." : ""}</div>
        <div style="margin-top: 8px; color: #94a3b8; font-size: 0.85rem;">Enable AI analysis for detailed summary</div>
      </div>`;
    } else {
      element.innerHTML = '<div style="color: #94a3b8; font-size: 0.9rem; text-align: center; padding: 20px;">No resume loaded yet.</div>';
    }
  }

  async function parseResumeWithAI(text) {
    // Always use backend
    try {
      console.log("[RESUME] Starting resume parsing, text length:", text ? text.length : 0);
      const response = await fetch(`${BACKEND_URL}/api/parse-resume`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ resumeText: text, sessionId: getSessionId() })
      });
      
      console.log("[RESUME] Backend response status:", response.status);
      
      if (response.ok) {
        const data = await response.json();
        console.log("[RESUME] Received analysis data:", data);
        resumeAnalysis = data.analysis;
        formatResumeSummary(resumeSummaryEl, resumeAnalysis, resumeText);
        
        // Update user profile with resume analysis
        await updateUserProfile();
        
        // Enable Resume-Based option now that resume is analyzed
        updateResumeBasedOption();
        
        return;
      } else {
        const errorText = await response.text();
        console.error("[RESUME] Backend error response:", response.status, errorText);
        throw new Error(`Backend error: ${response.status} - ${errorText}`);
      }
    } catch (err) {
      console.error("[RESUME] Resume parsing error:", err);
      console.error("[RESUME] Error details:", {
        message: err.message,
        stack: err.stack,
        name: err.name
      });
      
      // Show user-friendly error message
      if (resumeSummaryEl) {
        resumeSummaryEl.innerHTML = `
          <div style="color: #fca5a5; padding: 16px; background: rgba(239, 68, 68, 0.1); border-radius: 8px; border: 1px solid rgba(239, 68, 68, 0.3);">
            <div style="font-weight: 600; margin-bottom: 8px;">‚ö†Ô∏è Resume Analysis Failed</div>
            <div style="font-size: 0.9rem; color: #cbd5e1;">
              ${err.message || "Unable to analyze resume. Please check your connection and try again."}
            </div>
            <div style="margin-top: 12px; font-size: 0.85rem; color: #94a3b8;">
              You can still use the app - questions will be generated without resume context.
            </div>
          </div>
        `;
      }
      
      // Fallback: show raw resume text
      formatResumeSummary(resumeSummaryEl, null, resumeText);
    }
  }

  function extractResumeKeywords(text) {
    const lower = text.toLowerCase();
    const counts = {};

    firefighterKeywords.forEach((k) => {
      const regex = new RegExp("\\b" + escapeRegExp(k.toLowerCase()) + "\\b", "g");
      const matches = lower.match(regex);
      if (matches && matches.length > 0) {
        counts[k] = matches.length;
      }
    });

    const extraPatterns = [
      "captain",
      "officer",
      "volunteer",
      "paramedic",
      "wildland",
      "responder",
      "crew",
      "team lead"
    ];
    extraPatterns.forEach((k) => {
      const regex = new RegExp("\\b" + escapeRegExp(k.toLowerCase()) + "\\b", "g");
      const matches = lower.match(regex);
      if (matches && matches.length > 0) {
        counts[k] = (counts[k] || 0) + matches.length;
      }
    });

    return Object.entries(counts)
      .sort((a, b) => b[1] - a[1])
      .map(([word, count]) => ({ word, count }));
  }

  function renderResumeTags() {
    resumeTagsEl.innerHTML = "";
    if (!resumeKeywords.length) {
      const span = document.createElement("span");
      span.className = "tag";
      span.textContent = "No firefighter-specific keywords detected yet.";
      resumeTagsEl.appendChild(span);
      return;
    }
    resumeKeywords.slice(0, 10).forEach((k) => {
      const span = document.createElement("span");
      span.className = "tag";
      span.textContent = `${k.word} √ó${k.count}`;
      resumeTagsEl.appendChild(span);
    });
  }

  // ========== QUESTION SELECTION & TTS ==========

  const nextQuestionBtn = document.getElementById("nextQuestionBtn");
  const repeatQuestionBtn = document.getElementById("repeatQuestionBtn");
  const questionTextEl = document.getElementById("questionText");
  const questionCategoryLabelEl = document.getElementById("questionCategoryLabel");
  const questionIndexEl = document.getElementById("questionIndex");

  // Function to update button text based on question count
  function updateNextQuestionButtonText() {
    if (nextQuestionBtn) {
      if (questionCount === 0) {
        nextQuestionBtn.textContent = "üé§ Start Interview";
      } else {
        nextQuestionBtn.textContent = APP_CONFIG ? APP_CONFIG.buttons.nextQuestion : "üé§ Next Question";
      }
    }
  }
  
  // Initialize button text
  updateNextQuestionButtonText();
  
  nextQuestionBtn.addEventListener("click", async () => {
    // Check if user can use a question (credits/trial)
    if (!canUseQuestion()) {
      showPaywallIfNeeded();
      return;
    }
    
    nextQuestionBtn.disabled = true;
    nextQuestionBtn.textContent = APP_CONFIG ? APP_CONFIG.status.generatingQuestion : "ü§ñ Generating question...";
      try {
        currentQuestion = await generateAIQuestion();
        if (currentQuestion) {
          questionCount++;
          isFollowupQuestion = false;
          
          // Update button text immediately after incrementing questionCount
          updateNextQuestionButtonText();
          
          // Track asked questions to prevent duplicates
          const questionText = currentQuestion.template.toLowerCase().trim();
          askedQuestions.add(questionText);
          if (currentQuestion.category) {
            askedCategories.add(currentQuestion.category.toLowerCase());
          }
          
          renderQuestion(currentQuestion);
          
          // Speak question - ensure it happens
          console.log("About to speak question:", currentQuestion.template.substring(0, 50) + "...");
          try {
            await speakQuestionWithCaptions(currentQuestion.template);
            console.log("Question speaking completed");
          } catch (ttsError) {
            console.error("TTS error:", ttsError);
            console.error("TTS error stack:", ttsError.stack);
            // Continue even if TTS fails
          }
          
          // Auto-start recording based on the user's Next Question click (browser-friendly)
          startAnswerRecording(true);
        }
    } catch (err) {
      console.error("Question generation error:", err);
      // Fallback to static question
      currentQuestion = questionBank[questionCount % questionBank.length];
      questionCount++;
      // Update button text immediately after incrementing questionCount
      updateNextQuestionButtonText();
      renderQuestion(currentQuestion);
      speakQuestionWithCaptions(currentQuestion.template);
      // Auto-start recording even when we fall back to a static question
      startAnswerRecording(true);
    } finally {
      nextQuestionBtn.disabled = false;
      // Button text already updated above, but ensure it's correct here too
      updateNextQuestionButtonText();
    }
  });

  repeatQuestionBtn.addEventListener("click", () => {
    if (currentQuestion) speakQuestionWithCaptions(currentQuestion.template);
  });

  async function generateAIQuestion() {
    // Check if only flagged mode is enabled
    if (onlyFlaggedMode && flaggedQuestions.length > 0) {
      // Return a random flagged question
      const randomIndex = Math.floor(Math.random() * flaggedQuestions.length);
      const flaggedQ = flaggedQuestions[randomIndex];
      return {
        template: flaggedQ.question,
        category: flaggedQ.category,
        isFlagged: true
      };
    }
    
    // ALWAYS generate a NEW, unrelated question (not a follow-up)
    // Follow-ups are only generated by the "Ask Followup Question" button
    
    // Use backend if enabled
    // Always use backend
    {
      try {
        const allAskedQuestions = Array.from(askedQuestions);
        const askedCategoriesList = Array.from(askedCategories);
        
        const response = await fetch(`${BACKEND_URL}/api/question`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            sessionId: getSessionId(),
            resumeText: resumeText,
            resumeAnalysis: resumeAnalysis,
            history: conversationHistory,
            askedQuestions: allAskedQuestions,
            askedCategories: askedCategoriesList,
            practiceMode: practiceMode,
            selectedCategory: selectedCategory,
            onboardingData: onboardingData,
            questionType: document.getElementById('questionTypeSelect')?.value || null,
            difficulty: document.getElementById('difficultySelect')?.value || null,
            useQuestionBank: true
          })
        });
        
        if (!response.ok) {
          throw new Error(`Backend error: ${response.status}`);
        }
        
        const data = await response.json();
        return {
          category: data.category,
          template: data.template,
          tags: data.tags || [],
          isAI: true,
          isFollowup: false
        };
      } catch (err) {
        console.error("Backend question generation error:", err);
        // Fall through to local/fallback
      }
    }
    
    // Always use backend - no local fallback needed
    try {
      const resumeContext = resumeAnalysis 
        ? `Resume Analysis: ${JSON.stringify(resumeAnalysis)}`
        : resumeText 
          ? `Resume Text (first 2000 chars): ${resumeText.slice(0, 2000)}`
          : "No resume provided";
      
      const conversationContext = conversationHistory.length > 0
        ? `\n\nPrevious questions asked:\n${conversationHistory.slice(-3).map((item, i) => 
            `${i + 1}. Q: ${item.question}\n   A: ${item.answer ? item.answer.slice(0, 200) + "..." : "No answer yet"}`
          ).join("\n")}`
        : "";

      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer " + "REMOVED" // Always use backend instead
        },
        body: JSON.stringify({
          model: "gpt-4o-mini",
          messages: [
            {
              role: "system",
              content: "You are an expert firefighter interview panel member. Generate realistic, challenging interview questions that test behavioral competencies, technical knowledge, and situational judgment. Focus on GENERAL, OPEN-ENDED situational questions that any firefighter candidate might face, similar to: 'How would you handle a situation if you felt you weren't treated fairly?' or 'How would you handle a leader where you question their leadership, would you still respect them?' Keep questions broad and applicable to all candidates, not overly specific to their resume. The questions should test judgment, ethics, chain of command, and decision-making in hypothetical scenarios. CRITICAL: Ensure questions are UNIQUE and cover diverse topics/areas. Vary the categories and themes to provide comprehensive coverage of different firefighter competencies. If a resume is provided, occasionally reference different aspects of their background (certifications, experience, skills) but keep questions general enough for all candidates."
            },
            {
              role: "user",
              content: `Generate a single firefighter interview question. Focus on GENERAL, OPEN-ENDED situational questions that test judgment, ethics, and decision-making.

${resumeContext}${conversationContext}${diversityContext}

Requirements:
- Question should be a GENERAL situational/hypothetical question (like "How would you handle a situation if...")
- Keep it broad and applicable to all candidates, not overly specific to their resume
- Examples of good questions:
  * "How would you handle a situation if you felt you weren't treated fairly?"
  * "How would you handle a leader where you question their leadership, would you still respect them?"
  * "Your Captain orders you to get a radio from the engine. On the way a senior fire officer stops you and asks you to deliver an axe to the team on the roof right away. How would you handle this?"
- Test: chain of command, ethics, judgment, decision-making, conflict resolution
- CRITICAL: The question MUST be completely different from any question already asked (see list above)
- Ensure diversity: Cover different topics and areas. If many questions have been asked, explore new categories/topics. Vary between: chain of command, ethics, conflict resolution, safety, teamwork, leadership, decision-making, communication, stress management, equipment, training, etc.
- If resume is provided, occasionally reference different aspects of their background (certifications, experience, skills) but keep questions general enough for all candidates
- Rotate through different question types: hypothetical scenarios, ethical dilemmas, chain of command situations, team dynamics, safety protocols, etc.
- Make it challenging but fair
- Format: "Category: [category]\nQuestion: [question text]"

Return ONLY the category and question in that format.`
            }
          ]
        })
      });

      const data = await response.json();
      if (data.choices && data.choices[0] && data.choices[0].message) {
        const content = data.choices[0].message.content;
        const categoryMatch = content.match(/Category:\s*(.+)/i);
        const questionMatch = content.match(/Question:\s*(.+)/is);
        
        const category = categoryMatch ? categoryMatch[1].trim() : "General";
        let question = questionMatch ? questionMatch[1].trim() : content.trim();
        
        // Check for duplicates - if question was already asked, try generating again (max 3 attempts)
        const questionTextLower = question.toLowerCase().trim();
        let attempts = 0;
        while (askedQuestions.has(questionTextLower) && attempts < 3) {
          console.log(`Duplicate question detected, regenerating... (attempt ${attempts + 1})`);
          // Make another API call with stronger emphasis on uniqueness
          const retryResponse = await fetch("https://api.openai.com/v1/chat/completions", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": "Bearer REMOVED" // Always use backend instead
            },
            body: JSON.stringify({
              model: "gpt-4o-mini",
              messages: [
                {
                  role: "system",
                  content: "You are an expert firefighter interview panel member. Generate realistic, challenging interview questions that test behavioral competencies, technical knowledge, and situational judgment. Focus on GENERAL, OPEN-ENDED situational questions that any firefighter candidate might face. Ensure questions are UNIQUE and cover diverse topics."
                },
                {
                  role: "user",
                  content: `Generate a UNIQUE firefighter interview question that is COMPLETELY DIFFERENT from these already asked questions:

${Array.from(askedQuestions).map((q, i) => `${i + 1}. ${q}`).join("\n")}

Categories already covered: ${Array.from(askedCategories).join(", ") || "None"}

${resumeContext}

Requirements:
- MUST be completely different from all questions above
- Cover a NEW topic/area if possible
- General situational/hypothetical question
- Test: chain of command, ethics, judgment, decision-making, conflict resolution
- Format: "Category: [category]\nQuestion: [question text]"

Return ONLY the category and question.`
                }
              ]
            })
          });
          
          const retryData = await retryResponse.json();
          if (retryData.choices && retryData.choices[0] && retryData.choices[0].message) {
            const retryContent = retryData.choices[0].message.content;
            const retryCategoryMatch = retryContent.match(/Category:\s*(.+)/i);
            const retryQuestionMatch = retryContent.match(/Question:\s*(.+)/is);
            question = retryQuestionMatch ? retryQuestionMatch[1].trim() : retryContent.trim();
            const newQuestionTextLower = question.toLowerCase().trim();
            if (!askedQuestions.has(newQuestionTextLower)) {
              break; // Found unique question
            }
          }
          attempts++;
        }
        
        // Final check - if still duplicate, use fallback
        const finalQuestionTextLower = question.toLowerCase().trim();
        if (askedQuestions.has(finalQuestionTextLower)) {
          console.warn("Could not generate unique question after retries, using fallback");
          // Find a question from bank that hasn't been asked
          const unusedQuestions = questionBank.filter(q => {
            const qText = q.template.toLowerCase().trim();
            return !askedQuestions.has(qText);
          });
          if (unusedQuestions.length > 0) {
            const fallbackQ = unusedQuestions[Math.floor(Math.random() * unusedQuestions.length)];
            return {
              template: fallbackQ.template,
              category: fallbackQ.category || category,
              isAI: false,
              isFollowup: false
            };
          }
        }
        
        return {
          category: category,
          template: question,
          tags: [],
          isAI: true
        };
      }
    } catch (err) {
      console.error("AI question generation error:", err);
      throw err;
    }
    
    // Fallback
    return questionBank[questionCount % questionBank.length];
  }

  async function generateFollowupQuestion() {
    const lastQA = conversationHistory[conversationHistory.length - 1];
    if (!lastQA || !lastQA.answer) {
      return await generateAIQuestion();
    }

    // Use backend if enabled
    // Always use backend
    {
      try {
        const response = await authenticatedFetch(`${BACKEND_URL}/api/followup`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            lastQuestion: lastQA.question,
            lastAnswer: lastQA.answer,
            history: conversationHistory
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          isFollowupQuestion = true;
          return {
            category: data.category,
            template: data.template,
            tags: data.tags || [],
            isAI: true,
            isFollowup: true
          };
        }
      } catch (err) {
        console.error("Backend followup error:", err);
        // Fall through to local
      }
    }

    // Always use backend - no local fallback
    // This code path should not be reached
    return questionBank[questionCount % questionBank.length];

    try {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer " + "REMOVED" // Always use backend instead
        },
        body: JSON.stringify({
          model: "gpt-4o-mini",
          messages: [
            {
              role: "system",
              content: "You are an expert firefighter interview panel member. Generate a followup question that digs deeper into the candidate's answer, just like a real panel would. Ask for clarification, more detail, or explore a related aspect."
            },
            {
              role: "user",
              content: `The candidate was asked: "${lastQA.question}"

Their answer: "${lastQA.answer.slice(0, 1000)}"

Generate a followup question that:
- Probes deeper into their answer
- Asks for specific examples or clarification
- Tests their knowledge or judgment further
- Is what a real firefighter panel would ask next

Format: "Category: [category]\nQuestion: [question text]"

Return ONLY the category and question.`
            }
          ]
        })
      });

      const data = await response.json();
      if (data.choices && data.choices[0] && data.choices[0].message) {
        const content = data.choices[0].message.content;
        const categoryMatch = content.match(/Category:\s*(.+)/i);
        const questionMatch = content.match(/Question:\s*(.+)/is);
        
        const category = categoryMatch ? categoryMatch[1].trim() : "Followup";
        const question = questionMatch ? questionMatch[1].trim() : content.trim();
        
        isFollowupQuestion = true;
        return {
          category: category,
          template: question,
          tags: [],
          isAI: true,
          isFollowup: true
        };
      }
    } catch (err) {
      console.error("Followup question generation error:", err);
    }
    
    // Fallback
    return questionBank[questionCount % questionBank.length];
  }

  function renderQuestion(q) {
    questionTextEl.textContent = q.template;
    const categoryLabel = q.isFollowup ? `(Followup - ${q.category})` : `(${q.category})`;
    questionCategoryLabelEl.textContent = categoryLabel;
    questionIndexEl.textContent = String(questionCount);
    
    // Show followup explanation if this is a followup question
    const questionSubtitlesEl = document.getElementById('questionSubtitles');
    if (questionSubtitlesEl) {
      if (q.isFollowup) {
        questionSubtitlesEl.style.display = 'block';
        questionSubtitlesEl.innerHTML = `
          <div style="display: flex; align-items: flex-start; gap: 8px;">
            <span style="font-size: 1.1rem; flex-shrink: 0;">üí°</span>
            <div style="line-height: 1.5;">
              <strong style="color: #fbbf24;">Why a followup?</strong> This question digs deeper into your previous answer, helping you explore the topic more thoroughly and identify any areas that need clarification. Real interview panels often ask followups to test your depth of knowledge and ensure you can handle probing questions.
            </div>
          </div>
        `;
      } else {
        questionSubtitlesEl.style.display = 'none';
      }
    }
    
    // Show flag button and update its state
    const flagBtn = document.getElementById('flagQuestionBtn');
    const flagIcon = document.getElementById('flagIcon');
    const flagText = document.getElementById('flagText');
    if (flagBtn && flagIcon) {
      flagBtn.style.display = 'flex';
      flagBtn.style.alignItems = 'center';
      const isFlagged = flaggedQuestions.some(fq => fq.question === q.template);
      flagIcon.textContent = 'üö©';
      if (flagText) {
        flagText.textContent = isFlagged ? 'Flagged' : 'Flag';
      }
      flagBtn.style.opacity = isFlagged ? '1' : '0.8';
      flagBtn.style.background = isFlagged ? 'rgba(239, 68, 68, 0.3)' : 'rgba(239, 68, 68, 0.15)';
      flagBtn.style.borderColor = isFlagged ? 'rgba(239, 68, 68, 0.6)' : 'rgba(239, 68, 68, 0.4)';
      
      // Remove any existing listeners and add new one
      const newFlagBtn = flagBtn.cloneNode(true);
      flagBtn.parentNode.replaceChild(newFlagBtn, flagBtn);
      newFlagBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log("Flag button clicked for question:", q.template.substring(0, 50));
        toggleFlagQuestion(q);
      });
    }
  }
  
  // Flagged Questions Management
  function loadFlaggedQuestions() {
    try {
      const stored = localStorage.getItem('flaggedQuestions');
      if (stored) {
        flaggedQuestions = JSON.parse(stored);
      }
    } catch (e) {
      console.error('Error loading flagged questions:', e);
      flaggedQuestions = [];
    }
    updateFlaggedCount();
  }
  
  function saveFlaggedQuestions() {
    try {
      localStorage.setItem('flaggedQuestions', JSON.stringify(flaggedQuestions));
      updateFlaggedCount();
      renderFlaggedModal();
    } catch (e) {
      console.error('Error saving flagged questions:', e);
    }
  }
  
  function toggleFlagQuestion(q) {
    console.log("toggleFlagQuestion called with:", q);
    if (!q || !q.template) {
      console.error("toggleFlagQuestion: Invalid question object", q);
      return;
    }
    
    const questionText = q.template;
    const index = flaggedQuestions.findIndex(fq => fq.question === questionText);
    
    const flagBtn = document.getElementById('flagQuestionBtn');
    const flagIcon = document.getElementById('flagIcon');
    const flagText = document.getElementById('flagText');
    
    if (index >= 0) {
      // Unflag
      flaggedQuestions.splice(index, 1);
      console.log("Question unflagged");
      if (flagBtn && flagIcon) {
        flagBtn.style.opacity = '0.8';
        flagBtn.style.background = 'rgba(239, 68, 68, 0.15)';
        flagBtn.style.borderColor = 'rgba(239, 68, 68, 0.4)';
        if (flagText) flagText.textContent = 'Flag';
      }
    } else {
      // Flag
      flaggedQuestions.push({
        question: questionText,
        category: q.category || 'Unknown',
        flaggedAt: Date.now()
      });
      console.log("Question flagged. Total flagged:", flaggedQuestions.length);
      if (flagBtn && flagIcon) {
        flagBtn.style.opacity = '1';
        flagBtn.style.background = 'rgba(239, 68, 68, 0.3)';
        flagBtn.style.borderColor = 'rgba(239, 68, 68, 0.6)';
        if (flagText) flagText.textContent = 'Flagged';
      }
    }
    saveFlaggedQuestions();
    updateFlaggedCount();
    
    // Show brief notification
    const notification = document.createElement('div');
    notification.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #10b981; color: white; padding: 12px 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 10005; font-size: 0.9rem;';
    notification.textContent = index >= 0 ? '‚úì Question unflagged' : '‚úì Question flagged';
    document.body.appendChild(notification);
    setTimeout(() => {
      notification.style.opacity = '0';
      notification.style.transition = 'opacity 0.3s';
      setTimeout(() => notification.remove(), 300);
    }, 2000);
  }
  
  function updateFlaggedCount() {
    const countEl = document.getElementById('flaggedCount');
    if (countEl) {
      countEl.textContent = flaggedQuestions.length;
    }
  }
  
  function renderFlaggedModal() {
    const listEl = document.getElementById('flaggedQuestionsList');
    if (!listEl) return;
    
    if (flaggedQuestions.length === 0) {
      listEl.innerHTML = '<p style="color: #94a3b8; text-align: center; padding: 20px;">No flagged questions yet. Flag questions you find difficult to practice them later.</p>';
      return;
    }
    
    listEl.innerHTML = flaggedQuestions.map((fq, index) => `
      <div style="padding: 16px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(239, 68, 68, 0.2); border-radius: 8px;">
        <div style="display: flex; justify-content: space-between; align-items: start; gap: 12px;">
          <div style="flex: 1;">
            <div style="color: #fca5a5; font-size: 0.75rem; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">${fq.category}</div>
            <div style="color: #e2e8f0; font-size: 0.95rem; line-height: 1.5;">${fq.question}</div>
          </div>
          <button onclick="removeFlaggedQuestion(${index})" style="background: rgba(239, 68, 68, 0.2); border: 1px solid rgba(239, 68, 68, 0.4); border-radius: 6px; color: #fca5a5; padding: 6px 12px; font-size: 0.85rem; cursor: pointer; transition: all 0.2s; white-space: nowrap;" onmouseover="this.style.background='rgba(239, 68, 68, 0.3)'" onmouseout="this.style.background='rgba(239, 68, 68, 0.2)'">Remove</button>
        </div>
      </div>
    `).join('');
  }
  
  window.removeFlaggedQuestion = function(index) {
    flaggedQuestions.splice(index, 1);
    saveFlaggedQuestions();
    if (currentQuestion) {
      renderQuestion(currentQuestion); // Update flag button state
    }
  };
  
  // Initialize flagged questions on load
  loadFlaggedQuestions();
  
  // Modal controls
  const flaggedModal = document.getElementById('flaggedModal');
  const viewFlaggedBtn = document.getElementById('viewFlaggedBtn');
  const closeFlaggedModal = document.getElementById('closeFlaggedModal');
  const onlyFlaggedToggle = document.getElementById('onlyFlaggedToggle');
  
  if (viewFlaggedBtn) {
    viewFlaggedBtn.addEventListener('click', () => {
      renderFlaggedModal();
      if (flaggedModal) flaggedModal.style.display = 'flex';
    });
  }
  
  if (closeFlaggedModal) {
    closeFlaggedModal.addEventListener('click', () => {
      if (flaggedModal) flaggedModal.style.display = 'none';
    });
  }
  
  if (flaggedModal) {
    flaggedModal.addEventListener('click', (e) => {
      if (e.target === flaggedModal) {
        flaggedModal.style.display = 'none';
      }
    });
  }
  
  if (onlyFlaggedToggle) {
    onlyFlaggedToggle.addEventListener('change', (e) => {
      onlyFlaggedMode = e.target.checked;
      if (onlyFlaggedMode && flaggedQuestions.length === 0) {
        alert('No flagged questions yet. Flag some questions first!');
        onlyFlaggedToggle.checked = false;
        onlyFlaggedMode = false;
      }
    });
  }
  
  // ========== AREAS TO WORK ON ==========
  const areasToWorkOnBtn = document.getElementById('areasToWorkOnBtn');
  const areasToWorkOnModal = document.getElementById('areasToWorkOnModal');
  const areasToWorkOnContent = document.getElementById('areasToWorkOnContent');
  const closeAreasToWorkOnModal = document.getElementById('closeAreasToWorkOnModal');
  
  // Track if we've already auto-opened the modal (to avoid showing it multiple times)
  let hasAutoOpenedAreasModal = false;
  
  // Check if button should be shown and fetch/update areas to work on (optimized - single call)
  async function checkAndShowAreasToWorkOnButton(autoOpen = false) {
    if (!areasToWorkOnBtn || questionCount < 5) return;
    
    // Always show the button after 5 questions (stays visible after closing modal)
    areasToWorkOnBtn.style.display = 'block';
    
    // Check if we should regenerate (every 3 questions after 5: at 5, 8, 11, 14, etc.)
    const shouldRegenerate = questionCount === 5 || (questionCount > 5 && (questionCount - 5) % 3 === 0);
    
    // If this is the first time reaching 5 questions and autoOpen is true, open the modal
    if (autoOpen && !hasAutoOpenedAreasModal && areasToWorkOnModal && questionCount === 5) {
      hasAutoOpenedAreasModal = true;
      // Wait a moment for feedback to be fully displayed, then open the modal
      setTimeout(async () => {
        if (areasToWorkOnModal) {
          areasToWorkOnModal.style.display = 'flex';
          await loadAreasToWorkOn();
        }
      }, 1500); // 1.5 second delay to let user see their feedback first
    }
    
    // Regenerate in background if needed (every 3 questions after 5)
    if (shouldRegenerate) {
      generateAreasToWorkOn().catch(err => {
        console.warn('Background generation of areas to work on failed:', err);
      });
    }
  }
  
  // Generate or update areas to work on
  async function generateAreasToWorkOn() {
    try {
      const sessionId = getSessionId();
      const response = await fetch(`${BACKEND_URL}/api/areas-to-work-on`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ sessionId })
      });
      
      if (response.ok) {
        const data = await response.json();
        return data.areasToWorkOn;
      } else {
        throw new Error(`Failed to generate: ${response.status}`);
      }
    } catch (err) {
      console.error('Error generating areas to work on:', err);
      throw err;
    }
  }
  
  // Load and display areas to work on in modal (optimized - single call)
  async function loadAreasToWorkOn() {
    if (!areasToWorkOnContent) return;
    
    // Show loading state
    areasToWorkOnContent.innerHTML = `
      <div style="text-align: center; padding: 40px; color: #94a3b8;">
        <div style="font-size: 2rem; margin-bottom: 12px;">ü§ñ</div>
        <p>Analyzing your recent answers...</p>
        <p style="font-size: 0.9rem; margin-top: 8px;">This may take a moment</p>
      </div>
    `;
    
    try {
      // Single call - generate/regenerate (POST handles both cases)
      const areasToWorkOn = await generateAreasToWorkOn();
      
      // Calculate next update point (every 3 questions after 5: 8, 11, 14, etc.)
      const questionsSinceLastUpdate = questionCount % 3;
      const nextUpdateAt = questionsSinceLastUpdate === 0 ? questionCount + 3 : questionCount + (3 - questionsSinceLastUpdate);
      
      // Display the content
      if (areasToWorkOn) {
        areasToWorkOnContent.innerHTML = `
          <div style="background: rgba(251, 191, 36, 0.1); border-left: 4px solid #fbbf24; padding: 20px; border-radius: 8px; margin-bottom: 16px;">
            <p style="color: #e5e7eb; line-height: 1.8; font-size: 1.05rem; margin: 0; white-space: pre-wrap;">${areasToWorkOn}</p>
          </div>
          <div style="text-align: center; margin-top: 20px; padding-top: 16px; border-top: 1px solid rgba(148, 163, 184, 0.2);">
            <p style="color: #94a3b8; font-size: 0.85rem; margin: 0 0 8px 0;">This feedback is based on your last ${questionCount} answers.</p>
            <p style="color: #fbbf24; font-size: 0.9rem; margin: 0; font-weight: 600;">üîÑ Feedback will update after ${nextUpdateAt - questionCount} more ${nextUpdateAt - questionCount === 1 ? 'question' : 'questions'} (at question #${nextUpdateAt})</p>
          </div>
        `;
      } else {
        areasToWorkOnContent.innerHTML = `
          <div style="text-align: center; padding: 40px; color: #94a3b8;">
            <p>Not enough data yet. Answer a few more questions to get personalized feedback.</p>
          </div>
        `;
      }
    } catch (err) {
      console.error('Error loading areas to work on:', err);
      areasToWorkOnContent.innerHTML = `
        <div style="text-align: center; padding: 40px; color: #fca5a5;">
          <p>Error loading feedback. Please try again.</p>
        </div>
      `;
    }
  }
  
  if (areasToWorkOnBtn) {
    areasToWorkOnBtn.addEventListener('click', async () => {
      if (areasToWorkOnModal) {
        areasToWorkOnModal.style.display = 'flex';
        await loadAreasToWorkOn();
      }
    });
  }
  
  if (closeAreasToWorkOnModal) {
    closeAreasToWorkOnModal.addEventListener('click', () => {
      if (areasToWorkOnModal) areasToWorkOnModal.style.display = 'none';
    });
  }
  
  if (areasToWorkOnModal) {
    areasToWorkOnModal.addEventListener('click', (e) => {
      if (e.target === areasToWorkOnModal) {
        areasToWorkOnModal.style.display = 'none';
      }
    });
  }
  
  // ========== FEEDBACK SYSTEM ==========
  function setupFeedbackSystem() {
    console.log("Setting up feedback system...");
    const feedbackBtn = document.getElementById('feedbackBtn');
    const feedbackModal = document.getElementById('feedbackModal');
    const closeFeedbackModal = document.getElementById('closeFeedbackModal');
    const cancelFeedbackBtn = document.getElementById('cancelFeedbackBtn');
    const feedbackForm = document.getElementById('feedbackForm');
    
    console.log("Feedback elements found:", {
      feedbackBtn: !!feedbackBtn,
      feedbackModal: !!feedbackModal,
      closeFeedbackModal: !!closeFeedbackModal,
      cancelFeedbackBtn: !!cancelFeedbackBtn,
      feedbackForm: !!feedbackForm
    });
    
    if (feedbackBtn) {
      // Remove any existing listeners
      const newBtn = feedbackBtn.cloneNode(true);
      feedbackBtn.parentNode.replaceChild(newBtn, feedbackBtn);
      
      newBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log("Feedback button clicked!");
        const modal = document.getElementById('feedbackModal');
        if (modal) {
          console.log("Showing feedback modal");
          modal.style.display = 'flex';
        } else {
          console.error("Feedback modal not found!");
        }
      });
      
      // Also add inline onclick as backup
      newBtn.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log("Feedback button clicked (onclick)!");
        const modal = document.getElementById('feedbackModal');
        if (modal) {
          modal.style.display = 'flex';
        }
      };
    } else {
      console.error("Feedback button not found in DOM!");
    }
    
    if (closeFeedbackModal) {
      closeFeedbackModal.addEventListener('click', () => {
        const modal = document.getElementById('feedbackModal');
        const form = document.getElementById('feedbackForm');
        if (modal) modal.style.display = 'none';
        if (form) form.reset();
      });
    }
    
    if (cancelFeedbackBtn) {
      cancelFeedbackBtn.addEventListener('click', () => {
        const modal = document.getElementById('feedbackModal');
        const form = document.getElementById('feedbackForm');
        if (modal) modal.style.display = 'none';
        if (form) form.reset();
      });
    }
    
    if (feedbackModal) {
      feedbackModal.addEventListener('click', (e) => {
        if (e.target === feedbackModal) {
          feedbackModal.style.display = 'none';
          if (feedbackForm) feedbackForm.reset();
        }
      });
    }
    
    // Setup slider value updates
    const questionQualitySlider = document.getElementById('feedbackQuestionQuality');
    const aiFeedbackSlider = document.getElementById('feedbackAIFeedback');
    const easeOfUseSlider = document.getElementById('feedbackEaseOfUse');
    const recommendSlider = document.getElementById('feedbackRecommend');
    
    if (questionQualitySlider) {
      questionQualitySlider.addEventListener('input', (e) => {
        document.getElementById('questionQualityValue').textContent = e.target.value;
      });
    }
    if (aiFeedbackSlider) {
      aiFeedbackSlider.addEventListener('input', (e) => {
        document.getElementById('aiFeedbackValue').textContent = e.target.value;
      });
    }
    if (easeOfUseSlider) {
      easeOfUseSlider.addEventListener('input', (e) => {
        document.getElementById('easeOfUseValue').textContent = e.target.value;
      });
    }
    if (recommendSlider) {
      recommendSlider.addEventListener('input', (e) => {
        document.getElementById('recommendValue').textContent = e.target.value;
      });
    }
    
    if (feedbackForm) {
      feedbackForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const satisfaction = document.getElementById('feedbackSatisfaction').value;
      const questionQuality = document.getElementById('feedbackQuestionQuality')?.value || '5';
      const aiFeedback = document.getElementById('feedbackAIFeedback')?.value || '5';
      const easeOfUse = document.getElementById('feedbackEaseOfUse')?.value || '5';
      const recommend = document.getElementById('feedbackRecommend')?.value || '5';
      
      // Get selected items from multi-select dropdowns
      const workingWellSelect = document.getElementById('feedbackWorkingWell');
      const improvementsSelect = document.getElementById('feedbackImprovements');
      const categoriesSelect = document.getElementById('feedbackCategories');
      
      const workingWell = workingWellSelect ? Array.from(workingWellSelect.selectedOptions).map(opt => opt.value) : [];
      const improvements = improvementsSelect ? Array.from(improvementsSelect.selectedOptions).map(opt => opt.value) : [];
      const selectedCategories = categoriesSelect ? Array.from(categoriesSelect.selectedOptions).map(opt => opt.value) : [];
      
      const additional = document.getElementById('feedbackAdditional')?.value.trim() || '';
      
      if (!satisfaction) {
        alert('Please select your overall satisfaction level.');
        return;
      }
      
      // Note: recommend slider validation removed - default value of 5 is acceptable
      
      const submitBtn = feedbackForm.querySelector('button[type="submit"]');
      const originalText = submitBtn.textContent;
      submitBtn.disabled = true;
      submitBtn.textContent = 'Submitting...';
      
      try {
        const response = await fetch(`${BACKEND_URL}/api/feedback`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            sessionId: getSessionId(),
            satisfaction: satisfaction,
            ratings: {
              questionQuality: questionQuality,
              aiFeedback: aiFeedback,
              easeOfUse: easeOfUse,
              recommend: recommend
            },
            workingWell: workingWell,
            improvements: improvements,
            categories: selectedCategories,
            additional: additional,
            timestamp: new Date().toISOString()
          })
        });
        
        if (!response.ok) {
          throw new Error(`Backend error: ${response.status}`);
        }
        
        // Show success message
        const successMsg = document.createElement('div');
        successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #10b981; color: white; padding: 16px 24px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 10004; font-size: 0.95rem; animation: slideIn 0.3s ease;';
        successMsg.textContent = '‚úì Thank you for your feedback!';
        document.body.appendChild(successMsg);
        
        setTimeout(() => {
          successMsg.style.animation = 'slideOut 0.3s ease';
          setTimeout(() => successMsg.remove(), 300);
        }, 3000);
        
        // Close modal and reset form
        if (feedbackModal) feedbackModal.style.display = 'none';
        feedbackForm.reset();
      } catch (error) {
        console.error('Error submitting feedback:', error);
        alert('Failed to submit feedback. Please try again.');
      } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = originalText;
      }
    });
    }
  }
  
  // Initialize feedback system when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupFeedbackSystem);
  } else {
    setupFeedbackSystem();
  }
  
  // Also try after a short delay as backup
  setTimeout(setupFeedbackSystem, 1000);

  async function speakQuestionWithCaptions(text) {
    console.log("speakQuestionWithCaptions called with text:", text ? text.substring(0, 50) + "..." : "NO TEXT");
    
    if (!text || text.trim().length === 0) {
      console.error("speakQuestionWithCaptions: No text provided!");
      return;
    }
    
    // Stop speech recognition while TTS is speaking to prevent mic from picking up the question
    if (recognition && recognizing) {
      console.log("Stopping speech recognition while question is being spoken...");
      try {
        recognizing = false; // Set flag first to prevent auto-restart
        recognition.stop();
      } catch (e) {
        console.warn("Error stopping recognition:", e);
      }
    }
    
    isSpeaking = true; // Mark that TTS is starting
    
    const subtitleEl = document.getElementById("questionSubtitles");
    
    // Show subtitle area (will be updated during speech)
    if (subtitleEl) {
      subtitleEl.style.display = "block";
      // Don't set textContent here - let TTS function update it during speech
    }

    // Use OpenAI TTS if backend is enabled (high quality, natural voice)
    // Always use backend
    {
      console.log("Using backend OpenAI TTS...");
      console.log("BACKEND_URL:", typeof BACKEND_URL !== 'undefined' ? BACKEND_URL : 'NOT DEFINED');
      
      if (typeof BACKEND_URL === 'undefined') {
        console.error("BACKEND_URL is not defined! Falling back to browser TTS");
      } else {
        try {
          await speakWithOpenAITTS(text, subtitleEl);
          console.log("OpenAI TTS completed successfully");
          return;
        } catch (err) {
          console.error("OpenAI TTS error:", err.message || err);
          console.error("OpenAI TTS error details:", err);
          console.log("Falling back to browser TTS");
          // Fall through to browser TTS as fallback
        }
      }
    }
    
    // Fallback to browser TTS
    console.log("Attempting browser TTS fallback...");
    if (!window.speechSynthesis) {
      console.error("Browser TTS (speechSynthesis) not available");
      isSpeaking = false; // Reset flag if TTS not available
      return;
    }
    
    console.log("Using browser TTS fallback");
    window.speechSynthesis.cancel();
    
    // Ensure we have the best voice selected
    let voice = initializeVoice();
    
    // If voice not loaded yet, try to get it from available voices
    if (!voice && window.speechSynthesis) {
      const voices = window.speechSynthesis.getVoices();
      if (voices && voices.length > 0) {
        voice = selectBestVoice(voices);
        selectedVoice = voice; // Cache it
      }
    }
    
    const utterance = new SpeechSynthesisUtterance(text);
    
    // Use the selected voice if available
    if (voice) {
      utterance.voice = voice;
      utterance.lang = voice.lang;
    } else {
      utterance.lang = "en-US";
    }
    
    // Optimized parameters for ChatGPT-like natural, conversational speech
    utterance.rate = 0.88;  // Slightly slower for natural conversation pace
    utterance.pitch = 1.0;  // Neutral pitch (most natural, like ChatGPT)
    utterance.volume = 1.0;  // Full volume
    
    // Word-by-word highlighting for live captions
    const words = text.split(/\s+/);
    let currentWordIndex = 0;
    
    utterance.onboundary = (event) => {
      if (event.name === 'word' && subtitleEl) {
        const spokenWords = words.slice(0, currentWordIndex + 1).join(" ");
        const remainingWords = words.slice(currentWordIndex + 1).join(" ");
        subtitleEl.innerHTML = `<span style="color: #fbbf24;">${spokenWords}</span> <span style="color: #64748b;">${remainingWords}</span>`;
        currentWordIndex++;
      }
    };
    
    utterance.onend = () => {
      isSpeaking = false; // TTS finished
      if (subtitleEl) {
        // Hide subtitle when done - question is already displayed in questionText
        subtitleEl.style.display = "none";
      }
    };
    
    utterance.onerror = (event) => {
      isSpeaking = false; // Reset flag on error
      console.error("TTS error:", event);
    };
    
    window.speechSynthesis.speak(utterance);
  }
  
  // OpenAI TTS function (high quality, natural voice)
  async function speakWithOpenAITTS(text, subtitleEl) {
    console.log("speakWithOpenAITTS called");
    const voice = "alloy"; // Options: alloy, echo, fable, onyx, nova, shimmer
    
    if (!text || text.trim().length === 0) {
      console.error("speakWithOpenAITTS: No text provided!");
      throw new Error("No text provided for TTS");
    }
    
    // Use backend (OpenAI TTS is always via backend)
    try {
      console.log(`Calling backend OpenAI TTS at ${BACKEND_URL}/api/tts`);
      console.log(`Text length: ${text.length} characters`);
      const response = await fetch(`${BACKEND_URL}/api/tts`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ 
          text: text,
          voicePreference: selectedVoicePreference || (typeof onboardingData !== 'undefined' && onboardingData?.voicePreference) || null
        })
      });
      
      console.log(`Backend TTS response status: ${response.status}`);
      
      if (!response.ok) {
        const errorText = await response.text().catch(() => "Could not read error response");
        console.error(`Backend TTS error response: ${errorText}`);
        throw new Error(`Backend TTS failed: ${response.status} - ${errorText}`);
      }
      
      if (response.ok) {
        const audioBlob = await response.blob();
        console.log(`Received audio blob, size: ${audioBlob.size} bytes`);
        
        if (audioBlob.size === 0) {
          throw new Error("Received empty audio blob from backend");
        }
        
        const audioUrl = URL.createObjectURL(audioBlob);
        const audio = new Audio(audioUrl);
        
        // Update subtitle during speech (word-by-word highlighting will happen via audio events)
        if (subtitleEl) {
          subtitleEl.innerHTML = `<span style="color: #fbbf24;">Speaking...</span>`;
        }
        
          return new Promise((resolve, reject) => {
            // Handle user interaction requirement for audio playback
            const playAudio = () => {
              audio.play().then(() => {
                console.log("Audio playback started");
              }).catch(err => {
                console.error("Audio play() error:", err);
                // If autoplay is blocked, show subtitle and resolve (audio will play when user interacts)
                if (err.name === 'NotAllowedError' || err.message.includes('user agent')) {
                  console.warn("Audio autoplay blocked - user interaction required");
                  if (subtitleEl) {
                    subtitleEl.innerHTML = `<span style="color: #fbbf24;">${text}</span><br><small style="color: #94a3b8;">Click anywhere to play audio</small>`;
                  }
                  // Set up click handler to play audio
                  const clickHandler = () => {
                    audio.play().then(() => {
                      document.removeEventListener('click', clickHandler);
                    }).catch(reject);
                  };
                  document.addEventListener('click', clickHandler, { once: true });
                  resolve(); // Resolve immediately so UI doesn't hang
                  return;
                }
                reject(err);
              });
            };
            
            audio.onended = () => {
              isSpeaking = false; // TTS finished
              URL.revokeObjectURL(audioUrl);
              // Hide subtitle when audio ends - question is already displayed in questionText
              if (subtitleEl) {
                subtitleEl.style.display = "none";
              }
              resolve();
            };
            audio.onerror = (e) => {
              isSpeaking = false; // Reset flag on error
              console.error("Audio playback error:", e);
              reject(new Error("Audio playback failed"));
            };
            audio.oncanplaythrough = () => {
              playAudio();
            };
            audio.onloadeddata = () => {
              // Try to play as soon as data is loaded
              if (audio.readyState >= 2) {
                playAudio();
              }
            };
            audio.load();
          });
      } else {
        const errorText = await response.text().catch(() => `Status ${response.status}`);
        console.error(`Backend TTS failed: ${response.status}`, errorText);
        throw new Error(`TTS failed: ${response.status} - ${errorText}`);
      }
    } catch (err) {
      console.error("Backend TTS error:", err);
      console.error("Error message:", err.message);
      throw err; // Re-throw to fall back to browser TTS
    }
  }
  
  // Keep old function for backwards compatibility
  function speakQuestion(text) {
    speakQuestionWithCaptions(text);
  }

  // ========== CAMERA & MOTION TRACKING ==========

  const cameraBtn = document.getElementById("cameraBtn");
  const videoEl = document.getElementById("camera");
  const motionCanvas = document.getElementById("motionCanvas");
  const motionScoreEl = document.getElementById("motionScore");

  cameraBtn.addEventListener("click", async () => {
    if (cameraStream) {
      stopCamera();
      return;
    }
    await startCamera();
  });

  async function startCamera() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      alert("getUserMedia not supported. Try Chrome on https/localhost.");
      return;
    }
    try {
      cameraStream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: false
      });
      videoEl.srcObject = cameraStream;
      cameraBtn.textContent = "‚èπ Stop Camera";

      motionCanvas.width = videoEl.clientWidth || 640;
      motionCanvas.height = videoEl.clientHeight || 480;
      motionCtx = motionCanvas.getContext("2d");

      motionSamples = [];
      lastFrameData = null;
      if (motionIntervalId) clearInterval(motionIntervalId);
      // Increased interval and added smoothing to reduce jitter
      motionIntervalId = setInterval(captureMotionSample, 1000);
    } catch (err) {
      console.error(err);
      alert("Could not access camera. Check permissions.");
    }
  }

  function stopCamera() {
    if (cameraStream) {
      cameraStream.getTracks().forEach((t) => t.stop());
      cameraStream = null;
    }
    videoEl.srcObject = null;
    cameraBtn.textContent = "üì∑ Start Camera";
    if (motionIntervalId) {
      clearInterval(motionIntervalId);
      motionIntervalId = null;
    }
    motionSamples = [];
    lastFrameData = null;
    motionScoreEl.textContent = "‚Äì";
  }

  function captureMotionSample() {
    if (!cameraStream || !motionCtx) return;
    const w = motionCanvas.width;
    const h = motionCanvas.height;
    if (!w || !h) return;

    motionCtx.drawImage(videoEl, 0, 0, w, h);
    const frame = motionCtx.getImageData(0, 0, w, h);

    if (!lastFrameData) {
      lastFrameData = frame;
      return;
    }

    let diffSum = 0;
    const step = 4 * 12; // Increased step size to reduce sensitivity
    for (let i = 0; i < frame.data.length; i += step) {
      const r = frame.data[i];
      const g = frame.data[i + 1];
      const b = frame.data[i + 2];
      const r0 = lastFrameData.data[i];
      const g0 = lastFrameData.data[i + 1];
      const b0 = lastFrameData.data[i + 2];
      const delta = Math.abs(r - r0) + Math.abs(g - g0) + Math.abs(b - b0);
      diffSum += delta;
    }
    const avgDiff = diffSum / (frame.data.length / step);
    motionSamples.push(avgDiff);
    // Keep more samples for better smoothing
    if (motionSamples.length > 60) motionSamples.shift();

    // Smooth the display with exponential moving average
    const recentSamples = motionSamples.slice(-10);
    const smoothedScore = recentSamples.reduce((a, b) => a + b, 0) / recentSamples.length;
    const liveScore = Math.round(smoothedScore);
    motionScoreEl.textContent = liveScore;
    lastFrameData = frame;
  }

  function computeMotionScoreForAnswer() {
    if (!motionSamples.length) return null;
    const avg =
      motionSamples.reduce((a, b) => a + b, 0) / motionSamples.length;
    return avg;
  }

  // ========== SPEECH RECOGNITION ==========

  const startAnswerBtn = document.getElementById("startAnswerBtn");
  const stopAnswerBtn = document.getElementById("stopAnswerBtn");
  const micStatusDot = document.getElementById("micStatusDot");
  const micStatusText = document.getElementById("micStatusText");
  const transcriptBox = document.getElementById("transcriptBox");

  initSpeechRecognition();

  function initSpeechRecognition() {
    const SpeechRecognition =
      window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      transcriptBox.textContent =
        "Speech recognition not supported in this browser. You can still type your answer here manually.";
      transcriptBox.contentEditable = "true";
      return;
    }
    recognition = new SpeechRecognition();
    recognition.continuous = true;
    recognition.interimResults = true;
    recognition.lang = "en-US";

    recognition.onstart = () => {
      recognizing = true;
      micStatusDot.classList.remove("off");
      micStatusText.textContent = "Listening‚Ä¶ answer your question.";
    };
    recognition.onerror = (event) => {
      console.warn("Speech recognition error:", event.error);
      if (event.error === "no-speech") {
        // No speech detected, but keep listening
        return;
      }
      if (event.error === "network") {
        // Network error, try to restart
        if (recognizing) {
          setTimeout(() => {
            if (recognizing) {
              try {
                recognition.start();
              } catch (e) {
                console.error("Failed to restart recognition:", e);
              }
            }
          }, 1000);
        }
      }
    };
    
    recognition.onend = () => {
      // Don't auto-restart if TTS is speaking
      if (isSpeaking) {
        console.log("TTS is speaking, not auto-restarting recognition");
        recognizing = false;
        micStatusDot.classList.add("off");
        micStatusText.textContent = "Mic idle";
        return;
      }
      
      // Auto-restart if we're still supposed to be recording
      if (recognizing && stopAnswerBtn && !stopAnswerBtn.disabled) {
        console.log("Recognition ended, auto-restarting...");
        setTimeout(() => {
          if (recognizing && stopAnswerBtn && !stopAnswerBtn.disabled && !isSpeaking) {
            try {
              recognition.start();
            } catch (e) {
              console.error("Failed to auto-restart recognition:", e);
              recognizing = false;
              micStatusDot.classList.add("off");
              micStatusText.textContent = "Mic idle";
            }
          }
        }, 100);
        return;
      }
      
      // Only stop if user actually stopped
      recognizing = false;
      micStatusDot.classList.add("off");
      micStatusText.textContent = "Mic idle";
    };
    
    recognition.onresult = (event) => {
      let interim = "";
      let newFinal = "";
      
      // Only process NEW results (starting from resultIndex)
      // This prevents duplicating text when recognition restarts
      for (let i = event.resultIndex; i < event.results.length; i++) {
        const res = event.results[i];
        if (res.isFinal) {
          newFinal += res[0].transcript + " ";
        } else {
          interim += res[0].transcript + " ";
        }
      }
      
      // Accumulate: existing final transcript + new final results + interim
      lastAnswerTranscript = (lastAnswerTranscript + " " + newFinal).trim();
      liveTranscriptText = (lastAnswerTranscript + " " + interim).trim();
      
      transcriptBox.textContent = liveTranscriptText;
    };

    transcriptBox.contentEditable = "true";
    
    // Add visual feedback when editing transcript
    const editHint = document.getElementById('transcriptEditHint');
    transcriptBox.addEventListener('focus', () => {
      transcriptBox.style.border = '2px solid #fbbf24';
      transcriptBox.style.background = 'rgba(251, 191, 36, 0.1)';
      if (editHint) editHint.style.display = 'none';
    });
    
    transcriptBox.addEventListener('blur', () => {
      transcriptBox.style.border = '';
      transcriptBox.style.background = '';
      if (editHint && transcriptBox.textContent.trim()) editHint.style.display = 'block';
    });
    
    // Update text color and hide hint when user types
    transcriptBox.addEventListener('input', () => {
      if (transcriptBox.textContent.trim() === '') {
        transcriptBox.style.color = '#94a3b8';
        if (editHint) editHint.style.display = 'block';
      } else {
        transcriptBox.style.color = '#e5e7eb';
        if (editHint) editHint.style.display = 'none';
      }
    });
  }

  // Helper to start answer recording, used by both the button and auto-start from Next Question
  function startAnswerRecording(fromAuto = false) {
    if (!recognition) {
      if (transcriptBox) transcriptBox.focus();
      return;
    }
    if (recognizing) return;
    
    // Don't start recording if TTS is currently speaking
    if (isSpeaking) {
      console.log("TTS is speaking, waiting before starting recording...");
      // Wait a bit and try again
      setTimeout(() => {
        if (!isSpeaking) {
          startAnswerRecording(fromAuto);
        } else {
          // If still speaking, wait a bit more
          setTimeout(() => startAnswerRecording(fromAuto), 500);
        }
      }, 300);
      return;
    }
    
    // Reset transcript tracking
    lastAnswerTranscript = "";
    liveTranscriptText = "";
    if (transcriptBox) transcriptBox.textContent = "";
    motionSamples = [];
    
    // Reset recognition results
    if (recognition.abort) {
      try {
        recognition.abort();
      } catch (e) {
        console.warn("Error aborting recognition before restart:", e);
      }
    }
    
    recognizing = true;
    try {
      recognition.start();
      if (startAnswerBtn) startAnswerBtn.disabled = true;
      if (stopAnswerBtn) stopAnswerBtn.disabled = false;
      if (fromAuto && micStatusText) {
        micStatusText.textContent = "Listening‚Ä¶ wait for the question to finish, then answer in your own words.";
      }
    } catch (e) {
      console.error("Failed to start recognition:", e);
      recognizing = false;
      if (startAnswerBtn) startAnswerBtn.disabled = false;
      if (stopAnswerBtn) stopAnswerBtn.disabled = true;
    }
  }

  startAnswerBtn.addEventListener("click", () => {
    startAnswerRecording(false);
  });

  stopAnswerBtn.addEventListener("click", () => {
    if (!recognition) return;
    
    // Stop recognizing flag first to prevent auto-restart
    recognizing = false;
    
    // Stop recognition
    try {
      recognition.stop();
    } catch (e) {
      console.error("Error stopping recognition:", e);
    }
    
    // Get final transcript
    lastAnswerTranscript = liveTranscriptText || transcriptBox.textContent || "";
    
    // Update UI
    startAnswerBtn.disabled = false;
    stopAnswerBtn.disabled = true;
    micStatusDot.classList.add("off");
    micStatusText.textContent = "Mic idle";
    
    // Compute motion score
    motionScoreForAnswer = computeMotionScoreForAnswer();
    
    console.log("Recording stopped. Final transcript length:", lastAnswerTranscript.length, "words:", lastAnswerTranscript.split(/\s+/).length);
    
    // Automatically trigger analysis
    if (lastAnswerTranscript.trim()) {
      // Small delay to ensure transcript is finalized
      setTimeout(() => {
        triggerAnalysis();
      }, 500);
    }
  });

  // ========== FEEDBACK & ANALYSIS ==========

  const analyzeBtn = document.getElementById("analyzeBtn");
  const contentScoreEl = document.getElementById("contentScore");
  const voiceScoreEl = document.getElementById("voiceScore");
  const bodyScoreEl = document.getElementById("bodyScore");
  const contentFeedbackEl = document.getElementById("contentFeedback");
  const voiceFeedbackEl = document.getElementById("voiceFeedback");
  const bodyFeedbackEl = document.getElementById("bodyFeedback");
  const fireTipsEl = document.getElementById("fireTips");

  // Extract analysis logic into a reusable function
  async function triggerAnalysis() {
    const text = (transcriptBox.textContent || "").trim();
    if (!text) {
      alert("No transcript found. Answer the question or type your answer first.");
      return;
    }
    
    // Check credits before analysis
    if (!canUseQuestion()) {
      showPaywallIfNeeded();
      return;
    }
    
    lastAnswerTranscript = text;

    // Add to conversation history
    if (currentQuestion) {
      conversationHistory.push({
        question: currentQuestion.template,
        category: currentQuestion.category,
        answer: text,
        timestamp: Date.now()
      });
    }

    // ----- Local (instant) scoring -----
    const content = analyzeContent(text);
    const voice = analyzeVoice(text);
    const body = analyzeBody(motionScoreForAnswer);
    const tips = buildFireTips(content, voice, body);

    applyScoreToPill(contentScoreEl, content.score);
    applyScoreToPill(voiceScoreEl, voice.score);
    applyScoreToPill(bodyScoreEl, body.score);

    contentFeedbackEl.textContent = content.feedback;
    voiceFeedbackEl.textContent = voice.feedback;
    bodyFeedbackEl.textContent = body.feedback;
    fireTipsEl.textContent = tips;

    // ====== POPUP + AI LOADING BAR ======
    if (analyzeBtn) {
      analyzeBtn.disabled = true;
      analyzeBtn.textContent = APP_CONFIG ? APP_CONFIG.status.analyzing : "ü§ñ Analyzing with AI...";
    }

    // Open the AI modal immediately
    openAIModal();

    // Build loading UI inside the modal
    const modalContentEl = document.getElementById("aiModalContent");
    if (modalContentEl) {
      modalContentEl.innerHTML = `
        <div style="margin-bottom: 12px; font-size: 0.9rem; color: #e5e7eb;">
          Analyzing your answer and body language. This can take a few seconds...
        </div>
        <div style="margin-bottom: 8px; display:flex; justify-content:space-between; align-items:center;">
          <span style="font-size: 0.85rem; color:#cbd5e1;">Contacting AI Interview Coach</span>
          <span id="aiModalProgressPercent" style="font-size:0.85rem; color:#f97316; font-weight:600;">0%</span>
        </div>
        <div style="width:100%; height:8px; background:#111827; border-radius:999px; overflow:hidden;">
          <div id="aiModalProgressBar" style="width:0%; height:100%; background:linear-gradient(90deg,#f97316,#ef4444); transition:width 0.2s;"></div>
        </div>
      `;
    }

    const progressBar = document.getElementById("aiModalProgressBar");
    const progressPercent = document.getElementById("aiModalProgressPercent");
    let progress = 0;
    const progressInterval = setInterval(() => {
      progress += Math.random() * 15;
      if (progress > 90) progress = 90;
      if (progressBar) progressBar.style.width = progress + "%";
      if (progressPercent) progressPercent.textContent = Math.round(progress) + "%";
    }, 200);

    try {
      const response = await authenticatedFetch(`${BACKEND_URL}/api/analyze-answer`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          question: currentQuestion ? currentQuestion.template : "Unknown",
          answer: text,
          motionScore: motionScoreForAnswer,
          resumeAnalysis: resumeAnalysis,
          resumeText: resumeText,
          conversationHistory: conversationHistory,
          cityResearch: onboardingData?.cityResearch || null,
          category: currentQuestion?.category || null,
          sessionId: getSessionId(),
          questionCount: questionCount,
          trialCreditsRemaining: currentUser ? null : getTrialCreditsRemaining()
        }),
        credentials: 'include'
      });

      if (!response.ok) {
        if (response.status === 402) {
          // No credits
          const errorData = await response.json();
          clearInterval(progressInterval);
          if (modalContentEl) {
            modalContentEl.innerHTML = `
              <p style="color:#fecaca; margin-bottom:8px;">${errorData.message || 'No credits remaining'}</p>
              <button class="primary" onclick="showPaywallIfNeeded()" style="margin-top: 12px; padding: 8px 16px;">Buy Credits</button>
            `;
          }
          return;
        }
        throw new Error(`Backend error: ${response.status}`);
      }

      const data = await response.json();
      const aiFeedback = data.feedback;
      const hasDetailedFeedback = data.hasDetailedFeedback || false;
      const isTrialUser = data.isTrialUser || false;
      
      // Consume trial credit if this was a trial use
      if (isTrialUser && !currentUser) {
        consumeTrialCredit();
      }
      
      // Update credits display if paid user
      if (currentUser && data.creditsRemaining !== null) {
        currentUser.credits_balance = data.creditsRemaining;
        await updateCreditsDisplay();
      }

      // Finish progress bar
      clearInterval(progressInterval);
      if (progressBar) progressBar.style.width = "100%";
      if (progressPercent) progressPercent.textContent = "100%";

      if (aiFeedback) {
        // Small preview in right-hand card
        formatAIFeedback(fireTipsEl, aiFeedback, true);
        // Full formatted feedback into the modal (pass hasDetailedFeedback)
        formatAIFeedbackForModal(aiFeedback, hasDetailedFeedback);

        const viewBtn = document.getElementById("viewAIFeedbackBtn");
        if (viewBtn) {
          viewBtn.style.display = "block";
        }

        addFollowupButton();
        
        // Show "Practice Insights" button after 5 questions
        if (questionCount >= 5) {
          // Auto-open modal only after receiving feedback for the 5th question (not before)
          const shouldAutoOpen = questionCount === 5 && !hasAutoOpenedAreasModal;
          checkAndShowAreasToWorkOnButton(shouldAutoOpen);
        }
      } else if (modalContentEl) {
        modalContentEl.innerHTML = `
          <p style="color:#fecaca;">AI didn't return any feedback. Please try again.</p>
        `;
      }
    } catch (err) {
      console.error("Backend analysis error:", err);
      clearInterval(progressInterval);
      if (modalContentEl) {
        modalContentEl.innerHTML = `
          <p style="color:#fecaca; margin-bottom:4px;">AI analysis failed.</p>
          <p style="color:#9ca3af; font-size:0.85rem;">Check your connection and try again.</p>
        `;
      }
    } finally {
      if (analyzeBtn) {
        analyzeBtn.disabled = false;
        analyzeBtn.textContent = "ü§ñ Analyze Answer";
      }
    }
  }

  
  // Note: The analyze button is now hidden/removed from UI, but we keep the function for auto-triggering

  // Format AI feedback with proper HTML structure (for small preview)
  function formatAIFeedback(container, text, showPreview = false) {
    container.innerHTML = ""; // Clear existing content
    
    if (showPreview) {
      // Show just a brief preview in the small box - clean up markdown
      let preview = text
        .replace(/##\s+/g, '') // Remove headings
        .replace(/\*\*/g, '') // Remove bold markers
        .replace(/-\s+/g, '') // Remove bullet points
        .replace(/\s+/g, ' ') // Normalize whitespace
        .trim();
      
      // Get first meaningful sentence
      const sentences = preview.split(/[.!?]/).filter(s => s.trim().length > 10);
      preview = sentences[0] || preview;
      
      if (preview.length > 150) {
        preview = preview.slice(0, 147) + "...";
      }
      
      container.textContent = preview;
      container.style.cssText = "font-size: 0.75rem; color: #9ca3af; margin: 0; line-height: 1.4;";
    } else {
      // Full formatting for modal
      formatAIFeedbackForModal(text);
    }
  }
  
  // Format AI feedback for the modal (wide, readable format)
  function formatAIFeedbackForModal(text, hasDetailedFeedback = true) {
    const modalContent = document.getElementById("aiModalContent");
    if (!modalContent) return;
    
    // Check if this is a trial user without detailed feedback access
    const isTrialWithoutAccess = !hasDetailedFeedback;
    
    // Helper function to convert markdown bold (**text**) to HTML bold
    function convertMarkdownBold(str) {
      if (!str) return '';
      // First, handle patterns like "Label:**" or "**Label:**" - convert label to bold
      str = str.replace(/(\*\*)?([^*:]+?)(\*\*)?:\s*/g, '<strong>$2:</strong> ');
      // Then replace remaining **text** with <strong>text</strong>
      str = str.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
      // Clean up any remaining standalone asterisks that weren't part of pairs
      str = str.replace(/\*\*/g, '');
      return str;
    }
    
    // Clean up text - remove trailing dashes, extra spaces, incomplete formatting
    function cleanText(str) {
      return str
        .replace(/\s*-\s*$/, '') // Remove trailing dashes
        .replace(/\s+/g, ' ') // Normalize whitespace
        .trim();
    }
    
    // Parse markdown-style formatting
    const lines = text.split("\n");
    let html = "";
    let inList = false;
    let inPremiumSection = false;
    let inBlurredContentSection = false; // Track sections where only content should be blurred
    
    lines.forEach((line, index) => {
      const trimmed = line.trim();
      
      // Skip empty lines at the start
      if (trimmed.length === 0 && html === "") {
        return;
      }
      
      // Main sections (##) - clean up title
      if (trimmed.startsWith("## ")) {
        if (inList) {
          html += "</div>"; // Close list if open
          inList = false;
        }
        let sectionTitle = trimmed.substring(3).trim();
        sectionTitle = cleanText(sectionTitle); // Remove trailing dashes
        
        // Check if this is the premium section that should be fully blurred for trial users
        const isPremiumSection = sectionTitle.toLowerCase().includes('panel-ready') || 
                                 sectionTitle.toLowerCase().includes('panel ready') ||
                                 sectionTitle.toLowerCase().includes('detailed');
        
        // Check if this is a section where only content should be blurred (not the title)
        const isBlurredContentSection = isTrialWithoutAccess && (
          sectionTitle.toLowerCase().includes('what to improve') ||
          sectionTitle.toLowerCase().includes('star or approach') ||
          sectionTitle.toLowerCase().includes('approach overview')
        );
        
        if (isPremiumSection && isTrialWithoutAccess) {
          // Start premium locked section (fully blurred)
          inPremiumSection = true;
          inBlurredContentSection = false;
          html += `<div id="premiumSection" style="position: relative; margin-top: ${html ? '24px' : '0'}; margin-bottom: 12px; padding: 16px; background: rgba(15, 23, 42, 0.5); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 8px;">`;
          html += `<h4 style="margin: 0 0 12px 0; color: #fbbf24; font-size: 1.1rem; font-weight: 600; display: flex; align-items: center; gap: 8px;">
            <span>üîí</span>
            <span>${convertMarkdownBold(sectionTitle)}</span>
          </h4>`;
          html += `<div style="filter: blur(8px); pointer-events: none; user-select: none; opacity: 0.5;">`;
        } else if (isBlurredContentSection) {
          // Start section where only content is blurred (title visible)
          inBlurredContentSection = true;
          inPremiumSection = false;
          // Close premium section if we were in one
          if (inPremiumSection) {
            html += `</div></div>`;
            inPremiumSection = false;
          }
          html += `<h4 style="margin-top: ${html ? '24px' : '0'}; margin-bottom: 12px; color: #fbbf24; font-size: 1.1rem; font-weight: 600; display: flex; align-items: center; gap: 8px;">
            <span>üîí</span>
            <span>${convertMarkdownBold(sectionTitle)}</span>
          </h4>`;
        } else {
          // Close premium section if we were in one
          if (inPremiumSection) {
            html += `</div></div>`;
            inPremiumSection = false;
          }
          inBlurredContentSection = false;
          html += `<h4 style="margin-top: ${html ? '24px' : '0'}; margin-bottom: 12px; color: #fbbf24; font-size: 1.1rem; font-weight: 600;">${convertMarkdownBold(sectionTitle)}</h4>`;
        }
      }
      // Bullet points
      else if (trimmed.startsWith("- ") || trimmed.startsWith("* ")) {
        if (!inList) {
          html += '<div style="margin-left: 0; margin-bottom: 8px;">';
          inList = true;
        }
        let content = trimmed.substring(2).trim();
        content = cleanText(content);
        
        // For blurred content sections, blur only the content after the label
        if (inBlurredContentSection) {
          // Check if it matches pattern like "**Focus 1:** text" or "Focus 1:** text"
          const labelMatch = content.match(/^(\*\*)?([^*:]+?)(\*\*)?:\s*(.*)/);
          if (labelMatch && labelMatch.length >= 5) {
            const label = labelMatch[2].trim();
            const value = labelMatch[4] ? labelMatch[4].trim() : '';
            html += `<div class="bullet-point" style="margin-bottom: 6px; line-height: 1.6;">
              ‚Ä¢ <strong style="color: #fbbf24;">${label}:</strong> 
              <span style="filter: blur(8px); pointer-events: none; user-select: none; opacity: 0.5; display: inline-block;">${convertMarkdownBold(value)}</span>
            </div>`;
          } else {
            // If no label pattern, blur the entire content
            html += `<div class="bullet-point" style="margin-bottom: 6px; line-height: 1.6;">
              ‚Ä¢ <span style="filter: blur(8px); pointer-events: none; user-select: none; opacity: 0.5; display: inline-block;">${convertMarkdownBold(content)}</span>
            </div>`;
          }
        } else {
          // Content is already inside blur div if inPremiumSection is true
          html += `<div class="bullet-point" style="margin-bottom: 6px; line-height: 1.6;">‚Ä¢ ${convertMarkdownBold(content)}</div>`;
        }
      }
      // Regular paragraphs
      else if (trimmed.length > 0) {
        if (inList) {
          html += "</div>";
          inList = false;
        }
        
        let content = cleanText(trimmed);
        
        // Skip incomplete lines (like "**Correctne..." that got cut off)
        if (content.endsWith('...') && content.length < 20) {
          return; // Skip incomplete text
        }
        
        // Check if it's a score line
        if (content.match(/^\d+\/10/)) {
          // Content is already inside blur div if inPremiumSection is true
          html += `<div class="score-highlight" style="margin: 8px 0; padding: 8px; background: rgba(251, 191, 36, 0.1); border-left: 3px solid #fbbf24; border-radius: 4px;">${convertMarkdownBold(content)}</div>`;
        } 
        // Check if it's a label-value pair (like "**Summary:** text" or "Summary:** text")
        else if (content.match(/^(\*\*)?[^*:]+\*\*:/) || content.match(/^[^*:]+\*\*:/)) {
          // Split label and value - handle both "**Label:**" and "Label:**" formats
          const parts = content.match(/^(\*\*)?([^*:]+?)(\*\*)?:\s*(.*)/);
          if (parts && parts.length >= 5) {
            const label = parts[2].trim();
            const value = parts[4] ? parts[4].trim() : '';
            
            // For blurred content sections, blur only the value (content after label)
            if (inBlurredContentSection) {
              html += `<div style="margin-bottom: 8px; line-height: 1.6;">
                <strong style="color: #fbbf24;">${label}:</strong> 
                <span style="filter: blur(8px); pointer-events: none; user-select: none; opacity: 0.5; display: inline-block;">${convertMarkdownBold(value)}</span>
              </div>`;
            } else {
              // Content is already inside blur div if inPremiumSection is true
              html += `<div style="margin-bottom: 8px; line-height: 1.6;">
                <strong style="color: #fbbf24;">${label}:</strong> 
                <span style="color: #e5e7eb;">${convertMarkdownBold(value)}</span>
              </div>`;
            }
          } else {
            html += `<div style="margin-bottom: 8px; line-height: 1.6;">${convertMarkdownBold(content)}</div>`;
          }
        }
        else {
          // Content is already inside blur div if inPremiumSection is true
          html += `<div style="margin-bottom: 8px; line-height: 1.6; color: #e5e7eb;">${convertMarkdownBold(content)}</div>`;
        }
      }
      // Empty lines - only add spacing if we have content
      else if (html.length > 0) {
        if (inList) {
          html += "</div>";
          inList = false;
        }
        // Add spacing between sections
        if (index < lines.length - 1 && lines[index + 1]?.trim().startsWith('##')) {
          html += '<div style="margin-bottom: 16px;"></div>';
        }
      }
    });
    
    // Close any open list
    if (inList) {
      html += "</div>";
    }
    
    // Close premium section if it was opened
    if (inPremiumSection) {
      html += `</div></div>`; // Close blur div and premium section div
      html += `<div style="margin-top: 16px; padding: 16px; background: rgba(251, 191, 36, 0.1); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 8px; text-align: center;">
        <p style="color: #fbbf24; margin: 0 0 8px 0; font-weight: 600;">Full panel ready answer & detailed coaching are available after upgrading.</p>
        <button class="primary" onclick="window.showCreditPurchaseModal()" style="padding: 8px 16px; margin-top: 8px;">Buy Credits to Unlock</button>
      </div>`;
    }
    
    // Add unlock message after blurred content sections
    if (inBlurredContentSection && isTrialWithoutAccess) {
      html += `<div style="margin-top: 16px; padding: 16px; background: rgba(251, 191, 36, 0.1); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 8px; text-align: center;">
        <p style="color: #fbbf24; margin: 0 0 8px 0; font-weight: 600;">Detailed feedback is available after upgrading.</p>
        <button class="primary" onclick="window.showCreditPurchaseModal()" style="padding: 8px 16px; margin-top: 8px;">Buy Credits to Unlock</button>
      </div>`;
    }
    
    modalContent.innerHTML = html || '<p style="color: #94a3b8;">No feedback available.</p>';
  }
  
  // Modal functionality
  const aiModalOverlay = document.getElementById("aiModalOverlay");
  const closeAIModalBtn = document.getElementById("closeAIModal");
  const viewAIFeedbackBtn = document.getElementById("viewAIFeedbackBtn");
  
  function openAIModal() {
    const modal = document.getElementById("aiModalOverlay");
    if (modal) {
      modal.classList.add("active");
      modal.style.display = "flex"; // Force display
      document.body.style.overflow = "hidden"; // Prevent background scrolling
      console.log("AI Modal opened - display set to flex");
    } else {
      console.error("aiModalOverlay element not found!");
    }
  }
  
  function closeAIModal() {
    if (aiModalOverlay) {
      aiModalOverlay.classList.remove("active");
      document.body.style.overflow = ""; // Restore scrolling
    }
  }
  
  if (closeAIModalBtn) {
    closeAIModalBtn.addEventListener("click", closeAIModal);
  }
  
  if (viewAIFeedbackBtn) {
    viewAIFeedbackBtn.addEventListener("click", openAIModal);
  }
  
  // Close modal when clicking outside
  if (aiModalOverlay) {
    aiModalOverlay.addEventListener("click", (e) => {
      if (e.target === aiModalOverlay) {
        closeAIModal();
      }
    });
  }
  
  // Close modal with Escape key
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && aiModalOverlay && aiModalOverlay.classList.contains("active")) {
      closeAIModal();
    }
  });
  
  // Add followup button near question area
  function addFollowupButton() {
    // Remove existing followup button if any
    const existingBtn = document.getElementById("followupQuestionBtn");
    if (existingBtn) existingBtn.remove();
    
    const followupBtn = document.createElement("button");
    followupBtn.id = "followupQuestionBtn";
    followupBtn.textContent = "üí¨ Ask Followup Question";
    followupBtn.style.cssText = "margin-top: 12px; padding: 12px 20px; border-radius: 8px; border: none; background: #ef4444; color: #fff; cursor: pointer; font-size: 0.95rem; font-weight: 600; width: 100%; transition: background 0.2s;";
    followupBtn.onmouseover = () => followupBtn.style.background = "#dc2626";
    followupBtn.onmouseout = () => followupBtn.style.background = "#ef4444";
    
      followupBtn.onclick = async () => {
      followupBtn.disabled = true;
      followupBtn.textContent = "ü§ñ Generating followup...";
      try {
        currentQuestion = await generateFollowupQuestion();
        questionCount++;
        isFollowupQuestion = true; // Ensure flag is set
        updateNextQuestionButtonText();
        renderQuestion(currentQuestion);
        speakQuestionWithCaptions(currentQuestion.template);
        followupBtn.remove();
      } catch (err) {
        console.error("Followup generation error:", err);
        followupBtn.textContent = "Error generating followup";
        followupBtn.disabled = false;
      }
    };
    
    // Insert into the dedicated container
    const container = document.getElementById("followupButtonContainer");
    if (container) {
      container.innerHTML = "";
      container.appendChild(followupBtn);
    } else {
      // Fallback: add after question meta
      const questionMeta = document.querySelector(".question-meta");
      if (questionMeta && questionMeta.parentNode) {
        questionMeta.parentNode.insertBefore(followupBtn, questionMeta.nextSibling);
      }
    }
  }

  function analyzeContent(text) {
    const words = text.split(/\s+/).filter(Boolean);
    const length = words.length;

    const structureKeywords = [
      "situation",
      "call",
      "scene",
      "task",
      "problem",
      "action",
      "then",
      "after",
      "result",
      "outcome",
      "learned"
    ];
    const lower = text.toLowerCase();
    let structureHits = 0;
    structureKeywords.forEach((k) => {
      if (lower.includes(k)) structureHits++;
    });

    let keywordHits = 0;
    const allKeywords = new Set([
      ...firefighterKeywords.map((k) => k.toLowerCase()),
      ...resumeKeywords.map((k) => k.word.toLowerCase())
    ]);
    allKeywords.forEach((k) => {
      const regex = new RegExp("\\b" + escapeRegExp(k) + "\\b", "g");
      const matches = lower.match(regex);
      if (matches) keywordHits += matches.length;
    });

    let score = 0;
    if (length >= 80 && length <= 250) score += 3;
    else if (length >= 50 && length < 80) score += 2;
    else if (length < 50) score += 1;

    if (structureHits >= 6) score += 3;
    else if (structureHits >= 3) score += 2;
    else if (structureHits >= 1) score += 1;

    if (keywordHits >= 5) score += 3;
    else if (keywordHits >= 2) score += 2;
    else if (keywordHits >= 1) score += 1;

    const feedbackParts = [];
    feedbackParts.push(
      `Length: about ${length} words. Target 90‚Äì180 words for most panel answers.`
    );
    if (structureHits >= 6) {
      feedbackParts.push(
        "You naturally walked through the situation, actions, and outcome. Structure was clear."
      );
    } else if (structureHits >= 3) {
      feedbackParts.push(
        "Structure was decent but you could sharpen it with a clear beginning (call setup), middle (actions), and end (results/learning)."
      );
    } else {
      feedbackParts.push(
        "Try using a clear flow: brief scene setup ‚Üí what you did ‚Üí what happened ‚Üí what you learned."
      );
    }

    if (keywordHits >= 5) {
      feedbackParts.push(
        "You tied in strong role-specific details (gear, EMR, training, teamwork) which panels like to hear."
      );
    } else if (keywordHits >= 2) {
      feedbackParts.push(
        "You referenced some relevant experience. You could still anchor more to firefighter tasks and your resume (EMR, call types, training)."
      );
    } else {
      feedbackParts.push(
        "You kept things very general. Link the story directly to fire/medical or physical/crew work you actually do."
      );
    }

    return {
      score,
      feedback: feedbackParts.join(" ")
    };
  }

  function analyzeVoice(text) {
    const lower = text.toLowerCase();
    const fillerWords = ["um", "uh", "like", "you know", "sort of", "kind of"];
    let fillerCount = 0;
    fillerWords.forEach((w) => {
      const regex = new RegExp("\\b" + escapeRegExp(w) + "\\b", "g");
      const matches = lower.match(regex);
      if (matches) fillerCount += matches.length;
    });

    const sentences = text.split(/[.!?]+/).filter(Boolean);
    const avgSentenceLength = sentences.length
      ? text.split(/\s+/).filter(Boolean).length / sentences.length
      : 0;

    let score = 0;
    if (fillerCount === 0) score += 4;
    else if (fillerCount <= 2) score += 3;
    else if (fillerCount <= 5) score += 2;
    else score += 1;

    if (avgSentenceLength > 8 && avgSentenceLength < 25) score += 3;
    else if (avgSentenceLength >= 5 && avgSentenceLength <= 30) score += 2;
    else score += 1;

    const feedbackParts = [];
    if (fillerCount === 0) {
      feedbackParts.push("Nice work‚Äîno obvious filler words detected.");
    } else {
      feedbackParts.push(
        `Detected about ${fillerCount} filler words (e.g., ‚Äúum‚Äù, ‚Äúlike‚Äù). Try pausing silently instead of filling space.`
      );
    }

    if (avgSentenceLength > 8 && avgSentenceLength < 25) {
      feedbackParts.push("Your sentences are a good length‚Äîclear but not choppy.");
    } else if (avgSentenceLength <= 8) {
      feedbackParts.push(
        "Some sentences are very short. You may sound choppy; try linking ideas together slightly more."
      );
    } else {
      feedbackParts.push(
        "Some sentences are quite long. Break them up so the panel can follow key points."
      );
    }

    return {
      score,
      fillerCount,
      feedback: feedbackParts.join(" ")
    };
  }

  function analyzeBody(motionScore) {
    if (motionScore == null || isNaN(motionScore)) {
      return {
        score: 2,
        feedback:
          "Camera motion data wasn‚Äôt available for this answer. Make sure your camera is running before you start speaking."
      };
    }

    let score;
    let label;
    if (motionScore < 12) {
      score = 4;
      label = "Very steady ‚Äì little extra movement visible.";
    } else if (motionScore < 25) {
      score = 3;
      label = "Moderate, natural movement ‚Äì likely fine for a real panel.";
    } else if (motionScore < 50) {
      score = 2;
      label = "Noticeable movement ‚Äì may read as a bit fidgety or restless.";
    } else {
      score = 1;
      label =
        "High movement ‚Äì could distract from your answer. Practice keeping your posture steady.";
    }

    return {
      score,
      feedback: `${label} (motion score ‚âà ${motionScore.toFixed(0)} on this answer).`
    };
  }

  function buildFireTips(content, voice, body) {
    const tips = [];

    if (content.score < 7) {
      tips.push(
        "Practice giving answers in a clear fire-call flow: what the call was, what you saw, what you did, how it ended, and what you learned."
      );
    }

    if (voice.fillerCount && voice.fillerCount > 2) {
      tips.push(
        "Try mock answers where you deliberately pause for one full breath before speaking. That pause cuts out a lot of ‚Äúums‚Äù."
      );
    }

    if (body.score < 3) {
      tips.push(
        "Set the camera at eye level, plant your feet, and keep your hands rested on the table or in your lap between gestures."
      );
    }

    if (tips.length === 0) {
      tips.push(
        "This answer is close to panel-ready. Next step: practice 3‚Äì5 questions in a row so you build stamina and consistency."
      );
    }

    return tips.join(" ");
  }

  function applyScoreToPill(el, score) {
    el.classList.remove("low", "mid");
    if (score >= 7) {
      el.textContent = `${score}/10`;
    } else if (score >= 5) {
      el.textContent = `${score}/10`;
      el.classList.add("mid");
    } else {
      el.textContent = `${score}/10`;
      el.classList.add("low");
    }
  }

  function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
</script>

<!-- Feedback Button (Fixed at bottom) -->
<button id="feedbackBtn" onclick="document.getElementById('feedbackModal').style.display='flex'; console.log('Feedback button clicked (inline)');" style="position: fixed; bottom: 20px; right: 20px; background: linear-gradient(135deg, rgba(239, 68, 68, 0.9) 0%, rgba(220, 38, 38, 0.9) 100%); color: white; border: none; border-radius: 50px; padding: 12px 24px; font-size: 0.9rem; font-weight: 600; cursor: pointer; box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4); z-index: 9999; transition: all 0.3s; display: flex; align-items: center; gap: 8px;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 6px 16px rgba(239, 68, 68, 0.6)'" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 12px rgba(239, 68, 68, 0.4)'">
  üí¨ Feedback
</button>

<!-- Feedback Modal -->
<div id="feedbackModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 10003; display: none; align-items: center; justify-content: center; padding: 20px; backdrop-filter: blur(5px);">
  <div style="background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.98) 100%); border: 2px solid rgba(239, 68, 68, 0.3); border-radius: 16px; padding: 32px; max-width: 600px; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(239, 68, 68, 0.3);">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
      <h2 style="color: #ef4444; font-size: 1.5em; margin: 0;">üí¨ Share Your Feedback</h2>
      <button id="closeFeedbackModal" style="background: transparent; border: none; color: #cbd5e1; font-size: 1.5rem; cursor: pointer; padding: 4px 8px; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(239, 68, 68, 0.2)'" onmouseout="this.style.background='transparent'">√ó</button>
    </div>
    
    <form id="feedbackForm" style="display: flex; flex-direction: column; gap: 20px;">
      <!-- Overall Satisfaction -->
      <div>
        <label style="display: block; margin-bottom: 8px; color: #e2e8f0; font-size: 0.9rem; font-weight: 600;">Overall Satisfaction *</label>
        <select id="feedbackSatisfaction" required style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid rgba(148, 163, 184, 0.3); background: #1e293b; color: #fff; font-size: 1rem; cursor: pointer;">
          <option value="">Select your satisfaction level</option>
          <option value="very-satisfied">üòä Very Satisfied</option>
          <option value="satisfied">üôÇ Satisfied</option>
          <option value="neutral">üòê Neutral</option>
          <option value="dissatisfied">üòï Dissatisfied</option>
          <option value="very-dissatisfied">üòû Very Dissatisfied</option>
        </select>
      </div>
      
      <!-- Rating Sliders -->
      <div>
        <label style="display: block; margin-bottom: 12px; color: #e2e8f0; font-size: 0.9rem; font-weight: 600;">Rate Your Experience</label>
        <div style="display: flex; flex-direction: column; gap: 16px;">
          <!-- Question Quality -->
          <div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
              <span style="color: #cbd5e1; font-size: 0.85rem;">Question Quality</span>
              <span id="questionQualityValue" style="color: #fbbf24; font-size: 0.85rem; font-weight: 600;">5</span>
            </div>
            <input type="range" id="feedbackQuestionQuality" min="1" max="10" value="5" step="1">
            <div style="display: flex; justify-content: space-between; margin-top: 4px;">
              <span style="color: #64748b; font-size: 0.7rem;">Poor</span>
              <span style="color: #64748b; font-size: 0.7rem;">Excellent</span>
            </div>
          </div>
          
          <!-- AI Feedback Quality -->
          <div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
              <span style="color: #cbd5e1; font-size: 0.85rem;">AI Feedback Quality</span>
              <span id="aiFeedbackValue" style="color: #fbbf24; font-size: 0.85rem; font-weight: 600;">5</span>
            </div>
            <input type="range" id="feedbackAIFeedback" min="1" max="10" value="5" step="1">
            <div style="display: flex; justify-content: space-between; margin-top: 4px;">
              <span style="color: #64748b; font-size: 0.7rem;">Poor</span>
              <span style="color: #64748b; font-size: 0.7rem;">Excellent</span>
            </div>
          </div>
          
          <!-- Ease of Use -->
          <div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
              <span style="color: #cbd5e1; font-size: 0.85rem;">Ease of Use</span>
              <span id="easeOfUseValue" style="color: #fbbf24; font-size: 0.85rem; font-weight: 600;">5</span>
            </div>
            <input type="range" id="feedbackEaseOfUse" min="1" max="10" value="5" step="1">
            <div style="display: flex; justify-content: space-between; margin-top: 4px;">
              <span style="color: #64748b; font-size: 0.7rem;">Difficult</span>
              <span style="color: #64748b; font-size: 0.7rem;">Very Easy</span>
            </div>
          </div>
        </div>
      </div>
      
      <!-- What's Working Well - Quick Select -->
      <div>
        <label style="display: block; margin-bottom: 8px; color: #e2e8f0; font-size: 0.9rem; font-weight: 600;">What's working well? (select all that apply)</label>
        <select id="feedbackWorkingWell" multiple style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid rgba(148, 163, 184, 0.3); background: #1e293b; color: #fff; font-size: 0.95rem; cursor: pointer; min-height: 120px;">
          <option value="good-questions">Great question variety</option>
          <option value="ai-feedback">Helpful AI feedback</option>
          <option value="easy-to-use">Easy to use</option>
          <option value="resume-integration">Resume integration works well</option>
          <option value="voice-recognition">Voice recognition is accurate</option>
          <option value="mobile-friendly">Works well on mobile</option>
          <option value="fast-loading">Fast and responsive</option>
          <option value="helpful-tips">Helpful tips and suggestions</option>
        </select>
        <small style="color: #94a3b8; font-size: 0.75rem; margin-top: 4px; display: block;">Hold Ctrl/Cmd to select multiple</small>
      </div>
      
      <!-- What Could Be Improved - Quick Select -->
      <div>
        <label style="display: block; margin-bottom: 8px; color: #e2e8f0; font-size: 0.9rem; font-weight: 600;">What could be improved? (select all that apply)</label>
        <select id="feedbackImprovements" multiple style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid rgba(148, 163, 184, 0.3); background: #1e293b; color: #fff; font-size: 0.95rem; cursor: pointer; min-height: 120px;">
          <option value="more-questions">Need more question variety</option>
          <option value="better-feedback">AI feedback could be better</option>
          <option value="harder-to-use">Interface is confusing</option>
          <option value="slow-loading">Too slow or laggy</option>
          <option value="voice-issues">Voice recognition problems</option>
          <option value="mobile-issues">Mobile experience needs work</option>
          <option value="missing-features">Missing important features</option>
          <option value="buggy">Experiencing bugs or errors</option>
        </select>
        <small style="color: #94a3b8; font-size: 0.75rem; margin-top: 4px; display: block;">Hold Ctrl/Cmd to select multiple</small>
      </div>
      
      <!-- Categories They'd Like to See - Dropdown -->
      <div>
        <label style="display: block; margin-bottom: 8px; color: #e2e8f0; font-size: 0.9rem; font-weight: 600;">Categories you'd like to see more of:</label>
        <select id="feedbackCategories" multiple style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid rgba(148, 163, 184, 0.3); background: #1e293b; color: #fff; font-size: 0.95rem; cursor: pointer; min-height: 150px;">
          <option value="More Situational Questions">More Situational Questions</option>
          <option value="More Behavioral Questions">More Behavioral Questions</option>
          <option value="More Technical Questions">More Technical Questions</option>
          <option value="More Medical/EMR Questions">More Medical/EMR Questions</option>
          <option value="More Leadership Questions">More Leadership Questions</option>
          <option value="More City/Department Questions">More City/Department Questions</option>
          <option value="More Resume-Based Questions">More Resume-Based Questions</option>
          <option value="Better AI Feedback">Better AI Feedback</option>
          <option value="More Difficulty Options">More Difficulty Options</option>
        </select>
        <small style="color: #94a3b8; font-size: 0.75rem; margin-top: 4px; display: block;">Hold Ctrl/Cmd to select multiple</small>
      </div>
      
      <!-- Likelihood to Recommend - Slider -->
      <div>
        <label style="display: block; margin-bottom: 12px; color: #e2e8f0; font-size: 0.9rem; font-weight: 600;">How likely are you to recommend this to others? *</label>
        <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
          <span style="color: #cbd5e1; font-size: 0.85rem;">Not Likely</span>
          <span id="recommendValue" style="color: #fbbf24; font-size: 0.85rem; font-weight: 600;">5</span>
          <span style="color: #cbd5e1; font-size: 0.85rem;">Very Likely</span>
        </div>
        <input type="range" id="feedbackRecommend" min="0" max="10" value="5" step="1" required>
      </div>
      
      <!-- Additional Feedback (Optional) -->
      <div>
        <label style="display: block; margin-bottom: 8px; color: #e2e8f0; font-size: 0.9rem; font-weight: 600;">Anything else? (optional)</label>
        <textarea id="feedbackAdditional" placeholder="Any other comments..." style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid rgba(148, 163, 184, 0.3); background: #1e293b; color: #fff; font-size: 0.9rem; font-family: inherit; min-height: 60px; resize: vertical;"></textarea>
      </div>
      
      <!-- Submit Button -->
      <div style="display: flex; gap: 12px; margin-top: 8px;">
        <button type="submit" style="flex: 1; padding: 12px 24px; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: all 0.2s; box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(239, 68, 68, 0.6)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(239, 68, 68, 0.4)'">
          Submit Feedback
        </button>
        <button type="button" id="cancelFeedbackBtn" style="padding: 12px 24px; background: rgba(148, 163, 184, 0.2); color: #cbd5e1; border: 1px solid rgba(148, 163, 184, 0.3); border-radius: 8px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: all 0.2s;">
          Cancel
        </button>
      </div>
    </form>
  </div>
</div>

<!-- ========== AUTHENTICATION & CREDIT SYSTEM EVENT LISTENERS ========== -->
<script>
  // Check for referral code in URL and store it
  function checkReferralCodeFromURL() {
    const urlParams = new URLSearchParams(window.location.search);
    const refCode = urlParams.get('ref');
    if (refCode && refCode.trim()) {
      const code = refCode.trim().toUpperCase();
      // Store in localStorage so it can be used during signup/login
      localStorage.setItem('pendingReferralCode', code);
      console.log('Referral code detected in URL:', code);
      
      // Show a subtle notification that referral code was detected
      setTimeout(() => {
        const notification = document.createElement('div');
        notification.id = 'referralCodeNotification';
        notification.style.cssText = 'position: fixed; top: 20px; right: 20px; background: rgba(251, 191, 36, 0.95); color: #000; padding: 12px 20px; border-radius: 8px; font-size: 0.9rem; font-weight: 600; z-index: 10000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); display: flex; align-items: center; gap: 8px;';
        notification.innerHTML = `üéÅ Referral code detected! It will be applied when you sign up.`;
        document.body.appendChild(notification);
        
        // Remove notification after 5 seconds
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 5000);
      }, 500);
      
      // Clean up URL (remove ref parameter) for cleaner sharing
      const newUrl = window.location.pathname + (window.location.hash || '');
      window.history.replaceState({}, document.title, newUrl);
    }
  }
  
  // Initialize auth on page load
  document.addEventListener('DOMContentLoaded', () => {
    // CRITICAL: Initialize trial credits FIRST to preserve them
    initializeTrialCredits();
    
    // Then check referral code and auth
    checkReferralCodeFromURL();
    checkAuth();
    updateTrialCreditsDisplay();
    
    // Log current trial credits for debugging
    console.log('[INIT] Trial credits on page load:', getTrialCreditsRemaining());
  });
  
  // Signup form handler
  const signupForm = document.getElementById('signupForm');
  if (signupForm) {
    signupForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const name = document.getElementById('signupName').value;
      const email = document.getElementById('signupEmail').value;
      const password = document.getElementById('signupPassword').value;
      const errorEl = document.getElementById('signupError');
      
      // Hide referral status when submitting
      if (signupReferralStatus) signupReferralStatus.style.display = 'none';
      
      try {
        // Get trial credits before signup
        const trialCredits = getTrialCreditsRemaining();
        
        // Get referral code from input or localStorage (from URL)
        let referralCode = signupReferralCode ? signupReferralCode.value.trim() : '';
        if (!referralCode) {
          const pendingCode = localStorage.getItem('pendingReferralCode');
          if (pendingCode) {
            referralCode = pendingCode;
            // Auto-fill the input field
            if (signupReferralCode) signupReferralCode.value = referralCode;
          }
        }
        if (referralCode) referralCode = referralCode.toUpperCase();
        
        // Get existing onboarding data if available (from pre-signup onboarding)
        const existingOnboardingData = onboardingData || (localStorage.getItem('onboardingData') ? JSON.parse(localStorage.getItem('onboardingData')) : null);
        
        const response = await fetch(`${BACKEND_URL}/api/auth/signup`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ name, email, password, trialCredits, referralCode, onboardingData: existingOnboardingData })
        });
        
        const data = await response.json();
        
        if (response.ok) {
          currentUser = data.user;
          // Store user in localStorage as backup
          localStorage.setItem('currentUser', JSON.stringify(currentUser));
          // Store token in localStorage as fallback
          if (data.token) {
            authToken = data.token;
            setAuthToken(data.token);
          }
          // Load onboarding data if returned from server
          if (data.onboardingData) {
            loadOnboardingDataIntoForm(data.onboardingData);
          }
          // Clear trial credits from localStorage after successful transfer
          if (trialCredits > 0) {
            localStorage.removeItem('trial_credits_remaining');
          }
          // Show success message if referral code was used
          if (referralCode && signupReferralStatus) {
            const codeUpper = referralCode.toUpperCase();
            const isTestCode = codeUpper === 'TEST' || codeUpper === 'UNLIMITED' || codeUpper === 'DEV';
            if (isTestCode) {
              signupReferralStatus.textContent = `‚úì Test referral code "${referralCode}" applied! You received unlimited credits.`;
            } else {
              signupReferralStatus.textContent = `‚úì Referral code "${referralCode}" applied!`;
            }
            signupReferralStatus.style.display = 'block';
            // Clear pending referral code from localStorage after successful use
            localStorage.removeItem('pendingReferralCode');
          }
          updateAuthUI();
          await updateCreditsDisplay();
          document.getElementById('signupModal').style.display = 'none';
          // If coming from paywall, show credit purchase
          if (window.showCreditPurchaseAfterAuth) {
            window.showCreditPurchaseAfterAuth = false;
            showCreditPurchaseModal();
          }
        } else {
          if (errorEl) {
            errorEl.textContent = data.error || 'Signup failed';
            errorEl.style.display = 'block';
          }
        }
      } catch (error) {
        console.error('Signup error:', error);
        if (errorEl) {
          errorEl.textContent = 'Network error. Please try again.';
          errorEl.style.display = 'block';
        }
      }
    });
  }
  
  // Apply referral code button for login form
  const applyLoginReferralCodeBtn = document.getElementById('applyLoginReferralCode');
  const loginReferralCode = document.getElementById('loginReferralCode');
  const loginReferralStatus = document.getElementById('loginReferralStatus');
  
  if (applyLoginReferralCodeBtn && loginReferralCode) {
    applyLoginReferralCodeBtn.addEventListener('click', () => {
      const code = loginReferralCode.value.trim().toUpperCase();
      if (code) {
        if (loginReferralStatus) {
          loginReferralStatus.textContent = `‚úì Code "${code}" will be applied when you log in`;
          loginReferralStatus.style.display = 'block';
        }
      }
    });
  }
  
  // Apply referral code button for signup form
  const applySignupReferralCodeBtn = document.getElementById('applySignupReferralCode');
  const signupReferralCode = document.getElementById('signupReferralCode');
  const signupReferralStatus = document.getElementById('signupReferralStatus');
  
  if (applySignupReferralCodeBtn && signupReferralCode) {
    applySignupReferralCodeBtn.addEventListener('click', () => {
      const code = signupReferralCode.value.trim().toUpperCase();
      if (code) {
        if (signupReferralStatus) {
          signupReferralStatus.textContent = `‚úì Code "${code}" will be applied when you sign up`;
          signupReferralStatus.style.display = 'block';
        }
      }
    });
  }
  
  // Login form handler
  const loginForm = document.getElementById('loginForm');
  if (loginForm) {
    loginForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const email = document.getElementById('loginEmail').value;
      const password = document.getElementById('loginPassword').value;
      const rememberMe = document.getElementById('rememberMe')?.checked || false;
      const errorEl = document.getElementById('loginError');
      
      try {
        // Get trial credits before login
        const trialCredits = getTrialCreditsRemaining();
        
        // Get referral code from input or localStorage (from URL)
        let referralCode = loginReferralCode ? loginReferralCode.value.trim() : '';
        if (!referralCode) {
          const pendingCode = localStorage.getItem('pendingReferralCode');
          if (pendingCode) {
            referralCode = pendingCode;
            // Auto-fill the input field
            if (loginReferralCode) loginReferralCode.value = referralCode;
          }
        }
        if (referralCode) referralCode = referralCode.toUpperCase();
        
        const response = await fetch(`${BACKEND_URL}/api/auth/login`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ email, password, trialCredits, referralCode, rememberMe })
        });
        
        const data = await response.json();
        
        if (response.ok) {
          currentUser = data.user;
          // Store user in localStorage as backup
          localStorage.setItem('currentUser', JSON.stringify(currentUser));
          // Store token in localStorage as fallback
          if (data.token) {
            authToken = data.token;
            setAuthToken(data.token);
          }
          // Load onboarding data if returned from server
          if (data.onboardingData) {
            loadOnboardingDataIntoForm(data.onboardingData);
            // Save to localStorage and update global onboardingData
            onboardingData = data.onboardingData;
            localStorage.setItem('onboardingData', JSON.stringify(data.onboardingData));
          }
          // If user logged in, they've completed onboarding (either now or previously)
          // Always set onboardingComplete to true after successful login
          localStorage.setItem('onboardingComplete', 'true');
          
          // Clear trial credits from localStorage after successful transfer
          if (trialCredits > 0) {
            localStorage.removeItem('trial_credits_remaining');
          }
          // Show success message if referral code was used
          if (referralCode && loginReferralStatus) {
            const codeUpper = referralCode.toUpperCase();
            const isTestCode = codeUpper === 'TEST' || codeUpper === 'UNLIMITED' || codeUpper === 'DEV';
            if (isTestCode) {
              loginReferralStatus.textContent = `‚úì Test referral code "${referralCode}" applied! You received unlimited credits.`;
            } else {
              loginReferralStatus.textContent = `‚úì Referral code "${referralCode}" applied!`;
            }
            loginReferralStatus.style.display = 'block';
            // Clear pending referral code from localStorage after successful use
            localStorage.removeItem('pendingReferralCode');
          }
          updateAuthUI();
          await updateCreditsDisplay();
          const loginModal = document.getElementById('loginModal');
          if (loginModal) loginModal.style.display = 'none';
          
          // Handle login from onboarding modal
          if (window.loginOpenedFromOnboarding) {
            window.loginOpenedFromOnboarding = false;
            
            // Set a flag to prevent page load logic from interfering
            window.justLoggedIn = true;
            
            // Explicitly close ALL modals to ensure nothing is blocking the view
            const onboardingModal = document.getElementById('onboardingModal');
            const termsModal = document.getElementById('termsModal');
            const loginModal = document.getElementById('loginModal');
            const signupModal = document.getElementById('signupModal');
            
            if (onboardingModal) {
              onboardingModal.style.display = 'none';
              onboardingModal.style.visibility = 'hidden';
              console.log('Onboarding modal closed');
            }
            if (termsModal) {
              termsModal.style.display = 'none';
              termsModal.style.visibility = 'hidden';
            }
            if (loginModal) {
              loginModal.style.display = 'none';
              loginModal.style.visibility = 'hidden';
            }
            if (signupModal) {
              signupModal.style.display = 'none';
              signupModal.style.visibility = 'hidden';
            }
            
            // Restore body overflow and remove any modal-related classes
            document.body.style.overflow = 'auto';
            document.body.classList.remove('modal-open');
            
            // Show main app - use multiple methods to ensure it's visible
            const mainApp = document.getElementById('mainApp');
            if (mainApp) {
              // Remove any inline styles that might hide it
              mainApp.removeAttribute('hidden');
              mainApp.style.display = 'block';
              mainApp.style.visibility = 'visible';
              mainApp.style.opacity = '1';
              mainApp.style.position = 'relative';
              mainApp.style.zIndex = '1';
              // Force a reflow to ensure the display change takes effect
              void mainApp.offsetHeight;
              console.log('Main app displayed after login from onboarding');
            } else {
              console.error('Main app element not found after login!');
            }
            
            // Also ensure onboarding data is loaded into the app if available
            if (data.onboardingData && onboardingData) {
              // Update user profile with loaded data
              await updateUserProfile();
              console.log('Onboarding data loaded and profile updated after login');
            }
            
            // Multiple checks to ensure main app stays visible
            setTimeout(() => {
              const mainAppCheck = document.getElementById('mainApp');
              if (mainAppCheck) {
                if (mainAppCheck.style.display !== 'block') {
                  console.warn('Main app was hidden again, forcing it visible');
                  mainAppCheck.style.display = 'block';
                }
                mainAppCheck.style.visibility = 'visible';
                mainAppCheck.style.opacity = '1';
              }
              
              // Ensure all modals are still closed
              const modals = ['onboardingModal', 'termsModal', 'loginModal', 'signupModal'];
              modals.forEach(modalId => {
                const modal = document.getElementById(modalId);
                if (modal && modal.style.display !== 'none') {
                  console.warn(`Modal ${modalId} was reopened, closing it`);
                  modal.style.display = 'none';
                  modal.style.visibility = 'hidden';
                }
              });
            }, 100);
            
            // Clear the flag after a delay
            setTimeout(() => {
              window.justLoggedIn = false;
            }, 1000);
          }
          
          // If coming from paywall, show credit purchase
          if (window.showCreditPurchaseAfterAuth) {
            window.showCreditPurchaseAfterAuth = false;
            setTimeout(() => showCreditPurchaseModal(), 100); // Small delay to ensure modal closes first
          }
        } else {
          if (errorEl) {
            errorEl.textContent = data.error || 'Login failed';
            errorEl.style.display = 'block';
          }
        }
      } catch (error) {
        console.error('Login error:', error);
        if (errorEl) {
          errorEl.textContent = 'Network error. Please try again.';
          errorEl.style.display = 'block';
        }
      }
    });
  }
  
  // Logout handler
  const logoutBtn = document.getElementById('logoutBtn');
  if (logoutBtn) {
    logoutBtn.addEventListener('click', async () => {
      try {
        await authenticatedFetch(`${BACKEND_URL}/api/auth/logout`, {
          method: 'POST'
        });
        currentUser = null;
        authToken = null;
        setAuthToken(null);
        updateAuthUI();
        updateTrialCreditsDisplay();
      } catch (error) {
        console.error('Logout error:', error);
      }
    });
  }
  
  // Auto-fill referral code in modals if present in localStorage
  function autoFillReferralCodeInModals() {
    const pendingCode = localStorage.getItem('pendingReferralCode');
    if (pendingCode) {
      const signupInput = document.getElementById('signupReferralCode');
      const loginInput = document.getElementById('loginReferralCode');
      if (signupInput && !signupInput.value) {
        signupInput.value = pendingCode;
      }
      if (loginInput && !loginInput.value) {
        loginInput.value = pendingCode;
      }
    }
  }
  
  // Modal open/close handlers
  const loginBtn = document.getElementById('loginBtn');
  const signupBtn = document.getElementById('signupBtn');
  const closeLoginModal = document.getElementById('closeLoginModal');
  const closeSignupModal = document.getElementById('closeSignupModal');
  const closePaywallModal = document.getElementById('closePaywallModal');
  const buyCreditsFromPaywall = document.getElementById('buyCreditsFromPaywall');
  const cancelPaywall = document.getElementById('cancelPaywall');
  const closeCreditPurchaseModal = document.getElementById('closeCreditPurchaseModal');
  const userMenuBtn = document.getElementById('userMenuBtn');
  const userMenuDropdown = document.getElementById('userMenuDropdown');
  const switchToLogin = document.getElementById('switchToLogin');
  const switchToSignup = document.getElementById('switchToSignup');
  
  // Switch between login and signup modals
  if (switchToLogin) {
    switchToLogin.addEventListener('click', () => {
      const signupModal = document.getElementById('signupModal');
      const loginModal = document.getElementById('loginModal');
      if (signupModal) signupModal.style.display = 'none';
      if (loginModal) {
        loginModal.style.display = 'flex';
        autoFillReferralCodeInModals();
      }
    });
  }
  
  if (switchToSignup) {
    switchToSignup.addEventListener('click', () => {
      const loginModal = document.getElementById('loginModal');
      const signupModal = document.getElementById('signupModal');
      if (loginModal) loginModal.style.display = 'none';
      if (signupModal) {
        signupModal.style.display = 'flex';
        autoFillReferralCodeInModals();
      }
    });
  }
  
  // Google Sign-In handlers
  const googleSignupBtn = document.getElementById('googleSignupBtn');
  const googleLoginBtn = document.getElementById('googleLoginBtn');
  
  let googleClientId = null;
  let googleInitialized = false;
  let configCache = null; // Cache config to avoid multiple fetches
  
  // Fetch and cache config (optimized - only fetch once)
  async function fetchConfig() {
    if (configCache) return configCache;
    
    try {
      const configRes = await fetch(`${BACKEND_URL}/api/config`);
      if (configRes.ok) {
        configCache = await configRes.json();
        return configCache;
      }
    } catch (e) {
      console.error('[CONFIG] Failed to fetch:', e);
    }
    return null;
  }
  
  // Initialize Google Sign-In on page load
  async function initializeGoogleSignIn() {
    if (googleInitialized) return;
    
    try {
      // Wait for Google Identity Services to load
      if (!window.google || !window.google.accounts) {
        await new Promise((resolve) => {
          const checkGoogle = setInterval(() => {
            if (window.google && window.google.accounts) {
              clearInterval(checkGoogle);
              resolve();
            }
          }, 100);
          setTimeout(() => {
            clearInterval(checkGoogle);
            resolve();
          }, 5000);
        });
      }
      
      if (!window.google || !window.google.accounts) {
        console.error('Google Identity Services not loaded');
        return;
      }
      
      // Get client ID from backend
      try {
        // Ensure BACKEND_URL is defined (should be from first script tag)
        if (typeof BACKEND_URL === 'undefined') {
          console.error('[GOOGLE SIGN-IN] BACKEND_URL is not defined - check script loading order');
          return;
        }
        
        console.log('[GOOGLE SIGN-IN] Fetching config from:', `${BACKEND_URL}/api/config`);
        const config = await fetchConfig();
        if (config) {
          googleClientId = config.googleClientId || null;
          console.log('[GOOGLE SIGN-IN] Config response:', config);
          console.log('[GOOGLE SIGN-IN] Google Client ID:', googleClientId ? `Found (${googleClientId.substring(0, 20)}...)` : 'NOT FOUND');
          
          if (!googleClientId) {
            console.error('[GOOGLE SIGN-IN] Google Client ID is null in config response. Check backend GOOGLE_CLIENT_ID environment variable.');
            return;
          }
        } else {
          const errorText = await configRes.text();
          console.error('[GOOGLE SIGN-IN] Config endpoint error:', configRes.status, errorText);
          return;
        }
      } catch (e) {
        console.error('[GOOGLE SIGN-IN] Failed to fetch config:', e);
        console.error('[GOOGLE SIGN-IN] Error details:', e.message, e.stack);
        return;
      }
      
      if (!googleClientId) {
        console.error('[GOOGLE SIGN-IN] Google Client ID not available after fetch');
        return;
      }
      
      // Initialize Google Sign-In
      window.google.accounts.id.initialize({
        client_id: googleClientId,
        callback: handleGoogleCredential
      });
      
      googleInitialized = true;
      console.log('Google Sign-In initialized');
    } catch (error) {
      console.error('Failed to initialize Google Sign-In:', error);
    }
  }
  
  // Initialize on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeGoogleSignIn);
  } else {
    initializeGoogleSignIn();
  }
  
  async function handleGoogleSignIn() {
    try {
      // Use cached config or fetch if needed
      if (!googleClientId) {
        const config = await fetchConfig();
        if (config) {
          googleClientId = config.googleClientId;
          console.log('Fetched Google Client ID on button click:', googleClientId ? 'Found' : 'Not found');
        }
      }
      
      // Make sure Google is initialized
      if (!googleInitialized && googleClientId) {
        await initializeGoogleSignIn();
      }
      
      if (!window.google || !window.google.accounts) {
        alert('Google Identity Services failed to load. Please refresh the page and try again.');
        return;
      }
      
      if (!googleClientId) {
        console.error('[GOOGLE SIGN-IN] No client ID available - attempting to fetch again...');
        try {
          const config = await fetchConfig();
          if (config) {
            googleClientId = config.googleClientId;
            if (!googleClientId) {
              alert('Google Sign-In is not configured on the backend. Please ensure GOOGLE_CLIENT_ID is set in your Render environment variables and the backend service has been restarted.');
              return;
            }
          } else {
            alert('Unable to connect to backend. Please check your connection and try again.');
            return;
          }
        } catch (e) {
          console.error('[GOOGLE SIGN-IN] Failed to fetch config on button click:', e);
          alert('Unable to connect to backend. Please check your connection and try again.');
          return;
        }
      }
      
      // Use button-based sign-in (more reliable than One Tap)
      window.google.accounts.oauth2.initTokenClient({
        client_id: googleClientId,
        scope: 'openid email profile',
        callback: async (tokenResponse) => {
          try {
            // Exchange access token for ID token
            // First, get user info to verify
            const userInfoRes = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
              headers: { 'Authorization': `Bearer ${tokenResponse.access_token}` }
            });
            
            if (!userInfoRes.ok) {
              throw new Error('Failed to get user info');
            }
            
            const userInfo = await userInfoRes.json();
            
            // Get trial credits before Google sign-in
            const trialCredits = getTrialCreditsRemaining();
            
            // Get referral code from URL or localStorage if available
            const urlParams = new URLSearchParams(window.location.search);
            let referralCode = urlParams.get('ref') || localStorage.getItem('pendingReferralCode') || null;
            if (referralCode) {
              referralCode = referralCode.trim().toUpperCase();
              // Store in localStorage if from URL
              if (urlParams.get('ref')) {
                localStorage.setItem('pendingReferralCode', referralCode);
              }
            }
            
            // Now get ID token using the access token
            // We need to use the ID token for backend verification
            // For now, we'll send the access token and let backend verify
            const res = await fetch(`${BACKEND_URL}/api/auth/google`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              credentials: 'include',
              body: JSON.stringify({ 
                accessToken: tokenResponse.access_token,
                userInfo: userInfo,
                trialCredits: trialCredits,
                referralCode: referralCode
              })
            });
            
            const data = await res.json();
            
            if (res.ok) {
              currentUser = data.user;
          // Store user in localStorage as backup
          localStorage.setItem('currentUser', JSON.stringify(currentUser));
              // Store token in localStorage as fallback
              if (data.token) {
                authToken = data.token;
                setAuthToken(data.token);
              }
              // Clear trial credits from localStorage after successful transfer
              if (trialCredits > 0) {
                localStorage.removeItem('trial_credits_remaining');
              }
              updateAuthUI();
              await updateCreditsDisplay();
              
              const signupModal = document.getElementById('signupModal');
              const loginModal = document.getElementById('loginModal');
              if (signupModal) signupModal.style.display = 'none';
              if (loginModal) loginModal.style.display = 'none';
              
              if (window.showCreditPurchaseAfterAuth) {
                window.showCreditPurchaseAfterAuth = false;
                setTimeout(() => showCreditPurchaseModal(), 100);
              }
            } else {
              alert(data.error || 'Failed to sign in with Google');
            }
          } catch (error) {
            console.error('Google auth error:', error);
            alert('Network error. Please try again.');
          }
        }
      }).requestAccessToken();
    } catch (error) {
      console.error('Google Sign-In error:', error);
      alert('Google Sign-In failed. Please try again or use email/password.');
    }
  }
  
  async function handleGoogleCredential(response) {
    try {
      const res = await fetch(`${BACKEND_URL}/api/auth/google`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ idToken: response.credential })
      });
      
      const data = await res.json();
      
      if (res.ok) {
        currentUser = data.user;
        // Store token in localStorage as fallback
        if (data.token) {
          authToken = data.token;
          setAuthToken(data.token);
        }
        updateAuthUI();
        await updateCreditsDisplay();
        
        const signupModal = document.getElementById('signupModal');
        const loginModal = document.getElementById('loginModal');
        if (signupModal) signupModal.style.display = 'none';
        if (loginModal) loginModal.style.display = 'none';
        
        if (window.showCreditPurchaseAfterAuth) {
          window.showCreditPurchaseAfterAuth = false;
          setTimeout(() => showCreditPurchaseModal(), 100);
        }
      } else {
        alert(data.error || 'Failed to sign in with Google');
      }
    } catch (error) {
      console.error('Google auth error:', error);
      alert('Network error. Please try again.');
    }
  }
  
  if (googleSignupBtn) {
    googleSignupBtn.addEventListener('click', (e) => {
      e.preventDefault();
      handleGoogleSignIn();
    });
  }
  
  if (googleLoginBtn) {
    googleLoginBtn.addEventListener('click', (e) => {
      e.preventDefault();
      handleGoogleSignIn();
    });
  }
  
  // Header button handlers
  // Login/signup buttons are already handled by the existing event listeners below
  
  if (loginBtn) loginBtn.addEventListener('click', () => {
    const loginModal = document.getElementById('loginModal');
    if (loginModal) {
      loginModal.style.display = 'flex';
      autoFillReferralCodeInModals();
    }
  });
  
  if (signupBtn) signupBtn.addEventListener('click', () => {
    const signupModal = document.getElementById('signupModal');
    if (signupModal) {
      signupModal.style.display = 'flex';
      autoFillReferralCodeInModals();
    }
  });
  
  if (closeLoginModal) {
    closeLoginModal.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const loginModal = document.getElementById('loginModal');
      if (loginModal) {
        loginModal.style.display = 'none';
      }
      // If login was opened from onboarding, restore the onboarding modal
      if (window.loginOpenedFromOnboarding) {
        window.loginOpenedFromOnboarding = false;
        const onboardingModal = document.getElementById('onboardingModal');
        if (onboardingModal) {
          onboardingModal.style.display = 'flex';
        }
      }
    });
  }
  
  if (closeSignupModal) {
    closeSignupModal.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const signupModal = document.getElementById('signupModal');
      if (signupModal) {
        signupModal.style.display = 'none';
      }
    });
  }
  
  if (closePaywallModal) closePaywallModal.addEventListener('click', () => {
    const paywallModal = document.getElementById('paywallModal');
    if (paywallModal) paywallModal.style.display = 'none';
  });
  
  if (cancelPaywall) cancelPaywall.addEventListener('click', () => {
    const paywallModal = document.getElementById('paywallModal');
    if (paywallModal) paywallModal.style.display = 'none';
  });
  
  if (buyCreditsFromPaywall) buyCreditsFromPaywall.addEventListener('click', () => {
    const paywallModal = document.getElementById('paywallModal');
    if (paywallModal) paywallModal.style.display = 'none';
    if (!currentUser) {
      // Need to sign up first
      window.showCreditPurchaseAfterAuth = true;
      const signupModal = document.getElementById('signupModal');
      if (signupModal) {
        signupModal.style.display = 'flex';
        autoFillReferralCodeInModals();
      }
    } else {
      showCreditPurchaseModal();
    }
  });
  
  if (closeCreditPurchaseModal) closeCreditPurchaseModal.addEventListener('click', () => {
    const creditPurchaseModal = document.getElementById('creditPurchaseModal');
    if (creditPurchaseModal) creditPurchaseModal.style.display = 'none';
  });
  
  if (userMenuBtn) userMenuBtn.addEventListener('click', () => {
    if (userMenuDropdown) {
      userMenuDropdown.style.display = userMenuDropdown.style.display === 'none' ? 'block' : 'none';
    }
  });
  
  // Close user menu when clicking outside
  document.addEventListener('click', (e) => {
    const userMenu = document.getElementById('userMenu');
    const userMenuDropdown = document.getElementById('userMenuDropdown');
    if (userMenu && userMenuDropdown && !userMenu.contains(e.target)) {
      userMenuDropdown.style.display = 'none';
    }
  });
  
  // Settings button handler
  const settingsBtn = document.getElementById('settingsBtn');
  const settingsModal = document.getElementById('settingsModal');
  const closeSettingsModal = document.getElementById('closeSettingsModal');
  
  function showSettingsModal() {
    if (!settingsModal || !currentUser) return;
    
    // Populate form with current user data
    const settingsName = document.getElementById('settingsName');
    const settingsEmail = document.getElementById('settingsEmail');
    const passwordSection = document.getElementById('passwordSection');
    
    if (settingsName) settingsName.value = currentUser.name || '';
    if (settingsEmail) settingsEmail.value = currentUser.email || '';
    
    // Show password section only for email/password users
    if (passwordSection) {
      passwordSection.style.display = (currentUser.provider === 'email') ? 'block' : 'none';
    }
    
    // Load purchase history
    loadPurchaseHistory();
    loadCreditHistory();
    
    settingsModal.style.display = 'flex';
    const userMenuDropdown = document.getElementById('userMenuDropdown');
    if (userMenuDropdown) userMenuDropdown.style.display = 'none';
  }
  
  if (settingsBtn) {
    settingsBtn.addEventListener('click', showSettingsModal);
  }
  
  if (closeSettingsModal) {
    closeSettingsModal.addEventListener('click', () => {
      if (settingsModal) settingsModal.style.display = 'none';
    });
  }
  
  // Profile form handler
  const profileForm = document.getElementById('profileForm');
  if (profileForm) {
    profileForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const profileError = document.getElementById('profileError');
      const profileSuccess = document.getElementById('profileSuccess');
      const settingsName = document.getElementById('settingsName');
      const settingsCurrentPassword = document.getElementById('settingsCurrentPassword');
      const settingsNewPassword = document.getElementById('settingsNewPassword');
      const settingsConfirmPassword = document.getElementById('settingsConfirmPassword');
      
      if (profileError) profileError.style.display = 'none';
      if (profileSuccess) profileSuccess.style.display = 'none';
      
      // Validate password if changing
      if (settingsNewPassword && settingsNewPassword.value) {
        if (settingsNewPassword.value !== settingsConfirmPassword.value) {
          if (profileError) {
            profileError.textContent = 'New passwords do not match';
            profileError.style.display = 'block';
          }
          return;
        }
        if (settingsNewPassword.value.length < 8) {
          if (profileError) {
            profileError.textContent = 'Password must be at least 8 characters';
            profileError.style.display = 'block';
          }
          return;
        }
      }
      
      try {
        const updateData = {
          name: settingsName ? settingsName.value : undefined
        };
        
        // Add password if provided
        if (settingsNewPassword && settingsNewPassword.value) {
          updateData.password = settingsNewPassword.value;
          updateData.currentPassword = settingsCurrentPassword ? settingsCurrentPassword.value : '';
        }
        
        const res = await fetch(`${BACKEND_URL}/api/auth/profile`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify(updateData)
        });
        
        const data = await res.json();
        
        if (res.ok) {
          currentUser = data.user;
          // Store user in localStorage as backup
          localStorage.setItem('currentUser', JSON.stringify(currentUser));
          updateAuthUI();
          
          if (profileSuccess) {
            profileSuccess.textContent = 'Profile updated successfully!';
            profileSuccess.style.display = 'block';
          }
          
          // Clear password fields
          if (settingsCurrentPassword) settingsCurrentPassword.value = '';
          if (settingsNewPassword) settingsNewPassword.value = '';
          if (settingsConfirmPassword) settingsConfirmPassword.value = '';
          
          setTimeout(() => {
            if (profileSuccess) profileSuccess.style.display = 'none';
          }, 3000);
        } else {
          if (profileError) {
            profileError.textContent = data.error || 'Failed to update profile';
            profileError.style.display = 'block';
          }
        }
      } catch (error) {
        console.error('Update profile error:', error);
        if (profileError) {
          profileError.textContent = 'Network error. Please try again.';
          profileError.style.display = 'block';
        }
      }
    });
  }
  
  async function loadPurchaseHistory() {
    const purchaseHistory = document.getElementById('purchaseHistory');
    if (!purchaseHistory) return;
    
    try {
      const res = await authenticatedFetch(`${BACKEND_URL}/api/auth/purchase-history`);
      
      const data = await res.json();
      
      if (res.ok && data.transactions) {
        if (data.transactions.length === 0) {
          purchaseHistory.innerHTML = '<div style="color: #94a3b8; text-align: center; padding: 20px;">No purchases yet</div>';
        } else {
          // Get bundle names from backend
          const bundlesRes = await fetch(`${BACKEND_URL}/api/credits/bundles`);
          const bundlesData = await bundlesRes.json();
          const bundleMap = {};
          if (bundlesData.bundles) {
            bundlesData.bundles.forEach(b => {
              bundleMap[b.id] = b.name;
            });
          }
          
          purchaseHistory.innerHTML = data.transactions.map(t => {
            const date = new Date(t.created_at).toLocaleDateString();
            const amount = (t.amount_paid_cents / 100).toFixed(2);
            const bundleName = bundleMap[t.pack_id] || t.pack_id;
            return `
              <div style="padding: 12px; background: rgba(15, 23, 42, 0.6); border-radius: 8px; margin-bottom: 8px; border: 1px solid rgba(148, 163, 184, 0.2);">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                  <div>
                    <div style="color: #fbbf24; font-weight: 600;">${bundleName} Pack</div>
                    <div style="color: #94a3b8; font-size: 0.85rem;">${t.credits_purchased} credits ‚Ä¢ ${date}</div>
                  </div>
                  <div style="text-align: right;">
                    <div style="color: #fff; font-weight: 600;">$${amount}</div>
                    <div style="color: ${t.status === 'completed' ? '#86efac' : '#fbbf24'}; font-size: 0.85rem; text-transform: capitalize;">${t.status}</div>
                  </div>
                </div>
              </div>
            `;
          }).join('');
        }
      } else {
        purchaseHistory.innerHTML = '<div style="color: #fca5a5; text-align: center; padding: 20px;">Failed to load purchase history</div>';
      }
    } catch (error) {
      console.error('Load purchase history error:', error);
      purchaseHistory.innerHTML = '<div style="color: #fca5a5; text-align: center; padding: 20px;">Error loading purchase history</div>';
    }
  }
  
  async function loadCreditHistory() {
    const creditHistory = document.getElementById('creditHistory');
    if (!creditHistory) return;
    
    try {
      const res = await authenticatedFetch(`${BACKEND_URL}/api/auth/purchase-history`);
      
      const data = await res.json();
      
      if (res.ok && data.credit_history) {
        if (data.credit_history.length === 0) {
          creditHistory.innerHTML = '<div style="color: #94a3b8; text-align: center; padding: 20px;">No credit history yet</div>';
        } else {
          creditHistory.innerHTML = data.credit_history.slice(0, 20).map(l => {
            const date = new Date(l.created_at).toLocaleDateString();
            const changeColor = l.change > 0 ? '#86efac' : '#fca5a5';
            const changeSign = l.change > 0 ? '+' : '';
            return `
              <div style="padding: 12px; background: rgba(15, 23, 42, 0.6); border-radius: 8px; margin-bottom: 8px; border: 1px solid rgba(148, 163, 184, 0.2);">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                  <div style="color: #cbd5e1; font-size: 0.9rem;">${l.reason}</div>
                  <div style="color: ${changeColor}; font-weight: 600;">${changeSign}${l.change}</div>
                </div>
                <div style="color: #94a3b8; font-size: 0.8rem; margin-top: 4px;">${date}</div>
              </div>
            `;
          }).join('');
        }
      } else {
        creditHistory.innerHTML = '<div style="color: #fca5a5; text-align: center; padding: 20px;">Failed to load credit history</div>';
      }
    } catch (error) {
      console.error('Load credit history error:', error);
      creditHistory.innerHTML = '<div style="color: #fca5a5; text-align: center; padding: 20px;">Error loading credit history</div>';
    }
  }
  
  // Delete Account handlers
  const deleteAccountBtn = document.getElementById('deleteAccountBtn');
  const deleteAccountModal = document.getElementById('deleteAccountModal');
  const closeDeleteAccountModal = document.getElementById('closeDeleteAccountModal');
  const cancelDeleteBtn = document.getElementById('cancelDeleteBtn');
  const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
  const deleteConfirmInput = document.getElementById('deleteConfirmInput');
  const deleteAccountError = document.getElementById('deleteAccountError');
  
  function showDeleteAccountModal() {
    if (!deleteAccountModal || !currentUser) return;
    if (deleteConfirmInput) deleteConfirmInput.value = '';
    if (deleteAccountError) {
      deleteAccountError.textContent = '';
      deleteAccountError.style.display = 'none';
    }
    if (confirmDeleteBtn) confirmDeleteBtn.disabled = true;
    deleteAccountModal.style.display = 'flex';
  }
  
  function hideDeleteAccountModal() {
    if (deleteAccountModal) deleteAccountModal.style.display = 'none';
    if (deleteConfirmInput) deleteConfirmInput.value = '';
    if (deleteAccountError) {
      deleteAccountError.textContent = '';
      deleteAccountError.style.display = 'none';
    }
    if (confirmDeleteBtn) confirmDeleteBtn.disabled = true;
  }
  
  if (deleteAccountBtn) {
    deleteAccountBtn.addEventListener('click', showDeleteAccountModal);
  }
  
  if (closeDeleteAccountModal) {
    closeDeleteAccountModal.addEventListener('click', hideDeleteAccountModal);
  }
  
  if (cancelDeleteBtn) {
    cancelDeleteBtn.addEventListener('click', hideDeleteAccountModal);
  }
  
  // Enable/disable confirm button based on input
  if (deleteConfirmInput && confirmDeleteBtn) {
    deleteConfirmInput.addEventListener('input', (e) => {
      const value = e.target.value.trim().toUpperCase();
      confirmDeleteBtn.disabled = value !== 'DELETE';
      if (deleteAccountError) {
        deleteAccountError.textContent = '';
        deleteAccountError.style.display = 'none';
      }
    });
    
    deleteConfirmInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !confirmDeleteBtn.disabled) {
        confirmDeleteBtn.click();
      }
    });
  }
  
  // Handle account deletion
  if (confirmDeleteBtn) {
    confirmDeleteBtn.addEventListener('click', async () => {
      if (!currentUser) {
        if (deleteAccountError) {
          deleteAccountError.textContent = 'You must be logged in to delete your account';
          deleteAccountError.style.display = 'block';
        }
        return;
      }
      
      const confirmValue = deleteConfirmInput ? deleteConfirmInput.value.trim().toUpperCase() : '';
      if (confirmValue !== 'DELETE') {
        if (deleteAccountError) {
          deleteAccountError.textContent = 'Please type DELETE to confirm';
          deleteAccountError.style.display = 'block';
        }
        return;
      }
      
      if (confirmDeleteBtn.disabled) return;
      
      // Disable button during deletion
      confirmDeleteBtn.disabled = true;
      confirmDeleteBtn.textContent = 'Deleting...';
      
      try {
        const res = await authenticatedFetch(`${BACKEND_URL}/api/auth/delete-account`, {
          method: 'DELETE',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include'
        });
        
        const data = await res.json();
        
        if (res.ok) {
          // Clear all local storage
          localStorage.clear();
          sessionStorage.clear();
          
          // Clear current user
          currentUser = null;
          
          // Update UI
          updateAuthUI();
          
          // Hide modals
          hideDeleteAccountModal();
          if (settingsModal) settingsModal.style.display = 'none';
          
          // Show success message
          alert('Your account has been permanently deleted. All your data has been removed from our servers.');
          
          // Reload page to reset state
          window.location.reload();
        } else {
          if (deleteAccountError) {
            deleteAccountError.textContent = data.error || 'Failed to delete account. Please try again.';
            deleteAccountError.style.display = 'block';
          }
          confirmDeleteBtn.disabled = false;
          confirmDeleteBtn.textContent = 'Delete Account';
        }
      } catch (error) {
        console.error('Delete account error:', error);
        if (deleteAccountError) {
          deleteAccountError.textContent = 'Network error. Please try again.';
          deleteAccountError.style.display = 'block';
        }
        confirmDeleteBtn.disabled = false;
        confirmDeleteBtn.textContent = 'Delete Account';
      }
    });
  }
  
  // Redeem referral code handler (in dropdown menu)
  const dropdownRedeemReferralCodeBtn = document.getElementById('dropdownRedeemReferralCodeBtn');
  const dropdownRedeemReferralCode = document.getElementById('dropdownRedeemReferralCode');
  const dropdownRedeemReferralStatus = document.getElementById('dropdownRedeemReferralStatus');
  const dropdownRedeemReferralError = document.getElementById('dropdownRedeemReferralError');
  
  function handleReferralCodeRedemption(inputElement, statusElement, errorElement) {
    return async () => {
      const code = inputElement.value.trim().toUpperCase();
      if (!code) {
        if (errorElement) {
          errorElement.textContent = 'Please enter a referral code';
          errorElement.style.display = 'block';
        }
        if (statusElement) statusElement.style.display = 'none';
        return;
      }
      
      // Hide previous messages
      if (statusElement) statusElement.style.display = 'none';
      if (errorElement) errorElement.style.display = 'none';
      
      try {
        // Check if it's a test code - these always work
        const codeUpper = code.toUpperCase().trim();
        const isTestCode = codeUpper === 'TEST' || codeUpper === 'UNLIMITED' || codeUpper === 'DEV';
        
        // For test codes, skip validation and go straight to redemption
        if (!isTestCode) {
          // Validate code first (only for non-test codes)
          try {
            const validateRes = await fetch(`${BACKEND_URL}/api/referrals/validate`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ code })
            });
            
            const validateData = await validateRes.json();
            if (!validateData.valid) {
              if (errorElement) {
                errorElement.textContent = validateData.message || 'Invalid referral code';
                errorElement.style.display = 'block';
              }
              return;
            }
          } catch (validateError) {
            console.error('Validation error:', validateError);
            // Continue anyway for test codes
          }
        }
        
        // Redeem the referral code
        const redeemRes = await authenticatedFetch(`${BACKEND_URL}/api/referrals/redeem`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ code })
        });
        
        const redeemData = await redeemRes.json();
        
        if (redeemRes.ok && redeemData.success) {
          if (statusElement) {
            const creditsText = isTestCode ? 'unlimited' : (redeemData.creditsGranted || '3');
            statusElement.textContent = `‚úì Redeemed! +${creditsText} credits`;
            statusElement.style.display = 'block';
          }
          
          // Refresh user data and credits display
          const meRes = await authenticatedFetch(`${BACKEND_URL}/api/auth/me`);
          if (meRes.ok) {
            const userData = await meRes.json();
            currentUser = userData;
            updateAuthUI();
            await updateCreditsDisplay();
            loadCreditHistory(); // Refresh credit history
          }
          
          inputElement.value = '';
          
          // Clear success message after 3 seconds
          setTimeout(() => {
            if (statusElement) statusElement.style.display = 'none';
          }, 3000);
        } else {
          if (redeemRes.status === 401 || redeemRes.status === 403) {
            // Authentication error - clear state and show login
            handleAuthError();
            if (errorElement) {
              errorElement.textContent = 'Session expired. Please log in again.';
              errorElement.style.display = 'block';
            }
          } else {
            if (errorElement) {
              errorElement.textContent = redeemData.error || 'Failed to redeem referral code';
              errorElement.style.display = 'block';
            }
          }
        }
      } catch (error) {
        console.error('Redeem referral code error:', error);
        if (errorElement) {
          errorElement.textContent = 'Error redeeming code. Please try again.';
          errorElement.style.display = 'block';
        }
      }
    };
  }
  
  if (dropdownRedeemReferralCodeBtn && dropdownRedeemReferralCode) {
    dropdownRedeemReferralCodeBtn.addEventListener('click', handleReferralCodeRedemption(
      dropdownRedeemReferralCode,
      dropdownRedeemReferralStatus,
      dropdownRedeemReferralError
    ));
    
    // Also allow Enter key to submit
    dropdownRedeemReferralCode.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        dropdownRedeemReferralCodeBtn.click();
      }
    });
  }
  
  // Make showSettingsModal available globally
  window.showSettingsModal = showSettingsModal;
  
  // Credit purchase modal
  async function showCreditPurchaseModal() {
    if (!currentUser) {
      window.showCreditPurchaseAfterAuth = true;
      document.getElementById('signupModal').style.display = 'flex';
      return;
    }
    
    const modal = document.getElementById('creditPurchaseModal');
    const container = document.getElementById('creditBundlesContainer');
    
    // Load referral code - make sure modal is visible first
    if (modal) modal.style.display = 'flex';
    
    try {
      const refResponse = await authenticatedFetch(`${BACKEND_URL}/api/referrals/my-code`);
      if (refResponse.ok) {
        const refData = await refResponse.json();
        const referralCodeInput = document.getElementById('referralCodeDisplay');
        if (referralCodeInput) {
          referralCodeInput.value = refData.referralCode || 'Loading...';
          console.log('Referral code loaded:', refData.referralCode);
        }
      } else {
        console.error('Failed to load referral code:', refResponse.status);
        if (refResponse.status === 401 || refResponse.status === 403) {
          handleAuthError();
          // Close modal and show login
          if (modal) modal.style.display = 'none';
          const loginModal = document.getElementById('loginModal');
          if (loginModal) loginModal.style.display = 'flex';
          return;
        }
        const referralCodeInput = document.getElementById('referralCodeDisplay');
        if (referralCodeInput) {
          referralCodeInput.value = 'Error loading code';
        }
      }
    } catch (error) {
      console.error('Error loading referral code:', error);
      const referralCodeInput = document.getElementById('referralCodeDisplay');
      if (referralCodeInput) {
        referralCodeInput.value = 'Error loading code';
      }
    }
    
    try {
      const response = await fetch(`${BACKEND_URL}/api/credits/bundles`);
      const data = await response.json();
      
      // Don't show modal again if already shown
      if (modal && modal.style.display === 'flex') {
        // Modal already visible, just update bundles
      } else if (modal) {
        modal.style.display = 'flex';
      }
      
      if (container) {
        container.innerHTML = data.bundles.map(bundle => {
          const isPopular = bundle.isPopular || false;
          const isBestValue = bundle.isBestValue || false;
          const highlightStyle = isPopular || isBestValue ? 'rgba(251, 191, 36, 0.1)' : '#0f172a';
          const borderStyle = isPopular || isBestValue ? 'rgba(251, 191, 36, 0.5)' : 'rgba(148, 163, 184, 0.2)';
          const badgeText = isPopular ? 'MOST POPULAR' : isBestValue ? 'BEST VALUE' : '';
          
          return `
          <div style="padding: 20px; background: ${highlightStyle}; border: 2px solid ${borderStyle}; border-radius: 12px; text-align: center; cursor: pointer; transition: all 0.2s; position: relative; ${isPopular || isBestValue ? 'box-shadow: 0 4px 12px rgba(251, 191, 36, 0.3);' : ''}" 
               onmouseover="this.style.borderColor='rgba(251, 191, 36, 0.5)'; this.style.transform='translateY(-2px)'" 
               onmouseout="this.style.borderColor='${borderStyle}'; this.style.transform='translateY(0)'"
               onclick="purchaseCredits('${bundle.id}')">
               ${badgeText ? `<div style="position: absolute; top: -10px; left: 50%; transform: translateX(-50%); background: #fbbf24; color: #0f172a; padding: 4px 12px; border-radius: 12px; font-size: 0.75rem; font-weight: 700; text-transform: uppercase;">${badgeText}</div>` : ''}
            <h3 style="margin: ${badgeText ? '16px' : '0'} 0 8px 0; color: #fbbf24; font-size: 1.2rem;">${bundle.name}</h3>
            <div style="font-size: 2rem; font-weight: 700; color: #fff; margin: 12px 0;">${bundle.credits}</div>
            <div style="color: #94a3b8; font-size: 0.9rem; margin-bottom: 8px;">credits</div>
            <div style="color: #fbbf24; font-size: 1.5rem; font-weight: 600; margin: 16px 0;">$${bundle.price_dollars}</div>
            ${bundle.price_per_credit ? `<div style="color: #cbd5e1; font-size: 0.85rem; margin-bottom: 8px;">${bundle.price_per_credit} per Q</div>` : ''}
            ${bundle.description ? `<div style="color: #cbd5e1; font-size: 0.85rem; margin-bottom: ${isPopular || isBestValue ? '8px' : '0'}; font-style: italic;">${bundle.description}</div>` : ''}
            ${isPopular ? '<div style="color: #fbbf24; font-size: 0.8rem; font-weight: 600; margin-top: 8px; padding: 8px; background: rgba(251, 191, 36, 0.15); border-radius: 6px;">Most effective for serious practice</div>' : ''}
          </div>
        `;
        }).join('');
      }
      
      if (modal) modal.style.display = 'flex';
    } catch (error) {
      console.error('Error loading credit bundles:', error);
    }
  }
  
  async function purchaseCredits(packId) {
    if (!currentUser) {
      // Show signup modal if not logged in
      window.showCreditPurchaseAfterAuth = true;
      const signupModal = document.getElementById('signupModal');
      if (signupModal) {
        signupModal.style.display = 'flex';
      }
      return;
    }
    
    try {
      console.log('Creating checkout session for pack:', packId, 'User:', currentUser.id);
      const response = await authenticatedFetch(`${BACKEND_URL}/api/credits/create-checkout-session`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ packId })
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        console.error('Checkout session error:', response.status, errorData);
        
        if (response.status === 401 || response.status === 403) {
          // Token expired or invalid - try to refresh user session first
          console.log('Auth token issue, attempting to refresh user session...');
          try {
            const meResponse = await authenticatedFetch(`${BACKEND_URL}/api/auth/me`);
            if (meResponse.ok) {
              const userData = await meResponse.json();
              currentUser = userData;
              updateAuthUI();
              await updateCreditsDisplay();
              // Retry the purchase
              console.log('Session refreshed, retrying purchase...');
              return purchaseCredits(packId);
            } else {
              // Session really expired - don't show alert, just redirect to login
              console.log('Session expired, redirecting to login...');
              window.currentUser = null;
              updateAuthUI();
              // Close credit purchase modal
              const creditPurchaseModal = document.getElementById('creditPurchaseModal');
              if (creditPurchaseModal) creditPurchaseModal.style.display = 'none';
              // Show login modal
              const loginModal = document.getElementById('loginModal');
              if (loginModal) {
                loginModal.style.display = 'flex';
                // Show a message in the login modal
                const loginError = document.getElementById('loginError');
                if (loginError) {
                  loginError.textContent = 'Your session expired. Please log in again to continue.';
                  loginError.style.display = 'block';
                }
              }
              return;
            }
          } catch (refreshError) {
            console.error('Failed to refresh session:', refreshError);
            window.currentUser = null;
            updateAuthUI();
            // Close credit purchase modal
            const creditPurchaseModal = document.getElementById('creditPurchaseModal');
            if (creditPurchaseModal) creditPurchaseModal.style.display = 'none';
            // Show login modal
            const loginModal = document.getElementById('loginModal');
            if (loginModal) {
              loginModal.style.display = 'flex';
            }
            return;
          }
        }
        
        // Handle Stripe not configured error
        if (errorData.error && errorData.error.includes('Stripe not configured')) {
          alert('Payment processing is not yet configured. Please contact support.');
          return;
        }
        
        alert(errorData.error || 'Failed to create checkout session. Please try again.');
        return;
      }
      
      const data = await response.json();
      console.log('Checkout session created:', data.sessionId);
      
      if (data.url) {
        // Redirect to Stripe checkout
        window.location.href = data.url;
      } else {
        alert('Failed to create checkout session. Please try again.');
      }
    } catch (error) {
      console.error('Purchase error:', error);
      alert('Network error. Please try again.');
    }
  }
  
  // Referral code share functionality
  const shareReferralCodeBtn = document.getElementById('shareReferralCode');
  const referralCodeDisplay = document.getElementById('referralCodeDisplay');
  const referralCodeStatus = document.getElementById('referralCodeStatus');
  
  async function shareReferralCode() {
    const code = referralCodeDisplay ? referralCodeDisplay.value : '';
    if (!code || code === 'Loading...' || code === 'Error loading code') {
      if (referralCodeStatus) {
        referralCodeStatus.textContent = 'Please wait for code to load';
        referralCodeStatus.style.color = '#fca5a5';
        referralCodeStatus.style.display = 'block';
        setTimeout(() => {
          referralCodeStatus.style.display = 'none';
          referralCodeStatus.style.color = '#86efac';
        }, 2000);
      }
      return;
    }
    
    const shareUrl = `${window.location.origin}?ref=${code}`;
    const shareText = `Sharing the interview coach I'm using ‚Äî it pushes you to answer stronger and think sharper.\n\nIf you give one question a go, it helps me out and gets you some solid practice.\n\n${shareUrl}`;
    
    // Try Web Share API first (native sharing on mobile/desktop)
    // Put everything in text field - some platforms ignore url if text is provided
    if (navigator.share) {
      try {
        await navigator.share({
          title: 'Fire Interview Coach',
          text: shareText
        });
        if (referralCodeStatus) {
          referralCodeStatus.textContent = '‚úì Shared!';
          referralCodeStatus.style.color = '#86efac';
          referralCodeStatus.style.display = 'block';
          setTimeout(() => {
            referralCodeStatus.style.display = 'none';
          }, 2000);
        }
        return;
      } catch (err) {
        // User cancelled or error - fall through to copy
        if (err.name !== 'AbortError') {
          console.log('Share failed, falling back to copy:', err);
        } else {
          // User cancelled, don't show error
          return;
        }
      }
    }
    
    // Fallback: Copy to clipboard
    try {
      // Use modern Clipboard API if available
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(shareText);
      } else {
        // Fallback for older browsers
        referralCodeDisplay.select();
        referralCodeDisplay.setSelectionRange(0, 99999);
        document.execCommand('copy');
      }
      
      if (referralCodeStatus) {
        referralCodeStatus.textContent = '‚úì Copied to clipboard!';
        referralCodeStatus.style.color = '#86efac';
        referralCodeStatus.style.display = 'block';
        setTimeout(() => {
          referralCodeStatus.style.display = 'none';
        }, 2000);
      }
    } catch (err) {
      console.error('Failed to copy:', err);
      if (referralCodeStatus) {
        referralCodeStatus.textContent = 'Failed to share/copy';
        referralCodeStatus.style.color = '#fca5a5';
        referralCodeStatus.style.display = 'block';
        setTimeout(() => {
          referralCodeStatus.style.display = 'none';
          referralCodeStatus.style.color = '#86efac';
        }, 2000);
      }
    }
  }
  
  if (shareReferralCodeBtn && referralCodeDisplay) {
    shareReferralCodeBtn.addEventListener('click', shareReferralCode);
  }
  
  // Make functions globally accessible
  window.showCreditPurchaseModal = showCreditPurchaseModal;
  window.purchaseCredits = purchaseCredits;
  
  // Trial credits dropdown toggle
  const trialCreditsBtn = document.getElementById('trialCreditsBtn');
  const trialCreditsDropdown = document.getElementById('trialCreditsDropdown');
  
  if (trialCreditsBtn && trialCreditsDropdown) {
    trialCreditsBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const isVisible = trialCreditsDropdown.style.display === 'block';
      trialCreditsDropdown.style.display = isVisible ? 'none' : 'block';
    });
  }
  
  // Close modals when clicking outside
  document.addEventListener('click', (e) => {
    const modals = ['signupModal', 'loginModal', 'paywallModal', 'creditPurchaseModal'];
    modals.forEach(modalId => {
      const modal = document.getElementById(modalId);
      if (modal && e.target === modal) {
        modal.style.display = 'none';
      }
    });
    
    // Close user menu when clicking outside
    if (userMenuDropdown && !userMenuBtn.contains(e.target) && !userMenuDropdown.contains(e.target)) {
      userMenuDropdown.style.display = 'none';
    }
    
    // Close trial credits dropdown when clicking outside
    if (trialCreditsDropdown && trialCreditsBtn && !trialCreditsBtn.contains(e.target) && !trialCreditsDropdown.contains(e.target)) {
      trialCreditsDropdown.style.display = 'none';
    }
  });
</script>

<!-- Paywall Modal -->
<div id="paywallModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.9); z-index: 10000; align-items: center; justify-content: center;">
  <div style="background: #1e293b; border: 2px solid rgba(251, 191, 36, 0.5); border-radius: 16px; padding: 40px; max-width: 500px; width: 90%; max-height: 90vh; overflow-y: auto; text-align: center;">
    <h2 style="margin: 0 0 16px 0; color: #fbbf24; font-size: 1.8rem;">You've used your 3 free questions</h2>
    <p style="color: #cbd5e1; margin-bottom: 32px; line-height: 1.6;">
      To keep practicing and unlock full 10/10 answers and detailed feedback, you'll need credits.
    </p>
    <div style="display: flex; gap: 12px; justify-content: center;">
      <button id="buyCreditsFromPaywall" class="primary" style="padding: 12px 24px; font-size: 1rem;">Buy Credits</button>
      <button id="closePaywallModal" class="ghost" style="padding: 12px 24px; font-size: 1rem;">Maybe later</button>
    </div>
  </div>
</div>

<!-- Credit Purchase Modal -->
<div id="creditPurchaseModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.8); z-index: 10000; align-items: center; justify-content: center;">
  <div style="background: #1e293b; border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 16px; padding: 32px; max-width: 800px; width: 90%; max-height: 90vh; overflow-y: auto;">
    <h2 style="margin: 0 0 24px 0; color: #fbbf24; font-size: 1.8rem; text-align: center;">Choose your plan</h2>
    <div id="creditBundlesContainer" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 16px; margin-bottom: 24px;">
      <!-- Bundles will be loaded here -->
    </div>
    <div style="text-align: center;">
      <button id="closeCreditPurchaseModal" class="ghost" style="padding: 12px 24px;">Cancel</button>
    </div>
  </div>
</div>

</body>
</html>
