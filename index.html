<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Load configuration file for easy text updates -->
  <script src="config.js"></script>
  <meta charset="UTF-8" />
  <title>Fire Interview Coach</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');
    
    :root {
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0a0a0f;
      color: #f9fafb;
      --fire-red: #ef4444;
      --fire-orange: #f97316;
      --fire-yellow: #fbbf24;
      --fire-dark: #7f1d1d;
      --fire-darker: #450a0a;
      --dark-bg: #0f172a;
      --card-bg: rgba(15, 23, 42, 0.85);
      --card-border: rgba(239, 68, 68, 0.2);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      background: 
        radial-gradient(circle at 20% 10%, rgba(239, 68, 68, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 80% 90%, rgba(249, 115, 22, 0.1) 0%, transparent 50%),
        linear-gradient(180deg, #0a0a0f 0%, #1a0a0f 50%, #0a0a0f 100%);
      background-attachment: fixed;
      position: relative;
      overflow-x: hidden;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(239, 68, 68, 0.03) 2px, rgba(239, 68, 68, 0.03) 4px);
      pointer-events: none;
      z-index: 0;
    }

    .app {
      max-width: 1400px;
      width: 100%;
      margin: 20px auto;
      padding: 24px;
      border-radius: 24px;
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.95) 0%, rgba(30, 41, 59, 0.9) 100%);
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      gap: 16px;
      position: relative;
      z-index: 1;
      backdrop-filter: blur(10px);
      box-sizing: border-box;
    }

    header {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 24px;
      padding: 40px 24px;
      border-bottom: 2px solid rgba(239, 68, 68, 0.2);
      margin: -24px -24px 24px -24px;
      background: #000000;
      border-radius: 12px 12px 0 0;
      min-height: 180px;
    }

    .title {
      display: flex;
      align-items: center;
      gap: 24px;
      flex: 1;
    }

    .badge {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      padding: 4px 12px;
      border-radius: 999px;
      border: 1px solid rgba(239, 68, 68, 0.5);
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.2) 0%, rgba(249, 115, 22, 0.15) 100%);
      color: #fecaca;
      font-weight: 600;
      box-shadow: 0 0 12px rgba(239, 68, 68, 0.3);
      animation: pulse-glow 2s ease-in-out infinite;
    }

    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 0 12px rgba(239, 68, 68, 0.3); }
      50% { box-shadow: 0 0 20px rgba(239, 68, 68, 0.5); }
    }

    h1 {
      margin: 0;
      font-size: 1.8rem;
      font-weight: 800;
      display: flex;
      align-items: center;
      gap: 12px;
      background: linear-gradient(135deg, #ffffff 0%, #fecaca 50%, #fbbf24 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 30px rgba(239, 68, 68, 0.3);
    }

    h1 span.logo {
      width: 40px;
      height: 40px;
      border-radius: 12px;
      background: linear-gradient(135deg, #f97316 0%, #ef4444 50%, #dc2626 100%);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      transform: rotate(-8deg);
      box-shadow: 
        0 4px 12px rgba(239, 68, 68, 0.4),
        0 0 20px rgba(249, 115, 22, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      animation: fire-flicker 3s ease-in-out infinite;
      position: relative;
    }

    h1 span.logo::after {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(135deg, #f97316, #ef4444, #f97316);
      border-radius: 12px;
      z-index: -1;
      opacity: 0.5;
      filter: blur(8px);
      animation: fire-flicker 3s ease-in-out infinite;
    }

    @keyframes fire-flicker {
      0%, 100% { transform: rotate(-8deg) scale(1); }
      25% { transform: rotate(-6deg) scale(1.05); }
      50% { transform: rotate(-10deg) scale(0.98); }
      75% { transform: rotate(-7deg) scale(1.02); }
    }

    .subtitle {
      margin: 4px 0 0 0;
      font-size: 0.9rem;
      color: #cbd5e1;
      font-weight: 400;
      letter-spacing: 0.02em;
    }

    .layout {
      display: grid;
      grid-template-columns: 1.2fr 1fr;
      gap: 12px;
    }

    /* Responsive Styles */
    @media (max-width: 1280px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }

    /* Tablet Styles */
    @media (max-width: 1024px) {
      body {
        padding: 0;
      }
      
      .app {
        margin: 20px auto;
        padding: 16px;
        border-radius: 16px;
        width: 100%;
        box-sizing: border-box;
      }
      
      header {
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
      }
      
      .title {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }
      
      h1 {
        font-size: 1.5rem;
      }
      
      .card {
        padding: 16px;
      }
      
      .feedback-grid {
        grid-template-columns: 1fr;
      }
      
      .question-controls {
        flex-wrap: wrap;
      }
      
      .video-wrapper {
        max-height: 400px;
      }
    }
    
    @media (max-width: 768px) {
      .app {
        margin: 5px;
        padding: 12px;
      }
      
      header .title {
        width: 100%;
        gap: 12px;
      }
      
      header .title > div:first-child {
        width: 80px;
        height: 80px;
        padding: 8px;
      }
      
      h1 {
        font-size: 1.5rem;
        flex-wrap: wrap;
      }
      
      .subtitle {
        font-size: 0.8rem;
      }
      
      .card-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }
      
      .card-title {
        font-size: 0.95rem;
      }
      
      button {
        font-size: 0.85rem;
        padding: 8px 12px;
      }
      
      .video-wrapper {
        max-height: 300px;
      }
      
      video, canvas {
        max-height: 300px;
      }
    }
    
    @media (max-width: 480px) {
      .app {
        margin: 0;
        padding: 8px;
        border-radius: 0;
      }
      
      header {
        padding: 8px 0;
      }
      
      .card {
        padding: 12px;
        border-radius: 12px;
      }
      
      .feedback-block {
        padding: 10px;
      }
      
      .feedback-block h4 {
        font-size: 0.9rem;
      }
      
      .feedback-block p {
        font-size: 0.8rem;
      }
    }

    .card {
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.95) 0%, rgba(30, 41, 59, 0.9) 100%);
      border-radius: 20px;
      padding: 20px;
      border: 1px solid rgba(239, 68, 68, 0.15);
      display: flex;
      flex-direction: column;
      gap: 12px;
      box-shadow: 
        0 4px 16px rgba(0, 0, 0, 0.3),
        0 0 0 1px rgba(239, 68, 68, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.05);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, transparent, rgba(239, 68, 68, 0.5), transparent);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .card:hover {
      border-color: rgba(239, 68, 68, 0.3);
      box-shadow: 
        0 8px 24px rgba(0, 0, 0, 0.4),
        0 0 0 1px rgba(239, 68, 68, 0.2),
        0 0 30px rgba(239, 68, 68, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.08);
      transform: translateY(-2px);
    }

    .card:hover::before {
      opacity: 1;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
    }

    .card-title {
      font-size: 1rem;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 8px;
      color: #f9fafb;
      letter-spacing: 0.01em;
    }

    .card-title small {
      font-size: 0.75rem;
      font-weight: 400;
      color: #cbd5e1;
      opacity: 0.8;
    }

    .left, .right {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    label.file-label {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      cursor: pointer;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px dashed rgba(148, 163, 184, 0.5);
      font-size: 0.8rem;
      color: #e5e7eb;
    }

    label.file-label span.icon {
      font-size: 1rem;
    }

    input[type="file"] {
      display: none;
    }

    .resume-summary {
      font-size: 0.75rem;
      color: #9ca3af;
      max-height: 90px;
      overflow-y: auto;
      padding-right: 4px;
    }

    .resume-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 4px;
    }

    .tag {
      font-size: 0.7rem;
      padding: 4px 10px;
      border-radius: 999px;
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.2) 0%, rgba(249, 115, 22, 0.15) 100%);
      color: #fecaca;
      border: 1px solid rgba(239, 68, 68, 0.3);
      font-weight: 500;
      transition: all 0.2s ease;
    }

    .tag:hover {
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.3) 0%, rgba(249, 115, 22, 0.25) 100%);
      border-color: rgba(239, 68, 68, 0.5);
      transform: scale(1.05);
    }

    button {
      border-radius: 12px;
      border: none;
      padding: 12px 20px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      color: #fff;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 
        0 4px 12px rgba(239, 68, 68, 0.3),
        0 0 0 0 rgba(239, 68, 68, 0.5);
      position: relative;
      overflow: hidden;
      letter-spacing: 0.02em;
    }

    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s ease;
    }

    button:hover::before {
      left: 100%;
    }

    button:hover {
      background: linear-gradient(135deg, #f97316 0%, #ef4444 100%);
      transform: translateY(-2px);
      box-shadow: 
        0 8px 20px rgba(239, 68, 68, 0.5),
        0 0 30px rgba(249, 115, 22, 0.4),
        0 0 0 2px rgba(239, 68, 68, 0.3);
    }

    button.secondary {
      background: linear-gradient(135deg, rgba(55, 65, 81, 0.9) 0%, rgba(30, 41, 59, 0.9) 100%);
      color: #e5e7eb;
      border: 1px solid rgba(148, 163, 184, 0.2);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    button.secondary:hover {
      background: linear-gradient(135deg, rgba(75, 85, 99, 0.95) 0%, rgba(55, 65, 81, 0.95) 100%);
      border-color: rgba(239, 68, 68, 0.3);
      box-shadow: 
        0 4px 12px rgba(0, 0, 0, 0.3),
        0 0 20px rgba(239, 68, 68, 0.1);
    }

    button.ghost {
      background: transparent;
      color: #cbd5e1;
      padding: 6px 12px;
      border-radius: 8px;
      border: 1px solid rgba(148, 163, 184, 0.2);
      transition: all 0.2s ease;
    }

    button.ghost:hover {
      background: rgba(239, 68, 68, 0.1);
      border-color: rgba(239, 68, 68, 0.3);
      color: #fecaca;
    }

    button:active {
      transform: translateY(0);
      box-shadow: 
        0 2px 8px rgba(239, 68, 68, 0.4),
        0 0 0 1px rgba(239, 68, 68, 0.3);
    }

    button[disabled] {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .question-text {
      min-height: 40px;
      font-size: 0.9rem;
      line-height: 1.4;
      color: #e5e7eb;
    }

    .question-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      font-size: 0.7rem;
      color: #9ca3af;
    }

    .question-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-top: 4px;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #16a34a;
    }

    .status-dot.off {
      background: #991b1b;
    }

    .status {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.8rem;
      color: #9ca3af;
    }

    .transcript {
      background: rgba(15, 23, 42, 0.9);
      border-radius: 10px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      padding: 6px 8px;
      min-height: 52px;
      font-size: 0.75rem;
      color: #e5e7eb;
      overflow-y: auto;
      max-height: 110px;
    }

    .feedback-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
      font-size: 0.75rem;
    }

    @media (max-width: 600px) {
      .feedback-grid {
        grid-template-columns: 1fr;
      }
    }

    .feedback-block {
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.95) 0%, rgba(30, 41, 59, 0.9) 100%);
      border-radius: 12px;
      border: 1px solid rgba(239, 68, 68, 0.15);
      padding: 12px;
      transition: all 0.2s ease;
    }

    .feedback-block:hover {
      border-color: rgba(239, 68, 68, 0.3);
      box-shadow: 0 2px 8px rgba(239, 68, 68, 0.1);
    }

    .feedback-block h4 {
      margin: 0 0 8px 0;
      font-size: 0.85rem;
      font-weight: 700;
      color: #f9fafb;
      letter-spacing: 0.01em;
    }

    .feedback-block p {
      margin: 0;
      color: #cbd5e1;
      line-height: 1.5;
      font-size: 0.8rem;
    }

    .score-pill {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(34, 197, 94, 0.15);
      color: #bbf7d0;
    }

    .score-pill.mid {
      background: rgba(234, 179, 8, 0.15);
      color: #facc15;
    }

    .score-pill.low {
      background: rgba(248, 113, 113, 0.15);
      color: #fecaca;
    }

    .video-wrapper {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      background: #020617;
      border: 1px solid rgba(30, 64, 175, 0.7);
      aspect-ratio: 4 / 3;
    }

    video, canvas {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    canvas {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .video-overlay {
      position: absolute;
      inset: auto 8px 8px 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 6px;
      border-radius: 10px;
      background: linear-gradient(to right, rgba(15, 23, 42, 0.9), rgba(30, 64, 175, 0.8));
      font-size: 0.7rem;
      color: #e5e7eb;
    }

    .video-overlay span.label {
      text-transform: uppercase;
      font-size: 0.65rem;
      letter-spacing: 0.12em;
      color: #93c5fd;
    }

    .video-overlay span.value {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .metrics-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      font-size: 0.7rem;
      color: #9ca3af;
      margin-top: 4px;
    }

    .metric-chip {
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
    }

    .small-note {
      font-size: 0.7rem;
      color: #6b7280;
    }

    /* AI Feedback Modal */
    .ai-modal-overlay {
      display: none !important;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.9);
      z-index: 99999;
      align-items: center;
      justify-content: center;
      padding: 20px;
      overflow-y: auto;
      backdrop-filter: blur(5px);
      box-sizing: border-box;
    }

    .ai-modal-overlay.active {
      display: flex !important;
    }

    .ai-modal {
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.95) 100%);
      border-radius: 24px;
      padding: 32px;
      width: 90%;
      max-width: 900px;
      max-height: 85vh;
      overflow-y: auto;
      box-shadow: 0 24px 60px rgba(0, 0, 0, 0.9);
      border: none;
      position: relative;
      margin: 0;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-self: center;
    }

    .ai-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 16px;
      border-bottom: 1px solid rgba(239, 68, 68, 0.3);
    }

    .ai-modal-header h3 {
      margin: 0;
      font-size: 1.5rem;
      color: #fbbf24;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .ai-modal-close {
      background: none;
      border: none;
      color: #9ca3af;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      transition: all 0.2s;
    }

    .ai-modal-close:hover {
      background: rgba(239, 68, 68, 0.2);
      color: #fca5a5;
    }

    .ai-modal-content {
      font-size: 0.95rem;
      line-height: 1.7;
      color: #e5e7eb;
      flex: 1;
      overflow-y: auto;
      min-height: 0;
    }

    .ai-modal-content h4 {
      margin: 20px 0 12px 0;
      color: #fbbf24;
      font-size: 1.1rem;
      font-weight: 600;
    }

    .ai-modal-content div {
      margin-bottom: 12px;
    }

    .ai-modal-content .bullet-point {
      margin-left: 20px;
      margin-bottom: 8px;
      color: #e5e7eb;
    }

    .ai-modal-content .score-highlight {
      color: #fbbf24;
      font-weight: 600;
      font-size: 1.1rem;
    }

    /* Autocomplete Suggestions */
    .suggestion-item {
      padding: 10px 12px;
      cursor: pointer;
      color: #e2e8f0;
      font-size: 0.9rem;
      border-bottom: 1px solid rgba(239, 68, 68, 0.1);
      transition: background 0.2s;
    }

    .suggestion-item:hover {
      background: rgba(239, 68, 68, 0.15);
    }

    .suggestion-item:last-child {
      border-bottom: none;
    }

    .suggestion-item .suggestion-main {
      font-weight: 500;
      color: #fca5a5;
    }

    .suggestion-item .suggestion-detail {
      font-size: 0.8rem;
      color: #94a3b8;
      margin-top: 2px;
    }

    .suggestion-loading {
      padding: 12px;
      text-align: center;
      color: #94a3b8;
      font-size: 0.85rem;
    }
  </style>
  <!-- PDF.js for PDF text extraction -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    // Configure PDF.js worker to fix deprecation warning
    if (typeof pdfjsLib !== 'undefined') {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    }
  </script>
</head>
<body>

<!-- Terms & Privacy Acceptance Modal -->
<div id="termsModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 10000; display: none; align-items: center; justify-content: center; padding: 20px; backdrop-filter: blur(5px);">
  <div style="background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.98) 100%); border: 2px solid rgba(239, 68, 68, 0.3); border-radius: 16px; padding: 40px; max-width: 600px; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(239, 68, 68, 0.3);">
    <div style="text-align: center; margin-bottom: 30px;">
      <h2 style="color: #ef4444; font-size: 2em; margin-bottom: 10px;">üî• Welcome to Fire Interview Coach</h2>
      <p style="color: #cbd5e1; font-size: 1.1em;">Please review and accept our terms to continue</p>
    </div>
    
    <div style="background: rgba(239, 68, 68, 0.1); border-left: 4px solid #ef4444; padding: 15px; margin-bottom: 25px; border-radius: 4px;">
      <p style="color: #fca5a5; margin: 0; font-size: 0.95em;">
        <strong>Important:</strong> Fire Interview Coach is a practice tool only and does not guarantee job offers or employment.
      </p>
    </div>
    
    <div style="margin-bottom: 25px;">
      <label style="display: flex; align-items: flex-start; cursor: pointer; color: #e2e8f0; margin-bottom: 15px;">
        <input type="checkbox" id="acceptTerms" style="margin-right: 12px; margin-top: 4px; width: 20px; height: 20px; cursor: pointer; accent-color: #ef4444;">
        <span style="line-height: 1.6;">
          I have read and agree to the <a href="terms-of-service.html" target="_blank" style="color: #fca5a5; text-decoration: underline;">Terms of Service</a>
        </span>
      </label>
      
      <label style="display: flex; align-items: flex-start; cursor: pointer; color: #e2e8f0;">
        <input type="checkbox" id="acceptPrivacy" style="margin-right: 12px; margin-top: 4px; width: 20px; height: 20px; cursor: pointer; accent-color: #ef4444;">
        <span style="line-height: 1.6;">
          I have read and agree to the <a href="privacy-policy.html" target="_blank" style="color: #fca5a5; text-decoration: underline;">Privacy Policy</a>
        </span>
      </label>
    </div>
    
    <div style="display: flex; gap: 15px; justify-content: center;">
      <button id="acceptTermsBtn" style="padding: 14px 28px; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: #fff; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);" disabled>
        Accept & Continue
      </button>
    </div>
    
    <p style="text-align: center; margin-top: 20px; color: #94a3b8; font-size: 0.85em;">
      You must accept both terms to use Fire Interview Coach
    </p>
  </div>
</div>

<!-- Onboarding Modal -->
<div id="onboardingModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 10001; display: none; align-items: center; justify-content: center; padding: 20px; backdrop-filter: blur(5px); overflow-y: auto;">
  <div style="background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.98) 100%); border: 2px solid rgba(239, 68, 68, 0.3); border-radius: 16px; padding: 40px; max-width: 700px; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(239, 68, 68, 0.3);">
    <div style="text-align: center; margin-bottom: 30px;">
      <h2 style="color: #ef4444; font-size: 2em; margin-bottom: 10px;">üéØ Let's Get Started</h2>
      <p style="color: #cbd5e1; font-size: 1.1em;">Help us personalize your interview practice</p>
    </div>
    
    <form id="onboardingForm" style="display: flex; flex-direction: column; gap: 20px;">
      <!-- Resume Upload (Optional) -->
      <div>
        <label style="display: block; color: #e2e8f0; font-weight: 600; margin-bottom: 8px; font-size: 0.95rem;" id="onboardingResumeLabel">
          1. Upload Resume <span style="color: #94a3b8; font-weight: 400;">(Optional)</span>
        </label>
        <label class="file-label" style="display: flex; align-items: center; gap: 8px; padding: 12px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(239, 68, 68, 0.2); border-radius: 8px; cursor: pointer; transition: all 0.2s;">
          <span class="icon">üìÑ</span>
          <span style="flex: 1; color: #cbd5e1;" id="onboardingResumeButtonText">Upload resume (.txt / PDF)</span>
          <input type="file" id="onboardingResumeInput" accept=".txt,.pdf,.doc,.docx,.rtf" style="display: none;" />
        </label>
        <div id="onboardingResumeStatus" style="margin-top: 8px; font-size: 0.85rem; color: #94a3b8; min-height: 20px;"></div>
      </div>

      <!-- Location Selection -->
      <div>
        <label style="display: block; color: #e2e8f0; font-weight: 600; margin-bottom: 8px; font-size: 0.95rem;" id="onboardingLocationLabel">
          2. What City are you applying to? <span style="color: #ef4444;">*</span>
        </label>
        <div>
          <label style="display: block; color: #cbd5e1; font-size: 0.85rem; margin-bottom: 6px;" id="onboardingCountryLabel">Country</label>
          <select id="onboardingCountry" required style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px; color: #e2e8f0; font-size: 0.95rem; cursor: pointer; margin-bottom: 12px;">
            <option value="" id="onboardingCountryPlaceholder">Select Country</option>
            <option value="United States" id="onboardingCountryUS">United States</option>
            <option value="Canada" id="onboardingCountryCanada">Canada</option>
            <option value="United Kingdom" id="onboardingCountryUK">United Kingdom</option>
            <option value="Australia" id="onboardingCountryAustralia">Australia</option>
            <option value="New Zealand" id="onboardingCountryNZ">New Zealand</option>
            <option value="Other" id="onboardingCountryOther">Other</option>
          </select>
        </div>
        <div style="position: relative; margin-bottom: 12px;">
          <label style="display: block; color: #cbd5e1; font-size: 0.85rem; margin-bottom: 6px;" id="onboardingStateLabel">State/Province</label>
          <input type="text" id="onboardingStateProvince" placeholder="Start typing state/province (AI will suggest)" autocomplete="off" style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px; color: #e2e8f0; font-size: 0.95rem;">
          <div id="stateSuggestions" style="position: absolute; top: 100%; left: 0; right: 0; background: rgba(15, 23, 42, 0.98); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px; margin-top: 4px; max-height: 200px; overflow-y: auto; z-index: 10002; display: none; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);"></div>
        </div>
        <div style="position: relative;">
          <label style="display: block; color: #cbd5e1; font-size: 0.85rem; margin-bottom: 6px;" id="onboardingCityLabel">City</label>
          <input type="text" id="onboardingCity" placeholder="Start typing city name (AI will suggest)" required autocomplete="off" style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px; color: #e2e8f0; font-size: 0.95rem;">
          <div id="citySuggestions" style="position: absolute; top: 100%; left: 0; right: 0; background: rgba(15, 23, 42, 0.98); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px; margin-top: 4px; max-height: 200px; overflow-y: auto; z-index: 10002; display: none; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);"></div>
        </div>
      </div>

      <!-- Job Type Selection -->
      <div>
        <label style="display: block; color: #e2e8f0; font-weight: 600; margin-bottom: 8px; font-size: 0.95rem;" id="onboardingJobTypeLabel">
          3. What are you applying for? <span style="color: #ef4444;">*</span>
        </label>
        <select id="onboardingJobType" required style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px; color: #e2e8f0; font-size: 0.95rem; cursor: pointer;">
          <option value="" id="onboardingJobTypePlaceholder">Select Position Type</option>
          <option value="Fire" id="onboardingJobTypeFire">Fire</option>
          <option value="Police" id="onboardingJobTypePolice">Police</option>
          <option value="Paramedic" id="onboardingJobTypeParamedic">Paramedic</option>
          <option value="First Responder" id="onboardingJobTypeFirstResponder">First Responder</option>
          <option value="Dispatcher" id="onboardingJobTypeDispatcher">Dispatcher</option>
        </select>
      </div>

      <!-- Department Name -->
      <div>
        <label style="display: block; color: #e2e8f0; font-weight: 600; margin-bottom: 8px; font-size: 0.95rem;" id="onboardingDepartmentLabel">
          4. Department Name <span style="color: #ef4444;">*</span>
        </label>
        <input type="text" id="onboardingDepartmentName" placeholder="e.g., Abbotsford Fire Department" required style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px; color: #e2e8f0; font-size: 0.95rem;">
        <p style="margin-top: 6px; font-size: 0.8rem; color: #94a3b8;" id="onboardingDepartmentHelper">This will be used to personalize your interview questions</p>
      </div>

      <!-- Name (Optional) -->
      <div>
        <label style="display: block; color: #e2e8f0; font-weight: 600; margin-bottom: 8px; font-size: 0.95rem;" id="onboardingNameLabel">
          5. Your Name <span style="color: #94a3b8; font-weight: 400;">(Optional)</span>
        </label>
        <input type="text" id="onboardingName" placeholder="e.g., John Smith" style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px; color: #e2e8f0; font-size: 0.95rem;">
        <p style="margin-top: 6px; font-size: 0.8rem; color: #94a3b8;">AI will address you by name in some questions</p>
      </div>

      <!-- Voice Selection -->
      <div>
        <label style="display: block; color: #e2e8f0; font-weight: 600; margin-bottom: 8px; font-size: 0.95rem;" id="onboardingVoiceLabel">
          6. Voice Preference <span style="color: #94a3b8; font-weight: 400;">(Optional)</span>
        </label>
        <select id="onboardingVoice" style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px; color: #e2e8f0; font-size: 0.95rem; cursor: pointer;">
          <option value="">Default (Auto)</option>
          <option value="male">Male Voice</option>
          <option value="female">Female Voice</option>
        </select>
        <p style="margin-top: 6px; font-size: 0.8rem; color: #94a3b8;">Choose your preferred voice for question narration</p>
      </div>

      <!-- Submit Button -->
      <div style="display: flex; gap: 15px; justify-content: center; margin-top: 10px;">
        <button type="submit" id="onboardingSubmitBtn" style="padding: 14px 28px; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: #fff; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);">Start Practice Session</button>
      </div>
      
      <p style="text-align: center; margin-top: 10px; color: #94a3b8; font-size: 0.85em;" id="onboardingRequiredFields">
        <span style="color: #ef4444;">*</span> Required fields
      </p>
    </form>
  </div>
</div>

<div class="app" id="mainApp" style="display: none;">
  <header>
    <div class="title" style="display: flex; align-items: center; justify-content: center; width: 100%; height: 100%;">
      <!-- Logo Only - Scaled to Fit Banner -->
      <div style="display: flex; align-items: center; justify-content: center; width: 100%; height: 100%;">
        <img id="logoImage" src="banner-logo.png" alt="Interview Coach AI Logo" 
             style="width: 100%; height: auto; max-height: 160px; object-fit: contain; display: block;"
             onerror="console.error('Logo image failed to load:', this.src); this.style.display='none'; this.nextElementSibling.style.display='block';">
        <!-- Fallback SVG if logo image not found -->
        <svg width="500" height="120" viewBox="0 0 90 90" style="display: none; max-height: 120px;">
          <!-- Maltese Cross Background -->
          <path d="M45 12 L50 32 L70 32 L55 44 L60 64 L45 52 L30 64 L35 44 L20 32 L40 32 Z" 
                fill="none" 
                stroke="#94a3b8" 
                stroke-width="2.5" 
                stroke-linejoin="round"
                opacity="0.8"/>
          <!-- Flame Icon (center) -->
          <g transform="translate(45, 30)">
            <path d="M0 -5 L-2 5 L0 8 L2 5 Z" fill="#f97316"/>
            <path d="M0 -5 L-1.5 0 L0 3 L1.5 0 Z" fill="#fb923c"/>
            <circle cx="0" cy="-2" r="1.5" fill="#fbbf24"/>
          </g>
          <!-- Signal/WiFi Lines (below flame) -->
          <path d="M45 48 Q50 46 55 48" 
                fill="none" 
                stroke="#f97316" 
                stroke-width="2.5" 
                stroke-linecap="round"/>
          <path d="M45 51 Q53 48 61 51" 
                fill="none" 
                stroke="#f97316" 
                stroke-width="2.5" 
                stroke-linecap="round"/>
          <path d="M45 54 Q55 50 65 54" 
                fill="none" 
                stroke="#f97316" 
                stroke-width="2.5" 
                stroke-linecap="round"/>
          <!-- IH Letters (left arm) -->
          <text x="22" y="55" font-family="Arial, sans-serif" font-size="9" fill="#94a3b8" font-weight="bold" opacity="0.9">I</text>
          <text x="22" y="65" font-family="Arial, sans-serif" font-size="9" fill="#94a3b8" font-weight="bold" opacity="0.9">H</text>
          <!-- Asterisk (right arm) -->
          <text x="63" y="60" font-family="Arial, sans-serif" font-size="12" fill="#94a3b8" opacity="0.9">*</text>
        </svg>
      </div>
    </div>
  </header>

  <main class="layout">
    <!-- LEFT SIDE -->
    <section class="left">
      <!-- Resume card -->
      <div class="card">
        <div class="card-header">
          <div class="card-title">
            Resume
            <small>(tailors questions to your background)</small>
          </div>
          <button class="ghost" id="clearResumeBtn" type="button">Clear</button>
        </div>
        <div style="display: flex; flex-wrap: wrap; gap: 8px; align-items: center; margin-bottom: 6px;">
          <label class="file-label">
            <span class="icon">üìÑ</span>
            <span>Upload resume (.txt / simple PDF)</span>
            <input type="file" id="resumeInput" accept=".txt,.pdf,.doc,.docx,.rtf" />
          </label>
          <span class="small-note">
            For a full build, use a backend parser. This demo reads simple text.
          </span>
        </div>
        <div class="resume-summary" id="resumeSummary" style="padding: 16px; background: rgba(15, 23, 42, 0.6); border-radius: 8px; border: 1px solid rgba(239, 68, 68, 0.2); min-height: 120px;">
          <div style="color: #94a3b8; font-size: 0.9rem; text-align: center; padding: 20px;">
            No resume loaded yet. Upload a file to get personalized questions based on your experience.
          </div>
        </div>
        <div class="resume-tags" id="resumeTags" style="margin-top: 12px;"></div>
      </div>

      <!-- Question / mic card -->
      <div class="card">
        <div class="card-header">
          <div class="card-title">
            Interview Question
            <small id="questionCategoryLabel"></small>
          </div>
          <div class="question-controls">
            <button id="nextQuestionBtn" type="button">
              üé§ Next Question
            </button>
            <button id="repeatQuestionBtn" class="secondary" type="button">
              üîÅ Repeat
            </button>
          </div>
        </div>
        
        <!-- Practice Mode Toggle -->
        <div style="padding: 12px; background: rgba(239, 68, 68, 0.1); border-radius: 8px; margin: 12px; border: 1px solid rgba(239, 68, 68, 0.2);">
          <label style="display: block; margin-bottom: 8px; font-size: 0.85rem; color: #cbd5e1; font-weight: 600;">Practice Mode:</label>
          <div style="display: flex; gap: 16px; margin-bottom: 8px; flex-wrap: wrap;">
            <label style="display: flex; align-items: center; cursor: pointer; color: #e2e8f0; font-size: 0.9rem;">
              <input type="radio" name="practiceMode" id="simulationMode" value="simulation" checked style="margin-right: 6px; accent-color: #ef4444;">
              <span>üé≤ Interview Simulation (Random)</span>
            </label>
            <label style="display: flex; align-items: center; cursor: pointer; color: #e2e8f0; font-size: 0.9rem;">
              <input type="radio" name="practiceMode" id="specificMode" value="specific" style="margin-right: 6px; accent-color: #ef4444;">
              <span>üéØ User-Specific Practice</span>
            </label>
          </div>
          
          <!-- Category Selector (shown only in User-Specific mode) -->
          <div id="categorySelector" style="display: none; margin-top: 8px;">
            <label style="display: block; margin-bottom: 6px; font-size: 0.85rem; color: #cbd5e1;">Focus Category:</label>
            <select id="categorySelect" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid rgba(148, 163, 184, 0.3); background: #1e293b; color: #fff; font-size: 0.9rem; cursor: pointer;">
              <option value="">All Categories (Mixed)</option>
              <option value="Chain of Command">Chain of Command</option>
              <option value="Ethics & Integrity">Ethics & Integrity</option>
              <option value="Safety & Accountability">Safety & Accountability</option>
              <option value="Teamwork & Collaboration">Teamwork & Collaboration</option>
              <option value="Conflict Resolution">Conflict Resolution</option>
              <option value="Decision Making">Decision Making</option>
              <option value="Communication">Communication</option>
              <option value="Stress Management">Stress Management</option>
              <option value="Leadership">Leadership</option>
              <option value="Medical / EMR">Medical / EMR</option>
              <option value="Technical ‚Äì Fireground">Technical ‚Äì Fireground</option>
              <option value="Resume-Based">Resume-Based Questions</option>
              <option value="City & Department Specific">City & Department Specific</option>
            </select>
          </div>
        </div>
        
        <div class="question-text" id="questionText">
          Click <strong>Next Question</strong> to begin. AI will generate personalized questions based on your resume and conversation history.
        </div>
        <div id="questionSubtitles" style="margin-top: 8px; padding: 8px; background: rgba(15, 23, 42, 0.6); border-radius: 8px; font-size: 0.9rem; color: #cbd5e1; min-height: 24px; display: none;"></div>
        <div class="question-meta">
          <span>Question #<span id="questionIndex">0</span></span>
          <span>‚Ä¢</span>
          <span>Mode: AI-Powered Dynamic Panel (behavioural + technical + contextual followups)</span>
        </div>
        <div id="followupButtonContainer" style="margin-top: 12px;"></div>
        <div class="question-controls" style="margin-top: 10px;">
          <button id="startAnswerBtn" class="secondary" type="button">
            üé§ Answer Question
          </button>
          <button id="stopAnswerBtn" class="secondary" type="button" disabled>
            ‚úÖ Finish Answering Question
          </button>
          <div class="status">
            <span class="status-dot off" id="micStatusDot"></span>
            <span id="micStatusText"><!-- Loaded from config.js --></span>
          </div>
        </div>
        <p style="margin-top: 6px; font-size: 0.8rem; color: #94a3b8;">
          After each question is read aloud, recording will start automatically. Just begin speaking, then click
          <strong>Finish Answering Question</strong> when you‚Äôre done.
        </p>
        <div class="transcript" id="transcriptBox">
          Your live transcript will show here if your browser supports speech recognition. You can also type edits manually.
        </div>
      </div>

    </section>

    <!-- RIGHT SIDE -->
    <section class="right">
      <!-- Video card -->
      <div class="card">
        <div class="card-header">
          <div class="card-title">
            Camera & Presence
            <small>(just like sitting in front of a hiring panel)</small>
          </div>
          <button id="cameraBtn" type="button" class="secondary">
            üì∑ Start Camera
          </button>
        </div>
        <div class="video-wrapper">
          <video id="camera" autoplay playsinline muted></video>
          <canvas id="motionCanvas"></canvas>
          <div class="video-overlay">
            <span class="label">Body Language</span>
            <span class="value">
              Motion score:
              <strong id="motionScore">‚Äì</strong>
            </span>
          </div>
        </div>
        <div class="metrics-row">
          <span class="metric-chip">Environment: Aim for chest-up framing, neutral background, good light.</span>
          <span class="metric-chip">Goal: calm but engaged, limited fidgeting.</span>
        </div>
      </div>

      <!-- Feedback card - moved under camera -->
      <div class="card">
        <div class="card-header">
          <div class="card-title">
            Feedback on This Answer
          </div>
        </div>
        
        <!-- Progress bar for AI analysis -->
        <div id="aiProgressContainer" style="display: none; margin-bottom: 12px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
            <span style="font-size: 0.85rem; color: #cbd5e1;">ü§ñ AI Analyzing...</span>
            <span id="aiProgressPercent" style="font-size: 0.85rem; color: #f97316; font-weight: 600;">0%</span>
          </div>
          <div style="width: 100%; height: 8px; background: rgba(15, 23, 42, 0.6); border-radius: 4px; overflow: hidden;">
            <div id="aiProgressBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #f97316, #ef4444); border-radius: 4px; transition: width 0.3s ease; box-shadow: 0 0 10px rgba(249, 115, 22, 0.5);"></div>
          </div>
        </div>
        
        <div class="feedback-grid">
          <div class="feedback-block">
            <h4>Content & Structure <span id="contentScore" class="score-pill low">‚Äì</span></h4>
            <p id="contentFeedback">
              After you finish answering, feedback will appear here automatically.
            </p>
          </div>
          <div class="feedback-block">
            <h4>Voice & Filler Words <span id="voiceScore" class="score-pill low">‚Äì</span></h4>
            <p id="voiceFeedback">
              "Um, uh, like‚Ä¶" will be detected and summarized here based on your transcript.
            </p>
          </div>
          <div class="feedback-block">
            <h4>Body Language (Camera) <span id="bodyScore" class="score-pill low">‚Äì</span></h4>
            <p id="bodyFeedback">
              Movement and stability from the webcam feed will be scored as "steady / moderate / fidgety".
            </p>
          </div>
          <div class="feedback-block">
            <h4>Fire-Specific Tips / AI Coach</h4>
            <p id="fireTips">
              We'll highlight if you're hitting key themes: safety, teamwork, accountability, medical care, community, and learning from mistakes.
            </p>
            <button id="viewAIFeedbackBtn" type="button" style="margin-top: 8px; padding: 8px 12px; border-radius: 6px; border: 1px solid rgba(239, 68, 68, 0.5); background: rgba(239, 68, 68, 0.1); color: #fca5a5; cursor: pointer; font-size: 0.85rem; display: none;">
              üìñ View Detailed AI Feedback
            </button>
          </div>
        </div>
      </div>

    </section>
  </main>
</div>

<!-- Onscreen Console (Debug) -->
<div id="debugConsole" style="position: fixed; bottom: 20px; right: 20px; width: 400px; max-height: 300px; background: rgba(15, 23, 42, 0.95); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 12px; padding: 12px; z-index: 9999; display: none; box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5); font-family: 'Courier New', monospace; font-size: 11px;">
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid rgba(239, 68, 68, 0.2);">
    <h4 style="margin: 0; color: #fbbf24; font-size: 12px; font-weight: 600;">üêõ Debug Console</h4>
    <div>
      <button id="clearConsoleBtn" style="padding: 4px 8px; margin-right: 4px; background: rgba(239, 68, 68, 0.2); border: 1px solid rgba(239, 68, 68, 0.3); color: #fca5a5; border-radius: 4px; cursor: pointer; font-size: 10px;">Clear</button>
      <button id="toggleConsoleBtn" style="padding: 4px 8px; background: rgba(239, 68, 68, 0.2); border: 1px solid rgba(239, 68, 68, 0.3); color: #fca5a5; border-radius: 4px; cursor: pointer; font-size: 10px;">Hide</button>
    </div>
  </div>
  <div id="consoleContent" style="max-height: 240px; overflow-y: auto; color: #cbd5e1; line-height: 1.4;">
    <!-- Console messages will appear here -->
  </div>
</div>

<button id="showConsoleBtn" style="position: fixed; bottom: 20px; right: 20px; width: 50px; height: 50px; border-radius: 50%; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); border: none; color: #fff; font-size: 20px; cursor: pointer; z-index: 9998; box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4); display: flex; align-items: center; justify-content: center;">üêõ</button>

  <!-- Footer with Legal Links -->
  <footer style="text-align: center; padding: 30px 20px; margin-top: auto; border-top: 1px solid rgba(239, 68, 68, 0.2); color: #94a3b8; font-size: 0.9em; width: 100%; clear: both; display: block; flex-shrink: 0;">
    <div style="max-width: 1200px; margin: 0 auto;">
      <p style="margin-bottom: 10px; color: #94a3b8;" id="footerCopyright"><!-- Loaded from config.js --></p>
      <p style="margin: 0;">
        <a href="terms-of-service.html" style="color: #fca5a5; text-decoration: none; margin: 0 15px; transition: color 0.2s;" id="footerTermsLink"><!-- Loaded from config.js --></a>
        <span style="color: rgba(239, 68, 68, 0.5);">|</span>
        <a href="privacy-policy.html" style="color: #fca5a5; text-decoration: none; margin: 0 15px; transition: color 0.2s;" id="footerPrivacyLink"><!-- Loaded from config.js --></a>
      </p>
      <p style="margin-top: 10px; font-size: 0.85em; color: #64748b;" id="footerDisclaimer"><!-- Loaded from config.js --></p>
    </div>
  </footer>
</div>

<!-- AI Feedback Modal - Outside app container for proper fixed positioning -->
<div id="aiModalOverlay" class="ai-modal-overlay">
  <div class="ai-modal">
    <div class="ai-modal-header">
      <h3>ü§ñ AI Interview Coach Feedback</h3>
      <button class="ai-modal-close" id="closeAIModal" type="button">√ó</button>
    </div>
    <div class="ai-modal-content" id="aiModalContent">
      <!-- AI feedback will be inserted here -->
    </div>
  </div>
</div>

<script>
  // ========== LOAD CONFIGURATION TEXT ==========
  // Update all text elements from config.js
  document.addEventListener('DOMContentLoaded', function() {
    if (typeof APP_CONFIG !== 'undefined') {
      // Update buttons
      const nextQuestionBtn = document.getElementById('nextQuestionBtn');
      if (nextQuestionBtn) nextQuestionBtn.textContent = APP_CONFIG.buttons.nextQuestion;
      
      const startAnswerBtn = document.getElementById('startAnswerBtn');
      if (startAnswerBtn) startAnswerBtn.textContent = APP_CONFIG.buttons.answerQuestion;
      
      const stopAnswerBtn = document.getElementById('stopAnswerBtn');
      if (stopAnswerBtn) stopAnswerBtn.textContent = APP_CONFIG.buttons.finishAnswering;
      
      const repeatQuestionBtn = document.getElementById('repeatQuestionBtn');
      if (repeatQuestionBtn) repeatQuestionBtn.textContent = APP_CONFIG.buttons.repeatQuestion;
      
      // Update footer
      const footerCopyright = document.getElementById('footerCopyright');
      if (footerCopyright) {
        footerCopyright.textContent = APP_CONFIG.footer.copyright
          .replace('{year}', APP_CONFIG.copyrightYear)
          .replace('{company}', APP_CONFIG.companyName);
      }
      
      const footerTermsLink = document.getElementById('footerTermsLink');
      if (footerTermsLink) footerTermsLink.textContent = APP_CONFIG.footer.termsLink;
      
      const footerPrivacyLink = document.getElementById('footerPrivacyLink');
      if (footerPrivacyLink) footerPrivacyLink.textContent = APP_CONFIG.footer.privacyLink;
      
      const footerDisclaimer = document.getElementById('footerDisclaimer');
      if (footerDisclaimer) {
        footerDisclaimer.textContent = APP_CONFIG.footer.disclaimer
          .replace('{appName}', APP_CONFIG.appName);
      }
      
      // Update modal titles
      const aiModalTitle = document.querySelector('.ai-modal-header h3');
      if (aiModalTitle) aiModalTitle.textContent = APP_CONFIG.modals.aiFeedback;
      
      // Update status text
      const micStatusText = document.getElementById('micStatusText');
      if (micStatusText) micStatusText.textContent = APP_CONFIG.status.micIdle;
      
      // Update question instruction text
      const questionTextEl = document.getElementById('questionText');
      if (questionTextEl && questionTextEl.textContent.includes('Click')) {
        questionTextEl.innerHTML = APP_CONFIG.instructions.getStarted;
      }
    }
  });

  // ========== TERMS & PRIVACY ACCEPTANCE ==========
  const termsModal = document.getElementById("termsModal");
  const acceptTermsCheckbox = document.getElementById("acceptTerms");
  const acceptPrivacyCheckbox = document.getElementById("acceptPrivacy");
  const acceptTermsBtn = document.getElementById("acceptTermsBtn");
  const onboardingModal = document.getElementById("onboardingModal");
  const mainApp = document.getElementById("mainApp");
  
  // Hide main app by default
  if (mainApp) {
    mainApp.style.display = "none";
  }
  
  // Check if user has already accepted terms
  const termsAccepted = localStorage.getItem("termsAccepted") === "true";
  const privacyAccepted = localStorage.getItem("privacyAccepted") === "true";
  const onboardingComplete = localStorage.getItem("onboardingComplete") === "true";
  
  // Show modal if terms not accepted
  if (!termsAccepted || !privacyAccepted) {
    if (termsModal) {
      termsModal.style.display = "flex";
      // Disable all interactions until accepted
      document.body.style.overflow = "hidden";
      console.log("Terms modal displayed - terms not yet accepted");
    } else {
      console.error("Terms modal element not found!");
      // Fallback: show main app if modal doesn't exist
      if (mainApp) mainApp.style.display = "block";
    }
  } else if (!onboardingComplete) {
    // Terms accepted but onboarding not complete - show onboarding modal
    if (onboardingModal) {
      onboardingModal.style.display = "flex";
      document.body.style.overflow = "hidden";
      console.log("Onboarding modal displayed - onboarding not yet complete");
    } else {
      console.error("Onboarding modal element not found!");
      // Fallback: show main app if modal doesn't exist
      if (mainApp) mainApp.style.display = "block";
    }
  } else {
    // Both terms and onboarding complete - show main app
    if (mainApp) {
      mainApp.style.display = "block";
      console.log("Terms and onboarding already complete - showing main app");
    } else {
      console.error("Main app element not found!");
    }
  }
  
  // Update accept button state
  function updateAcceptButton() {
    if (acceptTermsBtn && acceptTermsCheckbox && acceptPrivacyCheckbox) {
      acceptTermsBtn.disabled = !(acceptTermsCheckbox.checked && acceptPrivacyCheckbox.checked);
      if (acceptTermsBtn.disabled) {
        acceptTermsBtn.style.opacity = "0.5";
        acceptTermsBtn.style.cursor = "not-allowed";
      } else {
        acceptTermsBtn.style.opacity = "1";
        acceptTermsBtn.style.cursor = "pointer";
      }
    }
  }
  
  // Listen for checkbox changes
  if (acceptTermsCheckbox) {
    acceptTermsCheckbox.addEventListener("change", updateAcceptButton);
  }
  if (acceptPrivacyCheckbox) {
    acceptPrivacyCheckbox.addEventListener("change", updateAcceptButton);
  }
  
  // Handle accept button click
  if (acceptTermsBtn) {
    acceptTermsBtn.addEventListener("click", () => {
      if (acceptTermsCheckbox.checked && acceptPrivacyCheckbox.checked) {
        // Save acceptance to localStorage
        localStorage.setItem("termsAccepted", "true");
        localStorage.setItem("privacyAccepted", "true");
        localStorage.setItem("termsAcceptedDate", new Date().toISOString());
        
        // Hide terms modal
        if (termsModal) {
          termsModal.style.display = "none";
        }
        
        // Check if onboarding is complete
        const onboardingCompleteCheck = localStorage.getItem("onboardingComplete") === "true";
        if (!onboardingCompleteCheck) {
          // Show onboarding modal
          if (onboardingModal) {
            onboardingModal.style.display = "flex";
            document.body.style.overflow = "hidden";
          }
        } else {
          // Show main app
          if (mainApp) {
            mainApp.style.display = "block";
          }
          document.body.style.overflow = "auto";
        }
        
        console.log("Terms and Privacy Policy accepted");
      }
    });
  }
  
  // Prevent closing modal by clicking outside (user must accept)
  if (termsModal) {
    termsModal.addEventListener("click", (e) => {
      if (e.target === termsModal) {
        // Optionally show a message that they must accept
        alert("You must accept the Terms of Service and Privacy Policy to use Fire Interview Coach.");
      }
    });
  }

  // Load onboarding config on page load
  function loadOnboardingConfig() {
    if (typeof ONBOARDING_CONFIG === 'undefined') {
      console.warn('Onboarding config not loaded');
      return;
    }
    
    // Update title and subtitle
    const titleEl = document.getElementById('onboardingTitle');
    const subtitleEl = document.getElementById('onboardingSubtitle');
    if (titleEl) titleEl.textContent = ONBOARDING_CONFIG.title;
    if (subtitleEl) subtitleEl.textContent = ONBOARDING_CONFIG.subtitle;
    
    // Update resume section
    const resumeLabelEl = document.getElementById('onboardingResumeLabel');
    const resumeButtonEl = document.getElementById('onboardingResumeButtonText');
    if (resumeLabelEl) {
      resumeLabelEl.innerHTML = ONBOARDING_CONFIG.resume.label + ' <span style="color: #94a3b8; font-weight: 400;">' + ONBOARDING_CONFIG.resume.optional + '</span>';
    }
    if (resumeButtonEl) resumeButtonEl.textContent = ONBOARDING_CONFIG.resume.uploadButtonText;
    
    // Update location section
    const locationLabelEl = document.getElementById('onboardingLocationLabel');
    const countryLabelEl = document.getElementById('onboardingCountryLabel');
    const stateLabelEl = document.getElementById('onboardingStateLabel');
    const cityLabelEl = document.getElementById('onboardingCityLabel');
    const stateInputEl = document.getElementById('onboardingStateProvince');
    const cityInputEl = document.getElementById('onboardingCity');
    
    if (locationLabelEl) {
      locationLabelEl.innerHTML = ONBOARDING_CONFIG.location.mainLabel + ' <span style="color: #ef4444;">' + ONBOARDING_CONFIG.location.required + '</span>';
    }
    if (countryLabelEl) countryLabelEl.textContent = ONBOARDING_CONFIG.location.country.label;
    if (stateLabelEl) stateLabelEl.textContent = ONBOARDING_CONFIG.location.stateProvince.label;
    if (cityLabelEl) cityLabelEl.textContent = ONBOARDING_CONFIG.location.city.label;
    if (stateInputEl) stateInputEl.placeholder = ONBOARDING_CONFIG.location.stateProvince.placeholder;
    if (cityInputEl) cityInputEl.placeholder = ONBOARDING_CONFIG.location.city.placeholder;
    
    // Update country dropdown
    const countrySelectEl = document.getElementById('onboardingCountry');
    if (countrySelectEl) {
      const placeholderEl = document.getElementById('onboardingCountryPlaceholder');
      if (placeholderEl) placeholderEl.textContent = ONBOARDING_CONFIG.location.country.placeholder;
      // Update option texts
      const usEl = document.getElementById('onboardingCountryUS');
      const canadaEl = document.getElementById('onboardingCountryCanada');
      const ukEl = document.getElementById('onboardingCountryUK');
      const ausEl = document.getElementById('onboardingCountryAustralia');
      const nzEl = document.getElementById('onboardingCountryNZ');
      const otherEl = document.getElementById('onboardingCountryOther');
      if (usEl) usEl.textContent = ONBOARDING_CONFIG.location.country.options.unitedStates;
      if (canadaEl) canadaEl.textContent = ONBOARDING_CONFIG.location.country.options.canada;
      if (ukEl) ukEl.textContent = ONBOARDING_CONFIG.location.country.options.unitedKingdom;
      if (ausEl) ausEl.textContent = ONBOARDING_CONFIG.location.country.options.australia;
      if (nzEl) nzEl.textContent = ONBOARDING_CONFIG.location.country.options.newZealand;
      if (otherEl) otherEl.textContent = ONBOARDING_CONFIG.location.country.options.other;
    }
    
    // Update job type section
    const jobTypeLabelEl = document.getElementById('onboardingJobTypeLabel');
    const jobTypeSelectEl = document.getElementById('onboardingJobType');
    if (jobTypeLabelEl) {
      jobTypeLabelEl.innerHTML = ONBOARDING_CONFIG.jobType.label + ' <span style="color: #ef4444;">' + ONBOARDING_CONFIG.jobType.required + '</span>';
    }
    if (jobTypeSelectEl) {
      const placeholderEl = document.getElementById('onboardingJobTypePlaceholder');
      if (placeholderEl) placeholderEl.textContent = ONBOARDING_CONFIG.jobType.placeholder;
      // Update option texts
      const fireEl = document.getElementById('onboardingJobTypeFire');
      const policeEl = document.getElementById('onboardingJobTypePolice');
      const paramedicEl = document.getElementById('onboardingJobTypeParamedic');
      const firstResponderEl = document.getElementById('onboardingJobTypeFirstResponder');
      const dispatcherEl = document.getElementById('onboardingJobTypeDispatcher');
      if (fireEl) fireEl.textContent = ONBOARDING_CONFIG.jobType.options.fire;
      if (policeEl) policeEl.textContent = ONBOARDING_CONFIG.jobType.options.police;
      if (paramedicEl) paramedicEl.textContent = ONBOARDING_CONFIG.jobType.options.paramedic;
      if (firstResponderEl) firstResponderEl.textContent = ONBOARDING_CONFIG.jobType.options.firstResponder;
      if (dispatcherEl) dispatcherEl.textContent = ONBOARDING_CONFIG.jobType.options.dispatcher;
    }
    
    // Update department section
    const deptLabelEl = document.getElementById('onboardingDepartmentLabel');
    const deptInputEl = document.getElementById('onboardingDepartmentName');
    const deptHelperEl = document.getElementById('onboardingDepartmentHelper');
    if (deptLabelEl) {
      deptLabelEl.innerHTML = ONBOARDING_CONFIG.department.label + ' <span style="color: #ef4444;">' + ONBOARDING_CONFIG.department.required + '</span>';
    }
    if (deptInputEl) deptInputEl.placeholder = ONBOARDING_CONFIG.department.placeholder;
    if (deptHelperEl) deptHelperEl.textContent = ONBOARDING_CONFIG.department.helperText;
    
    // Update name section
    const nameLabelEl = document.getElementById('onboardingNameLabel');
    const nameInputEl = document.getElementById('onboardingName');
    if (nameLabelEl) {
      nameLabelEl.innerHTML = ONBOARDING_CONFIG.name.label + ' <span style="color: #94a3b8; font-weight: 400;">' + ONBOARDING_CONFIG.name.optional + '</span>';
    }
    if (nameInputEl) {
      nameInputEl.placeholder = ONBOARDING_CONFIG.name.placeholder;
      const nameHelper = nameInputEl.nextElementSibling;
      if (nameHelper && nameHelper.tagName === 'P') {
        nameHelper.textContent = ONBOARDING_CONFIG.name.helperText;
      }
    }
    
    // Update voice section
    const voiceLabelEl = document.getElementById('onboardingVoiceLabel');
    const voiceSelectEl = document.getElementById('onboardingVoice');
    if (voiceLabelEl) {
      voiceLabelEl.innerHTML = ONBOARDING_CONFIG.voice.label + ' <span style="color: #94a3b8; font-weight: 400;">' + ONBOARDING_CONFIG.voice.optional + '</span>';
    }
    if (voiceSelectEl) {
      const defaultOpt = voiceSelectEl.querySelector('option[value=""]');
      const maleOpt = voiceSelectEl.querySelector('option[value="male"]');
      const femaleOpt = voiceSelectEl.querySelector('option[value="female"]');
      if (defaultOpt) defaultOpt.textContent = ONBOARDING_CONFIG.voice.options.default;
      if (maleOpt) maleOpt.textContent = ONBOARDING_CONFIG.voice.options.male;
      if (femaleOpt) femaleOpt.textContent = ONBOARDING_CONFIG.voice.options.female;
      const voiceHelper = voiceSelectEl.nextElementSibling;
      if (voiceHelper && voiceHelper.tagName === 'P') {
        voiceHelper.textContent = ONBOARDING_CONFIG.voice.helperText;
      }
    }
    
    // Update submit button
    const submitBtnEl = document.getElementById('onboardingSubmitBtn');
    if (submitBtnEl) submitBtnEl.textContent = ONBOARDING_CONFIG.submit.buttonText;
    
    // Update footer
    const requiredFieldsEl = document.getElementById('onboardingRequiredFields');
    if (requiredFieldsEl) {
      requiredFieldsEl.innerHTML = '<span style="color: #ef4444;">' + ONBOARDING_CONFIG.footer.requiredFields.split(' ')[0] + '</span> ' + ONBOARDING_CONFIG.footer.requiredFields.split(' ').slice(1).join(' ');
    }
  }
  
  // Load onboarding config on page load
  loadOnboardingConfig();
  
  // ========== ONBOARDING MODAL ==========
  const onboardingForm = document.getElementById("onboardingForm");
  const onboardingResumeInput = document.getElementById("onboardingResumeInput");
  const onboardingResumeStatus = document.getElementById("onboardingResumeStatus");
  
  // Check if onboarding is already complete (onboardingModal and mainApp already defined above)
  if (onboardingComplete) {
    // Load saved onboarding data
    const savedData = localStorage.getItem("onboardingData");
    if (savedData) {
      try {
        onboardingData = JSON.parse(savedData);
        console.log("Loaded onboarding data:", onboardingData);
      } catch (e) {
        console.error("Failed to parse saved onboarding data:", e);
      }
    }
    // Show main app if terms are accepted
    const termsAccepted = localStorage.getItem("termsAccepted") === "true";
    const privacyAccepted = localStorage.getItem("privacyAccepted") === "true";
    if (termsAccepted && privacyAccepted && mainApp) {
      mainApp.style.display = "block";
      // If resume was loaded during onboarding, display it
      if (resumeText && resumeText.length > 10 && resumeSummaryEl) {
        if (resumeAnalysis) {
          formatResumeSummary(resumeSummaryEl, resumeAnalysis, resumeText);
        } else {
          // Re-analyze if we have text but no analysis
          parseResumeWithAI(resumeText).catch(err => {
            console.error("Failed to re-analyze resume:", err);
            resumeSummaryEl.innerHTML = `<div style="color: #94a3b8; font-size: 0.9rem; padding: 20px;">üìÑ Resume loaded (${resumeText.length} characters). Analysis pending.</div>`;
          });
        }
      }
    }
  } else {
    // Show onboarding modal if terms are accepted but onboarding is not
    const termsAccepted = localStorage.getItem("termsAccepted") === "true";
    const privacyAccepted = localStorage.getItem("privacyAccepted") === "true";
    if (termsAccepted && privacyAccepted && onboardingModal) {
      onboardingModal.style.display = "flex";
      document.body.style.overflow = "hidden";
    }
  }
  
  // ========== LOCATION AUTCOMPLETE ==========
  const cityInput = document.getElementById("onboardingCity");
  const stateInput = document.getElementById("onboardingStateProvince");
  const countrySelect = document.getElementById("onboardingCountry");
  const citySuggestions = document.getElementById("citySuggestions");
  const stateSuggestions = document.getElementById("stateSuggestions");
  
  let citySearchTimeout = null;
  let stateSearchTimeout = null;
  
  // City autocomplete
  if (cityInput && citySuggestions) {
    cityInput.addEventListener("input", (e) => {
      const query = e.target.value.trim();
      
      // Clear previous timeout
      if (citySearchTimeout) {
        clearTimeout(citySearchTimeout);
      }
      
      // Hide suggestions if query is too short
      if (query.length < 2) {
        citySuggestions.style.display = "none";
        citySuggestions.innerHTML = "";
        return;
      }
      
      // Show loading state
      citySuggestions.style.display = "block";
      citySuggestions.innerHTML = '<div class="suggestion-loading">ü§ñ Searching cities...</div>';
      
      // Debounce search (increased to 500ms to reduce API calls)
      citySearchTimeout = setTimeout(async () => {
        try {
          const country = countrySelect ? countrySelect.value : "";
          const stateProvince = stateInput ? stateInput.value.trim() : "";
          const response = await fetch(`${BACKEND_URL}/api/search-location`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              query: query,
              type: "city",
              country: country || undefined,
              stateProvince: stateProvince || undefined
            })
          });
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('City search API error:', response.status, errorText);
            
            // Check if endpoint doesn't exist (404 or 405)
            if (response.status === 404 || response.status === 405) {
              throw new Error('Location search not available. Please type manually.');
            }
            
            throw new Error(`Search failed: ${response.status}`);
          }
          
          const data = await response.json();
          const suggestions = data.suggestions || [];
          
          if (suggestions.length === 0) {
            if (data.error) {
              console.error('Backend error:', data.error);
              citySuggestions.innerHTML = '<div class="suggestion-loading" style="color: #ef4444;">' + ONBOARDING_CONFIG.location.searchMessages.searchUnavailable + '</div>';
            } else {
              citySuggestions.innerHTML = '<div class="suggestion-loading">' + ONBOARDING_CONFIG.location.searchMessages.noCitiesFound + '</div>';
            }
            return;
          }
          
          // Render suggestions
          citySuggestions.innerHTML = suggestions.map(s => `
            <div class="suggestion-item" data-city="${s.name}" data-state="${s.stateProvince || ''}" data-country="${s.country || ''}">
              <div class="suggestion-main">${s.name}</div>
              <div class="suggestion-detail">${s.fullLocation || `${s.name}, ${s.stateProvince || ''}, ${s.country || ''}`}</div>
            </div>
          `).join("");
          
          // Add click handlers
          citySuggestions.querySelectorAll(".suggestion-item").forEach(item => {
            item.addEventListener("click", () => {
              const city = item.dataset.city;
              const state = item.dataset.state;
              const countryFromSuggestion = item.dataset.country;
              
              cityInput.value = city;
              citySuggestions.style.display = "none";
              
              // Auto-fill state/province if not already filled
              if (state && stateInput && !stateInput.value.trim()) {
                stateInput.value = state;
              }
              
              // Auto-fill country if not already selected
              if (countryFromSuggestion && countrySelect && !countrySelect.value) {
                countrySelect.value = countryFromSuggestion;
              }
            });
          });
        } catch (error) {
          console.error("City search error:", error);
          console.error("Error details:", {
            message: error.message,
            stack: error.stack,
            query: query,
            country: countrySelect ? countrySelect.value : "none"
          });
          
          // Check if it's a network error or endpoint not found
          if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
            citySuggestions.innerHTML = '<div class="suggestion-loading" style="color: #ef4444;">' + ONBOARDING_CONFIG.location.searchMessages.cannotConnect + '</div>';
          } else if (error.message.includes('not available')) {
            citySuggestions.innerHTML = '<div class="suggestion-loading" style="color: #fbbf24;">' + ONBOARDING_CONFIG.location.searchMessages.notAvailable + '</div>';
          } else {
            citySuggestions.innerHTML = '<div class="suggestion-loading" style="color: #ef4444;">' + ONBOARDING_CONFIG.location.searchMessages.searchUnavailable + '</div>';
          }
        }
      }, 500); // 500ms debounce to reduce API calls
    });
    
    // Hide suggestions when clicking outside
    document.addEventListener("click", (e) => {
      if (!cityInput.contains(e.target) && !citySuggestions.contains(e.target)) {
        citySuggestions.style.display = "none";
      }
    });
  }
  
  // State/Province autocomplete
  if (stateInput && stateSuggestions) {
    stateInput.addEventListener("input", (e) => {
      const query = e.target.value.trim();
      
      // Clear previous timeout
      if (stateSearchTimeout) {
        clearTimeout(stateSearchTimeout);
      }
      
      // Hide suggestions if query is too short
      if (query.length < 2) {
        stateSuggestions.style.display = "none";
        stateSuggestions.innerHTML = "";
        return;
      }
      
      // Show loading state
      stateSuggestions.style.display = "block";
      stateSuggestions.innerHTML = '<div class="suggestion-loading">ü§ñ Searching states/provinces...</div>';
      
      // Debounce search (increased to 500ms to reduce API calls)
      stateSearchTimeout = setTimeout(async () => {
        try {
          const country = countrySelect ? countrySelect.value : "";
          const response = await fetch(`${BACKEND_URL}/api/search-location`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              query: query,
              type: "state",
              country: country || undefined
            })
          });
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('State search API error:', response.status, errorText);
            
            // Check if endpoint doesn't exist (404 or 405)
            if (response.status === 404 || response.status === 405) {
              throw new Error('Location search not available. Please type manually.');
            }
            
            throw new Error(`Search failed: ${response.status}`);
          }
          
          const data = await response.json();
          const suggestions = data.suggestions || [];
          
          if (suggestions.length === 0) {
            if (data.error) {
              console.error('Backend error:', data.error);
              stateSuggestions.innerHTML = '<div class="suggestion-loading" style="color: #ef4444;">Search unavailable. Try typing manually.</div>';
            } else {
              stateSuggestions.innerHTML = '<div class="suggestion-loading">No states/provinces found</div>';
            }
            return;
          }
          
          // Render suggestions
          stateSuggestions.innerHTML = suggestions.map(s => `
            <div class="suggestion-item" data-state="${s.name}" data-country="${s.country || ''}">
              <div class="suggestion-main">${s.name}</div>
              <div class="suggestion-detail">${s.fullLocation || `${s.name}, ${s.country || ''}`}</div>
            </div>
          `).join("");
          
          // Add click handlers
          stateSuggestions.querySelectorAll(".suggestion-item").forEach(item => {
            item.addEventListener("click", () => {
              const state = item.dataset.state;
              const countryFromSuggestion = item.dataset.country;
              
              stateInput.value = state;
              stateSuggestions.style.display = "none";
              
              // Auto-fill country if not already selected
              if (countryFromSuggestion && countrySelect && !countrySelect.value) {
                countrySelect.value = countryFromSuggestion;
              }
            });
          });
        } catch (error) {
          console.error("State search error:", error);
          console.error("Error details:", {
            message: error.message,
            stack: error.stack,
            query: query,
            country: countrySelect ? countrySelect.value : "none"
          });
          
          // Check if it's a network error or endpoint not found
          if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
            stateSuggestions.innerHTML = '<div class="suggestion-loading" style="color: #ef4444;">Cannot connect to server. You can type manually.</div>';
          } else if (error.message.includes('not available')) {
            stateSuggestions.innerHTML = '<div class="suggestion-loading" style="color: #fbbf24;">Location search not available. Please type manually.</div>';
          } else {
            stateSuggestions.innerHTML = '<div class="suggestion-loading" style="color: #ef4444;">Search unavailable. Please type manually.</div>';
          }
        }
      }, 500); // 500ms debounce to reduce API calls
    });
    
    // Hide suggestions when clicking outside
    document.addEventListener("click", (e) => {
      if (!stateInput.contains(e.target) && !stateSuggestions.contains(e.target)) {
        stateSuggestions.style.display = "none";
      }
    });
  }
  
  // Handle resume upload in onboarding
  if (onboardingResumeInput) {
    onboardingResumeInput.addEventListener("change", async (event) => {
      const file = event.target.files[0];
      if (!file) return;
      
      onboardingResumeStatus.textContent = "Reading resume file...";
      onboardingResumeStatus.style.color = "#94a3b8";
      
      try {
        // Check if it's a PDF
        if (file.type === "application/pdf" || file.name.toLowerCase().endsWith(".pdf")) {
          if (typeof pdfjsLib === "undefined") {
            onboardingResumeStatus.textContent = "PDF.js library is loading... Please wait.";
            await new Promise(resolve => setTimeout(resolve, 1000));
            if (typeof pdfjsLib === "undefined") {
              onboardingResumeStatus.textContent = "PDF.js failed to load. Please refresh.";
              onboardingResumeStatus.style.color = "#ef4444";
              return;
            }
          }
          
          const arrayBuffer = await file.arrayBuffer();
          const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
          
          let fullText = "";
          for (let i = 1; i <= pdf.numPages; i++) {
            const page = await pdf.getPage(i);
            const textContent = await page.getTextContent();
            const pageText = textContent.items.map(item => item.str).join(" ");
            fullText += pageText + " ";
          }
          
          resumeText = fullText.replace(/\s+/g, " ").trim();
          
          if (!resumeText || resumeText.length < 10) {
            onboardingResumeStatus.textContent = "Could not extract text from PDF. Try a .txt file.";
            onboardingResumeStatus.style.color = "#ef4444";
            return;
          }
          
          onboardingResumeStatus.textContent = `‚úì Resume loaded (${resumeText.length} characters)`;
          onboardingResumeStatus.style.color = "#10b981";
        } else {
          // Text file
          const text = await file.text();
          resumeText = text.replace(/\s+/g, " ").trim();
          
          if (!resumeText || resumeText.length < 10) {
            onboardingResumeStatus.textContent = "Resume file appears to be empty.";
            onboardingResumeStatus.style.color = "#ef4444";
            return;
          }
          
          onboardingResumeStatus.textContent = `‚úì Resume loaded (${resumeText.length} characters)`;
          onboardingResumeStatus.style.color = "#10b981";
        }
        
        // Parse resume with AI if we have text
        if (resumeText && resumeText.length > 10) {
          onboardingResumeStatus.textContent = "ü§ñ Analyzing resume with AI...";
          try {
            const analysis = await parseResumeWithAI(resumeText);
            if (analysis) {
              resumeAnalysis = analysis;
              onboardingResumeStatus.textContent = `‚úì Resume analyzed successfully`;
            }
          } catch (e) {
            console.error("Resume analysis error:", e);
            onboardingResumeStatus.textContent = `‚úì Resume loaded (analysis skipped)`;
          }
        }
      } catch (error) {
        console.error("Resume upload error:", error);
        onboardingResumeStatus.textContent = "Error loading resume: " + error.message;
        onboardingResumeStatus.style.color = "#ef4444";
      }
    });
  }
  
  // Handle onboarding form submission
  if (onboardingForm) {
    onboardingForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      
      const country = document.getElementById("onboardingCountry").value;
      const stateProvince = document.getElementById("onboardingStateProvince").value;
      const city = document.getElementById("onboardingCity").value.trim();
      const jobType = document.getElementById("onboardingJobType").value;
      const departmentName = document.getElementById("onboardingDepartmentName").value.trim();
      const name = document.getElementById("onboardingName") ? document.getElementById("onboardingName").value.trim() : "";
      const voicePreference = document.getElementById("onboardingVoice") ? document.getElementById("onboardingVoice").value : "";
      
      // Validate required fields
      if (!country || !city || !jobType || !departmentName) {
        alert("Please fill in all required fields (marked with *)");
        return;
      }
      
      // Save onboarding data
      onboardingData = {
        country,
        stateProvince,
        city,
        jobType,
        departmentName,
        name: name || null,
        voicePreference: voicePreference || null,
        cityResearch: null // Will be populated by backend
      };
      
      localStorage.setItem("onboardingData", JSON.stringify(onboardingData));
      localStorage.setItem("onboardingComplete", "true");
      
      // Show loading state
      const submitBtn = document.getElementById("onboardingSubmitBtn");
      const originalText = submitBtn.textContent;
      submitBtn.textContent = "Researching city information...";
      submitBtn.disabled = true;
      
      try {
        // Call backend to research city information
        const response = await fetch(`${BACKEND_URL}/api/research-city`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            country,
            stateProvince,
            city,
            jobType,
            departmentName
          })
        });
        
        if (!response.ok) {
          throw new Error(`Backend error: ${response.status}`);
        }
        
        const data = await response.json();
        onboardingData.cityResearch = data.research;
        localStorage.setItem("onboardingData", JSON.stringify(onboardingData));
        
        // Set voice preference
        if (onboardingData.voicePreference) {
          selectedVoicePreference = onboardingData.voicePreference;
        }
        
        // Update user profile on backend with all onboarding data
        await updateUserProfile();
        
        console.log("City research completed:", data.research);
        
        // Hide onboarding modal and show main app
        if (onboardingModal) {
          onboardingModal.style.display = "none";
        }
        if (mainApp) {
          mainApp.style.display = "block";
        }
        document.body.style.overflow = "auto";
        
        // Resume will be processed by the main app when it loads
        // The resumeText and resumeAnalysis variables are already set
      } catch (error) {
        console.error("City research error:", error);
        // Still proceed even if research fails
        if (onboardingModal) {
          onboardingModal.style.display = "none";
        }
        if (mainApp) {
          mainApp.style.display = "block";
        }
        document.body.style.overflow = "auto";
        alert("Onboarding complete, but city research failed. You can still use the app.");
      } finally {
        submitBtn.textContent = originalText;
        submitBtn.disabled = false;
      }
    });
  }

  // ========== ONScreen CONSOLE ==========
  const debugConsole = document.getElementById("debugConsole");
  const consoleContent = document.getElementById("consoleContent");
  const showConsoleBtn = document.getElementById("showConsoleBtn");
  const toggleConsoleBtn = document.getElementById("toggleConsoleBtn");
  const clearConsoleBtn = document.getElementById("clearConsoleBtn");
  
  function logToConsole(message, type = "info") {
    if (!consoleContent) return;
    
    const timestamp = new Date().toLocaleTimeString();
    const colors = {
      info: "#93c5fd",
      error: "#fca5a5",
      warn: "#fbbf24",
      success: "#86efac"
    };
    const color = colors[type] || colors.info;
    
    const logEntry = document.createElement("div");
    logEntry.style.cssText = `margin-bottom: 4px; color: ${color}; word-break: break-word;`;
    logEntry.textContent = `[${timestamp}] ${message}`;
    
    consoleContent.appendChild(logEntry);
    consoleContent.scrollTop = consoleContent.scrollHeight;
    
    // Don't call console methods here - they're already being called by the override
  }
  
  if (showConsoleBtn) {
    showConsoleBtn.addEventListener("click", () => {
      if (debugConsole) {
        debugConsole.style.display = "block";
        showConsoleBtn.style.display = "none";
      }
    });
  }
  
  if (toggleConsoleBtn) {
    toggleConsoleBtn.addEventListener("click", () => {
      if (debugConsole) {
        debugConsole.style.display = "none";
        if (showConsoleBtn) showConsoleBtn.style.display = "flex";
      }
    });
  }
  
  if (clearConsoleBtn) {
    clearConsoleBtn.addEventListener("click", () => {
      if (consoleContent) {
        consoleContent.innerHTML = "";
      }
    });
  }
  
  // Override console methods to also log to onscreen console
  // Use a flag to prevent infinite recursion - call original first, then log
  let isLogging = false;
  
  if (consoleContent) {
    try {
      const originalLog = console.log.bind(console);
      const originalError = console.error.bind(console);
      const originalWarn = console.warn.bind(console);
      
      const safeStringify = (arg) => {
        if (typeof arg === 'object' && arg !== null) {
          try {
            return JSON.stringify(arg);
          } catch (e) {
            return String(arg);
          }
        }
        return String(arg);
      };
      
      console.log = function(...args) {
        originalLog(...args);
        if (!isLogging && consoleContent) {
          isLogging = true;
          try {
            logToConsole(args.map(safeStringify).join(" "), "info");
          } catch (e) {
            // Ignore
          }
          isLogging = false;
        }
      };
      
      console.error = function(...args) {
        originalError(...args);
        if (!isLogging && consoleContent) {
          isLogging = true;
          try {
            logToConsole(args.map(safeStringify).join(" "), "error");
          } catch (e) {
            // Ignore
          }
          isLogging = false;
        }
      };
      
      console.warn = function(...args) {
        originalWarn(...args);
        if (!isLogging && consoleContent) {
          isLogging = true;
          try {
            logToConsole(args.map(safeStringify).join(" "), "warn");
          } catch (e) {
            // Ignore
          }
          isLogging = false;
        }
      };
    } catch (err) {
      // If console override fails, just continue without it
      console.error("Console override failed:", err);
    }
  }

  // ========== API CONFIGURATION ==========
  // Backend API URL - automatically detects environment
  // For production: Update this to your Render backend URL (e.g., https://fire-interview-coach-api.onrender.com)
  const BACKEND_URL = (() => {
    const hostname = window.location.hostname;
    // Local development
    if (hostname === 'localhost' || hostname === '127.0.0.1') {
      return 'http://localhost:3001';
    }
    // Production - Backend URL
    return 'https://fire-interview-coach-api.onrender.com';
  })();
  
  // Always use backend service (API keys are hidden on the server)
  const USE_BACKEND = true;
  
  // Practice mode: "simulation" (random) or "specific" (category-based)
  let practiceMode = "simulation";
  let selectedCategory = "";
  
  // Initialize practice mode toggle listeners (run immediately, not on DOMContentLoaded)
  function initializePracticeModeToggle() {
    const simulationModeEl = document.getElementById("simulationMode");
    const specificModeEl = document.getElementById("specificMode");
    const categorySelectorEl = document.getElementById("categorySelector");
    const categorySelectEl = document.getElementById("categorySelect");
    
    if (simulationModeEl && specificModeEl) {
      simulationModeEl.addEventListener("change", () => {
        practiceMode = "simulation";
        if (categorySelectorEl) categorySelectorEl.style.display = "none";
        selectedCategory = "";
        if (categorySelectEl) categorySelectEl.value = "";
        console.log("Practice mode: Interview Simulation (Random)");
      });
      
      specificModeEl.addEventListener("change", () => {
        practiceMode = "specific";
        if (categorySelectorEl) {
          categorySelectorEl.style.display = "block";
          console.log("Category selector shown");
        }
        console.log("Practice mode: User-Specific Practice");
      });
    } else {
      console.warn("Practice mode toggle elements not found");
    }
    
    if (categorySelectEl) {
      categorySelectEl.addEventListener("change", () => {
        selectedCategory = categorySelectEl.value;
        console.log("Selected category:", selectedCategory || "All Categories");
      });
    } else {
      console.warn("Category select element not found");
    }
  }
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializePracticeModeToggle);
  } else {
    // DOM already loaded
    initializePracticeModeToggle();
  }

  // API configuration removed - always using backend service

  // ========== BASIC DATA & STATE ==========
  
  // Onboarding data
  let onboardingData = {
    country: "",
    stateProvince: "",
    city: "",
    jobType: "",
    departmentName: "",
    name: null,
    voicePreference: null,
    cityResearch: null // Will be populated by backend
  };
  
  // Voice preference for TTS
  let selectedVoicePreference = null;
  
  // Generate or retrieve session ID for user profile
  function getSessionId() {
    let sessionId = localStorage.getItem('userSessionId');
    if (!sessionId) {
      sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      localStorage.setItem('userSessionId', sessionId);
    }
    return sessionId;
  }
  
  // Update user profile on backend
  async function updateUserProfile() {
    const sessionId = getSessionId();
    try {
      await fetch(`${BACKEND_URL}/api/user-profile`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          sessionId: sessionId,
          name: onboardingData.name,
          city: onboardingData.city,
          stateProvince: onboardingData.stateProvince,
          country: onboardingData.country,
          departmentName: onboardingData.departmentName,
          jobType: onboardingData.jobType,
          voicePreference: onboardingData.voicePreference,
          resumeText: resumeText || null,
          resumeAnalysis: resumeAnalysis || null,
          cityResearch: onboardingData.cityResearch || null
        })
      });
    } catch (error) {
      console.error('Failed to update user profile:', error);
      // Non-critical, continue without profile update
    }
  }

  const questionBank = [
    {
      category: "Behavioural ‚Äì High Stress",
      template: "Tell me about a time you responded to a high-stress emergency. How did you keep scene control and communicate clearly with your team?",
      tags: ["stress", "communication", "teamwork"]
    },
    {
      category: "Behavioural ‚Äì Conflict",
      template: "Describe a situation where you disagreed with a decision from a senior firefighter, officer, or supervisor. How did you handle it?",
      tags: ["conflict", "professionalism", "chain of command"]
    },
    {
      category: "Safety & Accountability",
      template: "Tell me about a mistake you made on a call or during training. What did you do in the moment and what did you change afterwards?",
      tags: ["safety", "accountability", "learning"]
    },
    {
      category: "Medical / EMR",
      template: "Walk me through how you would approach a call for a patient in respiratory distress. Assume you‚Äôre responding as an EMR or first responder.",
      tags: ["medical", "EMR", "assessment"]
    },
    {
      category: "Teamwork",
      template: "Give me an example of when you had to rely heavily on your crew or teammates to get a task done safely.",
      tags: ["teamwork", "trust", "communication"]
    },
    {
      category: "Community Focus",
      template: "Why do you want to serve in this community specifically, and what have you already done that shows commitment to serving others?",
      tags: ["community", "motivation"]
    },
    {
      category: "Resilience",
      template: "Tell me about a time outside the fire service where you had to push through fatigue or setbacks to reach a goal.",
      tags: ["resilience", "fitness", "discipline"]
    },
    {
      category: "Technical ‚Äì Fireground",
      template: "Explain your approach when you arrive first on scene to a structure fire with smoke showing but no flames visible.",
      tags: ["size-up", "fireground", "command"]
    }
  ];

  const firefighterKeywords = [
    "firefighter", "fire service", "POC", "paid on call", "EMR", "first responder",
    "ICS", "incident command", "medical", "patient", "scene safety",
    "hoseline", "ladder", "SCBA", "BA", "RIT", "rapid intervention",
    "construction", "glazing", "windows", "leadership", "team lead",
    "training", "drill", "community", "volunteer", "rescue"
  ];

  let resumeText = "";
  let resumeKeywords = [];
  let resumeAnalysis = null; // AI-parsed resume data
  let currentQuestion = null;
  let questionCount = 0;
  let conversationHistory = []; // Track Q&A for context-aware followups
  let isFollowupQuestion = false; // Track if current question is a followup
  let askedQuestions = new Set(); // Track all asked questions (by text) to prevent duplicates
  let askedCategories = new Set(); // Track question categories to ensure diversity
  let resumeTopicsCovered = new Set(); // Track resume topics/questions covered

  let cameraStream = null;
  let motionCtx = null;
  let lastFrameData = null;
  let motionSamples = [];
  let motionIntervalId = null;

  let recognition = null;
  let recognizing = false;
  let liveTranscriptText = "";
  let lastAnswerTranscript = "";
  let motionScoreForAnswer = null;
  
  // ========== VOICE SELECTION ==========
  let selectedVoice = null;
  
  // Find and cache the best available voice
  function initializeVoice() {
    if (selectedVoice) return selectedVoice;
    
    const voices = window.speechSynthesis.getVoices();
    if (!voices || voices.length === 0) {
      // Voices might not be loaded yet, try again after a short delay
      setTimeout(() => {
        const voices = window.speechSynthesis.getVoices();
        if (voices && voices.length > 0) {
          selectedVoice = selectBestVoice(voices);
        }
      }, 100);
      return null;
    }
    
    selectedVoice = selectBestVoice(voices);
    return selectedVoice;
  }
  
  function selectBestVoice(voices) {
    // Prioritize premium/neural voices that sound most like ChatGPT (natural, conversational)
    const premiumVoices = [
      "Google US English", "Google UK English", "Microsoft Zira", "Microsoft David",
      "Samantha", "Alex", "Victoria", "Daniel", "Karen", "Microsoft Mark", "Microsoft Hazel",
      "Alloy", "Echo", "Fable", "Onyx", "Nova", "Shimmer" // OpenAI-style names
    ];
    
    // First, try premium voices (most natural)
    for (const premium of premiumVoices) {
      const voice = voices.find(v => {
        const name = v.name.toLowerCase();
        return name.includes(premium.toLowerCase()) || 
               name.includes("neural") ||
               name.includes("premium") ||
               (premium === "Google US English" && (name.includes("google") && name.includes("us"))) ||
               (premium === "Google UK English" && (name.includes("google") && name.includes("uk")));
      });
      if (voice && voice.lang.startsWith("en")) {
        return voice;
      }
    }
    
    // Try to find voices that sound conversational (not robotic)
    const conversationalVoices = voices.filter(v => {
      const name = v.name.toLowerCase();
      return v.lang.startsWith("en") && 
             !name.includes("novelty") &&
             !name.includes("compact") &&
             !name.includes("robotic") &&
             (name.includes("female") || 
              name.includes("zira") || 
              name.includes("samantha") || 
              name.includes("victoria") ||
              name.includes("alex") ||
              name.includes("daniel") ||
              name.includes("karen"));
    });
    
    if (conversationalVoices.length > 0) {
      return conversationalVoices[0];
    }
    
    // Fallback: any English voice
    const englishVoices = voices.filter(v => 
      v.lang.startsWith("en") && 
      !v.name.toLowerCase().includes("novelty") &&
      !v.name.toLowerCase().includes("compact")
    );
    
    if (englishVoices.length > 0) {
      return englishVoices[0];
    }
    
    // Last resort: any voice
    return voices[0] || null;
  }
  
  // Load voices when they become available
  if (window.speechSynthesis) {
    window.speechSynthesis.onvoiceschanged = () => {
      initializeVoice();
    };
    // Try to initialize immediately
    initializeVoice();
  }

  // ========== RESUME HANDLING ==========

  const resumeInput = document.getElementById("resumeInput");
  const resumeSummaryEl = document.getElementById("resumeSummary");
  const resumeTagsEl = document.getElementById("resumeTags");
  const clearResumeBtn = document.getElementById("clearResumeBtn");

  resumeInput.addEventListener("change", handleResumeUpload);
  clearResumeBtn.addEventListener("click", () => {
    resumeInput.value = "";
    resumeText = "";
    resumeKeywords = [];
    resumeSummaryEl.textContent =
      "No resume loaded yet. Upload a file to extract keywords like ‚ÄúPOC firefighter‚Äù, ‚ÄúEMR‚Äù, ‚Äúconstruction‚Äù, etc.";
    resumeTagsEl.innerHTML = "";
  });

  async function handleResumeUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    resumeSummaryEl.textContent = "Reading resume file...";

    // Check if it's a PDF
    if (file.type === "application/pdf" || file.name.toLowerCase().endsWith(".pdf")) {
      try {
        // Check if PDF.js is loaded
        if (typeof pdfjsLib === "undefined") {
          resumeSummaryEl.textContent = "PDF.js library is loading... Please wait a moment and try again.";
          // Wait a bit and retry
          await new Promise(resolve => setTimeout(resolve, 1000));
          if (typeof pdfjsLib === "undefined") {
            resumeSummaryEl.textContent = "PDF.js failed to load. Please refresh the page or convert your PDF to .txt format.";
            return;
          }
        }
        
        // Use PDF.js to extract text from PDF
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        
        let fullText = "";
        // Extract text from all pages
        for (let i = 1; i <= pdf.numPages; i++) {
          const page = await pdf.getPage(i);
          const textContent = await page.getTextContent();
          const pageText = textContent.items.map(item => item.str).join(" ");
          fullText += pageText + " ";
        }
        
        resumeText = fullText.replace(/\s+/g, " ").trim();
        
        if (!resumeText || resumeText.length < 10) {
          resumeSummaryEl.textContent =
            "Could not extract text from PDF. The PDF might be image-based or corrupted. Try exporting as .txt or .docx.";
          return;
        }
        
        // Show loading state
        resumeSummaryEl.innerHTML = '<div style="text-align: center; color: #94a3b8; padding: 20px;">üìÑ Resume loaded. Analyzing...</div>';
        resumeKeywords = extractResumeKeywords(resumeText);
        renderResumeTags();
        
        // AI-powered resume analysis
        // Always use backend for AI analysis
        resumeSummaryEl.innerHTML = '<div style="text-align: center; color: #94a3b8; padding: 20px;">ü§ñ Analyzing resume with AI...</div>';
        await parseResumeWithAI(resumeText);
      } catch (err) {
        console.error("PDF parsing error:", err);
        resumeSummaryEl.textContent =
          "Error reading PDF. Try converting to .txt or .docx format, or ensure the PDF contains selectable text (not just images).";
      }
    } else {
      // Handle text files (txt, doc, etc.)
      const reader = new FileReader();
      reader.onload = async (e) => {
        resumeText = String(e.target.result || "").replace(/\s+/g, " ").trim();
        if (!resumeText) {
          resumeSummaryEl.textContent =
            "Could not read text from this file. Try exporting your resume as .txt or .pdf.";
          return;
        }

        // Show loading state
        resumeSummaryEl.innerHTML = '<div style="text-align: center; color: #94a3b8; padding: 20px;">üìÑ Resume loaded. Analyzing...</div>';
        resumeKeywords = extractResumeKeywords(resumeText);
        renderResumeTags();
        
        // AI-powered resume analysis
        // Always use backend for AI analysis
        resumeSummaryEl.innerHTML = '<div style="text-align: center; color: #94a3b8; padding: 20px;">ü§ñ Analyzing resume with AI...</div>';
        await parseResumeWithAI(resumeText);
      };

      reader.readAsText(file);
    }
  }
  
  // Format resume summary with clean, structured display
  function formatResumeSummary(element, analysis, rawText) {
    if (!element) return;
    
    if (analysis) {
      // Use AI analysis for clean summary
      const experience = analysis.experience || analysis.yearsOfExperience || "Not specified";
      const certifications = Array.isArray(analysis.certifications) ? analysis.certifications : [];
      const skills = Array.isArray(analysis.skills) ? analysis.skills : [];
      const workHistory = Array.isArray(analysis.workHistory) ? analysis.workHistory : [];
      const achievements = Array.isArray(analysis.achievements) ? analysis.achievements : [];
      const focusAreas = Array.isArray(analysis.interviewFocus) ? analysis.interviewFocus : [];
      
      let html = '<div style="color: #e2e8f0;">';
      
      // Experience
      html += `<div style="margin-bottom: 12px;">
        <div style="color: #fca5a5; font-weight: 600; font-size: 0.85rem; margin-bottom: 4px;">üìä Experience</div>
        <div style="color: #cbd5e1; font-size: 0.9rem;">${experience}</div>
      </div>`;
      
      // Certifications
      if (certifications.length > 0) {
        html += `<div style="margin-bottom: 12px;">
          <div style="color: #fca5a5; font-weight: 600; font-size: 0.85rem; margin-bottom: 4px;">üèÜ Certifications</div>
          <div style="color: #cbd5e1; font-size: 0.9rem;">${certifications.join(" ‚Ä¢ ")}</div>
        </div>`;
      }
      
      // Key Skills
      if (skills.length > 0) {
        html += `<div style="margin-bottom: 12px;">
          <div style="color: #fca5a5; font-weight: 600; font-size: 0.85rem; margin-bottom: 4px;">üíº Key Skills</div>
          <div style="color: #cbd5e1; font-size: 0.9rem;">${skills.slice(0, 6).join(" ‚Ä¢ ")}${skills.length > 6 ? "..." : ""}</div>
        </div>`;
      }
      
      // Interview Focus Areas
      if (focusAreas.length > 0) {
        html += `<div style="margin-bottom: 12px;">
          <div style="color: #fca5a5; font-weight: 600; font-size: 0.85rem; margin-bottom: 4px;">üéØ Interview Focus</div>
          <div style="color: #cbd5e1; font-size: 0.9rem;">${focusAreas.slice(0, 4).join(" ‚Ä¢ ")}</div>
        </div>`;
      }
      
      html += '</div>';
      element.innerHTML = html;
    } else if (rawText) {
      // Fallback: show basic info from raw text
      const preview = rawText.slice(0, 200).replace(/\s+/g, " ").trim();
      element.innerHTML = `<div style="color: #cbd5e1; font-size: 0.9rem; line-height: 1.6;">
        <div style="color: #fca5a5; font-weight: 600; margin-bottom: 8px;">üìÑ Resume Loaded</div>
        <div>${preview}${rawText.length > 200 ? "..." : ""}</div>
        <div style="margin-top: 8px; color: #94a3b8; font-size: 0.85rem;">Enable AI analysis for detailed summary</div>
      </div>`;
    } else {
      element.innerHTML = '<div style="color: #94a3b8; font-size: 0.9rem; text-align: center; padding: 20px;">No resume loaded yet.</div>';
    }
  }

  async function parseResumeWithAI(text) {
    // Always use backend
    try {
      console.log("[RESUME] Starting resume parsing, text length:", text ? text.length : 0);
      const response = await fetch(`${BACKEND_URL}/api/parse-resume`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ resumeText: text })
      });
      
      console.log("[RESUME] Backend response status:", response.status);
      
      if (response.ok) {
        const data = await response.json();
        console.log("[RESUME] Received analysis data:", data);
        resumeAnalysis = data.analysis;
        formatResumeSummary(resumeSummaryEl, resumeAnalysis, resumeText);
        
        // Update user profile with resume analysis
        await updateUserProfile();
        
        return;
      } else {
        const errorText = await response.text();
        console.error("[RESUME] Backend error response:", response.status, errorText);
        throw new Error(`Backend error: ${response.status} - ${errorText}`);
      }
    } catch (err) {
      console.error("[RESUME] Resume parsing error:", err);
      console.error("[RESUME] Error details:", {
        message: err.message,
        stack: err.stack,
        name: err.name
      });
      
      // Show user-friendly error message
      if (resumeSummaryEl) {
        resumeSummaryEl.innerHTML = `
          <div style="color: #fca5a5; padding: 16px; background: rgba(239, 68, 68, 0.1); border-radius: 8px; border: 1px solid rgba(239, 68, 68, 0.3);">
            <div style="font-weight: 600; margin-bottom: 8px;">‚ö†Ô∏è Resume Analysis Failed</div>
            <div style="font-size: 0.9rem; color: #cbd5e1;">
              ${err.message || "Unable to analyze resume. Please check your connection and try again."}
            </div>
            <div style="margin-top: 12px; font-size: 0.85rem; color: #94a3b8;">
              You can still use the app - questions will be generated without resume context.
            </div>
          </div>
        `;
      }
      
      // Fallback: show raw resume text
      formatResumeSummary(resumeSummaryEl, null, resumeText);
    }
  }

  function extractResumeKeywords(text) {
    const lower = text.toLowerCase();
    const counts = {};

    firefighterKeywords.forEach((k) => {
      const regex = new RegExp("\\b" + escapeRegExp(k.toLowerCase()) + "\\b", "g");
      const matches = lower.match(regex);
      if (matches && matches.length > 0) {
        counts[k] = matches.length;
      }
    });

    const extraPatterns = [
      "captain",
      "officer",
      "volunteer",
      "paramedic",
      "wildland",
      "responder",
      "crew",
      "team lead"
    ];
    extraPatterns.forEach((k) => {
      const regex = new RegExp("\\b" + escapeRegExp(k.toLowerCase()) + "\\b", "g");
      const matches = lower.match(regex);
      if (matches && matches.length > 0) {
        counts[k] = (counts[k] || 0) + matches.length;
      }
    });

    return Object.entries(counts)
      .sort((a, b) => b[1] - a[1])
      .map(([word, count]) => ({ word, count }));
  }

  function renderResumeTags() {
    resumeTagsEl.innerHTML = "";
    if (!resumeKeywords.length) {
      const span = document.createElement("span");
      span.className = "tag";
      span.textContent = "No firefighter-specific keywords detected yet.";
      resumeTagsEl.appendChild(span);
      return;
    }
    resumeKeywords.slice(0, 10).forEach((k) => {
      const span = document.createElement("span");
      span.className = "tag";
      span.textContent = `${k.word} √ó${k.count}`;
      resumeTagsEl.appendChild(span);
    });
  }

  // ========== QUESTION SELECTION & TTS ==========

  const nextQuestionBtn = document.getElementById("nextQuestionBtn");
  const repeatQuestionBtn = document.getElementById("repeatQuestionBtn");
  const questionTextEl = document.getElementById("questionText");
  const questionCategoryLabelEl = document.getElementById("questionCategoryLabel");
  const questionIndexEl = document.getElementById("questionIndex");

  nextQuestionBtn.addEventListener("click", async () => {
    nextQuestionBtn.disabled = true;
    nextQuestionBtn.textContent = APP_CONFIG ? APP_CONFIG.status.generatingQuestion : "ü§ñ Generating question...";
      try {
        currentQuestion = await generateAIQuestion();
        if (currentQuestion) {
          questionCount++;
          isFollowupQuestion = false;
          
          // Track asked questions to prevent duplicates
          const questionText = currentQuestion.template.toLowerCase().trim();
          askedQuestions.add(questionText);
          if (currentQuestion.category) {
            askedCategories.add(currentQuestion.category.toLowerCase());
          }
          
          renderQuestion(currentQuestion);
          speakQuestionWithCaptions(currentQuestion.template);
          // Auto-start recording based on the user's Next Question click (browser-friendly)
          startAnswerRecording(true);
        }
    } catch (err) {
      console.error("Question generation error:", err);
      // Fallback to static question
      currentQuestion = questionBank[questionCount % questionBank.length];
      questionCount++;
      renderQuestion(currentQuestion);
      speakQuestionWithCaptions(currentQuestion.template);
      // Auto-start recording even when we fall back to a static question
      startAnswerRecording(true);
    } finally {
      nextQuestionBtn.disabled = false;
      nextQuestionBtn.textContent = APP_CONFIG ? APP_CONFIG.buttons.nextQuestion : "üé§ Next Question";
    }
  });

  repeatQuestionBtn.addEventListener("click", () => {
    if (currentQuestion) speakQuestionWithCaptions(currentQuestion.template);
  });

  async function generateAIQuestion() {
    // ALWAYS generate a NEW, unrelated question (not a follow-up)
    // Follow-ups are only generated by the "Ask Followup Question" button
    
    // Use backend if enabled
    // Always use backend
    {
      try {
        const allAskedQuestions = Array.from(askedQuestions);
        const askedCategoriesList = Array.from(askedCategories);
        
        const response = await fetch(`${BACKEND_URL}/api/question`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            sessionId: getSessionId(),
            resumeText: resumeText,
            resumeAnalysis: resumeAnalysis,
            history: conversationHistory,
            askedQuestions: allAskedQuestions,
            askedCategories: askedCategoriesList,
            practiceMode: practiceMode,
            selectedCategory: selectedCategory,
            onboardingData: onboardingData,
            questionType: document.getElementById('questionTypeSelect')?.value || null,
            difficulty: document.getElementById('difficultySelect')?.value || null,
            useQuestionBank: true
          })
        });
        
        if (!response.ok) {
          throw new Error(`Backend error: ${response.status}`);
        }
        
        const data = await response.json();
        return {
          category: data.category,
          template: data.template,
          tags: data.tags || [],
          isAI: true,
          isFollowup: false
        };
      } catch (err) {
        console.error("Backend question generation error:", err);
        // Fall through to local/fallback
      }
    }
    
    // Always use backend - no local fallback needed
    try {
      const resumeContext = resumeAnalysis 
        ? `Resume Analysis: ${JSON.stringify(resumeAnalysis)}`
        : resumeText 
          ? `Resume Text (first 2000 chars): ${resumeText.slice(0, 2000)}`
          : "No resume provided";
      
      const conversationContext = conversationHistory.length > 0
        ? `\n\nPrevious questions asked:\n${conversationHistory.slice(-3).map((item, i) => 
            `${i + 1}. Q: ${item.question}\n   A: ${item.answer ? item.answer.slice(0, 200) + "..." : "No answer yet"}`
          ).join("\n")}`
        : "";

      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer " + "REMOVED" // Always use backend instead
        },
        body: JSON.stringify({
          model: "gpt-4o-mini",
          messages: [
            {
              role: "system",
              content: "You are an expert firefighter interview panel member. Generate realistic, challenging interview questions that test behavioral competencies, technical knowledge, and situational judgment. Focus on GENERAL, OPEN-ENDED situational questions that any firefighter candidate might face, similar to: 'How would you handle a situation if you felt you weren't treated fairly?' or 'How would you handle a leader where you question their leadership, would you still respect them?' Keep questions broad and applicable to all candidates, not overly specific to their resume. The questions should test judgment, ethics, chain of command, and decision-making in hypothetical scenarios. CRITICAL: Ensure questions are UNIQUE and cover diverse topics/areas. Vary the categories and themes to provide comprehensive coverage of different firefighter competencies. If a resume is provided, occasionally reference different aspects of their background (certifications, experience, skills) but keep questions general enough for all candidates."
            },
            {
              role: "user",
              content: `Generate a single firefighter interview question. Focus on GENERAL, OPEN-ENDED situational questions that test judgment, ethics, and decision-making.

${resumeContext}${conversationContext}${diversityContext}

Requirements:
- Question should be a GENERAL situational/hypothetical question (like "How would you handle a situation if...")
- Keep it broad and applicable to all candidates, not overly specific to their resume
- Examples of good questions:
  * "How would you handle a situation if you felt you weren't treated fairly?"
  * "How would you handle a leader where you question their leadership, would you still respect them?"
  * "Your Captain orders you to get a radio from the engine. On the way a senior fire officer stops you and asks you to deliver an axe to the team on the roof right away. How would you handle this?"
- Test: chain of command, ethics, judgment, decision-making, conflict resolution
- CRITICAL: The question MUST be completely different from any question already asked (see list above)
- Ensure diversity: Cover different topics and areas. If many questions have been asked, explore new categories/topics. Vary between: chain of command, ethics, conflict resolution, safety, teamwork, leadership, decision-making, communication, stress management, equipment, training, etc.
- If resume is provided, occasionally reference different aspects of their background (certifications, experience, skills) but keep questions general enough for all candidates
- Rotate through different question types: hypothetical scenarios, ethical dilemmas, chain of command situations, team dynamics, safety protocols, etc.
- Make it challenging but fair
- Format: "Category: [category]\nQuestion: [question text]"

Return ONLY the category and question in that format.`
            }
          ]
        })
      });

      const data = await response.json();
      if (data.choices && data.choices[0] && data.choices[0].message) {
        const content = data.choices[0].message.content;
        const categoryMatch = content.match(/Category:\s*(.+)/i);
        const questionMatch = content.match(/Question:\s*(.+)/is);
        
        const category = categoryMatch ? categoryMatch[1].trim() : "General";
        let question = questionMatch ? questionMatch[1].trim() : content.trim();
        
        // Check for duplicates - if question was already asked, try generating again (max 3 attempts)
        const questionTextLower = question.toLowerCase().trim();
        let attempts = 0;
        while (askedQuestions.has(questionTextLower) && attempts < 3) {
          console.log(`Duplicate question detected, regenerating... (attempt ${attempts + 1})`);
          // Make another API call with stronger emphasis on uniqueness
          const retryResponse = await fetch("https://api.openai.com/v1/chat/completions", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": "Bearer REMOVED" // Always use backend instead
            },
            body: JSON.stringify({
              model: "gpt-4o-mini",
              messages: [
                {
                  role: "system",
                  content: "You are an expert firefighter interview panel member. Generate realistic, challenging interview questions that test behavioral competencies, technical knowledge, and situational judgment. Focus on GENERAL, OPEN-ENDED situational questions that any firefighter candidate might face. Ensure questions are UNIQUE and cover diverse topics."
                },
                {
                  role: "user",
                  content: `Generate a UNIQUE firefighter interview question that is COMPLETELY DIFFERENT from these already asked questions:

${Array.from(askedQuestions).map((q, i) => `${i + 1}. ${q}`).join("\n")}

Categories already covered: ${Array.from(askedCategories).join(", ") || "None"}

${resumeContext}

Requirements:
- MUST be completely different from all questions above
- Cover a NEW topic/area if possible
- General situational/hypothetical question
- Test: chain of command, ethics, judgment, decision-making, conflict resolution
- Format: "Category: [category]\nQuestion: [question text]"

Return ONLY the category and question.`
                }
              ]
            })
          });
          
          const retryData = await retryResponse.json();
          if (retryData.choices && retryData.choices[0] && retryData.choices[0].message) {
            const retryContent = retryData.choices[0].message.content;
            const retryCategoryMatch = retryContent.match(/Category:\s*(.+)/i);
            const retryQuestionMatch = retryContent.match(/Question:\s*(.+)/is);
            question = retryQuestionMatch ? retryQuestionMatch[1].trim() : retryContent.trim();
            const newQuestionTextLower = question.toLowerCase().trim();
            if (!askedQuestions.has(newQuestionTextLower)) {
              break; // Found unique question
            }
          }
          attempts++;
        }
        
        // Final check - if still duplicate, use fallback
        const finalQuestionTextLower = question.toLowerCase().trim();
        if (askedQuestions.has(finalQuestionTextLower)) {
          console.warn("Could not generate unique question after retries, using fallback");
          // Find a question from bank that hasn't been asked
          const unusedQuestions = questionBank.filter(q => {
            const qText = q.template.toLowerCase().trim();
            return !askedQuestions.has(qText);
          });
          if (unusedQuestions.length > 0) {
            const fallbackQ = unusedQuestions[Math.floor(Math.random() * unusedQuestions.length)];
            return {
              template: fallbackQ.template,
              category: fallbackQ.category || category,
              isAI: false,
              isFollowup: false
            };
          }
        }
        
        return {
          category: category,
          template: question,
          tags: [],
          isAI: true
        };
      }
    } catch (err) {
      console.error("AI question generation error:", err);
      throw err;
    }
    
    // Fallback
    return questionBank[questionCount % questionBank.length];
  }

  async function generateFollowupQuestion() {
    const lastQA = conversationHistory[conversationHistory.length - 1];
    if (!lastQA || !lastQA.answer) {
      return await generateAIQuestion();
    }

    // Use backend if enabled
    // Always use backend
    {
      try {
        const response = await fetch(`${BACKEND_URL}/api/followup`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            lastQuestion: lastQA.question,
            lastAnswer: lastQA.answer,
            history: conversationHistory
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          isFollowupQuestion = true;
          return {
            category: data.category,
            template: data.template,
            tags: data.tags || [],
            isAI: true,
            isFollowup: true
          };
        }
      } catch (err) {
        console.error("Backend followup error:", err);
        // Fall through to local
      }
    }

    // Always use backend - no local fallback
    // This code path should not be reached
    return questionBank[questionCount % questionBank.length];

    try {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer " + "REMOVED" // Always use backend instead
        },
        body: JSON.stringify({
          model: "gpt-4o-mini",
          messages: [
            {
              role: "system",
              content: "You are an expert firefighter interview panel member. Generate a followup question that digs deeper into the candidate's answer, just like a real panel would. Ask for clarification, more detail, or explore a related aspect."
            },
            {
              role: "user",
              content: `The candidate was asked: "${lastQA.question}"

Their answer: "${lastQA.answer.slice(0, 1000)}"

Generate a followup question that:
- Probes deeper into their answer
- Asks for specific examples or clarification
- Tests their knowledge or judgment further
- Is what a real firefighter panel would ask next

Format: "Category: [category]\nQuestion: [question text]"

Return ONLY the category and question.`
            }
          ]
        })
      });

      const data = await response.json();
      if (data.choices && data.choices[0] && data.choices[0].message) {
        const content = data.choices[0].message.content;
        const categoryMatch = content.match(/Category:\s*(.+)/i);
        const questionMatch = content.match(/Question:\s*(.+)/is);
        
        const category = categoryMatch ? categoryMatch[1].trim() : "Followup";
        const question = questionMatch ? questionMatch[1].trim() : content.trim();
        
        isFollowupQuestion = true;
        return {
          category: category,
          template: question,
          tags: [],
          isAI: true,
          isFollowup: true
        };
      }
    } catch (err) {
      console.error("Followup question generation error:", err);
    }
    
    // Fallback
    return questionBank[questionCount % questionBank.length];
  }

  function renderQuestion(q) {
    questionTextEl.textContent = q.template;
    const categoryLabel = q.isFollowup ? `(Followup - ${q.category})` : `(${q.category})`;
    questionCategoryLabelEl.textContent = categoryLabel;
    questionIndexEl.textContent = String(questionCount);
  }

  async function speakQuestionWithCaptions(text) {
    const subtitleEl = document.getElementById("questionSubtitles");
    
    // Show subtitle area (will be updated during speech)
    if (subtitleEl) {
      subtitleEl.style.display = "block";
      // Don't set textContent here - let TTS function update it during speech
    }

    // Use OpenAI TTS if backend is enabled (high quality, natural voice)
    // Always use backend
    {
      console.log("Using backend OpenAI TTS...");
      try {
        await speakWithOpenAITTS(text, subtitleEl);
        console.log("OpenAI TTS completed successfully");
        return;
      } catch (err) {
        console.error("OpenAI TTS error:", err.message || err);
        console.log("Falling back to browser TTS");
        // Fall through to browser TTS as fallback
      }
    }
    
    // Fallback to browser TTS
    if (!window.speechSynthesis) {
      // No TTS available
      return;
    }
    
    window.speechSynthesis.cancel();
    
    // Ensure we have the best voice selected
    let voice = initializeVoice();
    
    // If voice not loaded yet, try to get it from available voices
    if (!voice && window.speechSynthesis) {
      const voices = window.speechSynthesis.getVoices();
      if (voices && voices.length > 0) {
        voice = selectBestVoice(voices);
        selectedVoice = voice; // Cache it
      }
    }
    
    const utterance = new SpeechSynthesisUtterance(text);
    
    // Use the selected voice if available
    if (voice) {
      utterance.voice = voice;
      utterance.lang = voice.lang;
    } else {
      utterance.lang = "en-US";
    }
    
    // Optimized parameters for ChatGPT-like natural, conversational speech
    utterance.rate = 0.88;  // Slightly slower for natural conversation pace
    utterance.pitch = 1.0;  // Neutral pitch (most natural, like ChatGPT)
    utterance.volume = 1.0;  // Full volume
    
    // Word-by-word highlighting for live captions
    const words = text.split(/\s+/);
    let currentWordIndex = 0;
    
    utterance.onboundary = (event) => {
      if (event.name === 'word' && subtitleEl) {
        const spokenWords = words.slice(0, currentWordIndex + 1).join(" ");
        const remainingWords = words.slice(currentWordIndex + 1).join(" ");
        subtitleEl.innerHTML = `<span style="color: #fbbf24;">${spokenWords}</span> <span style="color: #64748b;">${remainingWords}</span>`;
        currentWordIndex++;
      }
    };
    
    utterance.onend = () => {
      if (subtitleEl) {
        // Hide subtitle when done - question is already displayed in questionText
        subtitleEl.style.display = "none";
      }
    };
    
    window.speechSynthesis.speak(utterance);
  }
  
  // OpenAI TTS function (high quality, natural voice)
  async function speakWithOpenAITTS(text, subtitleEl) {
    const voice = "alloy"; // Options: alloy, echo, fable, onyx, nova, shimmer
    
    // Use backend (OpenAI TTS is always via backend)
    try {
      console.log(`Calling backend OpenAI TTS at ${BACKEND_URL}/api/tts`);
      const response = await fetch(`${BACKEND_URL}/api/tts`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ 
          text,
          voicePreference: selectedVoicePreference || onboardingData?.voicePreference || null
        })
      });
      
      console.log(`Backend TTS response status: ${response.status}`);
      
      if (response.ok) {
        const audioBlob = await response.blob();
        console.log(`Received audio blob, size: ${audioBlob.size} bytes`);
        
        if (audioBlob.size === 0) {
          throw new Error("Received empty audio blob from backend");
        }
        
        const audioUrl = URL.createObjectURL(audioBlob);
        const audio = new Audio(audioUrl);
        
        // Update subtitle during speech (word-by-word highlighting will happen via audio events)
        if (subtitleEl) {
          subtitleEl.innerHTML = `<span style="color: #fbbf24;">Speaking...</span>`;
        }
        
          return new Promise((resolve, reject) => {
            // Handle user interaction requirement for audio playback
            const playAudio = () => {
              audio.play().then(() => {
                console.log("Audio playback started");
              }).catch(err => {
                console.error("Audio play() error:", err);
                // If autoplay is blocked, show subtitle and resolve (audio will play when user interacts)
                if (err.name === 'NotAllowedError' || err.message.includes('user agent')) {
                  console.warn("Audio autoplay blocked - user interaction required");
                  if (subtitleEl) {
                    subtitleEl.innerHTML = `<span style="color: #fbbf24;">${text}</span><br><small style="color: #94a3b8;">Click anywhere to play audio</small>`;
                  }
                  // Set up click handler to play audio
                  const clickHandler = () => {
                    audio.play().then(() => {
                      document.removeEventListener('click', clickHandler);
                    }).catch(reject);
                  };
                  document.addEventListener('click', clickHandler, { once: true });
                  resolve(); // Resolve immediately so UI doesn't hang
                  return;
                }
                reject(err);
              });
            };
            
            audio.onended = () => {
              URL.revokeObjectURL(audioUrl);
              // Hide subtitle when audio ends - question is already displayed in questionText
              if (subtitleEl) {
                subtitleEl.style.display = "none";
              }
              resolve();
            };
            audio.onerror = (e) => {
              console.error("Audio playback error:", e);
              reject(new Error("Audio playback failed"));
            };
            audio.oncanplaythrough = () => {
              playAudio();
            };
            audio.onloadeddata = () => {
              // Try to play as soon as data is loaded
              if (audio.readyState >= 2) {
                playAudio();
              }
            };
            audio.load();
          });
      } else {
        const errorText = await response.text().catch(() => `Status ${response.status}`);
        console.error(`Backend TTS failed: ${response.status}`, errorText);
        throw new Error(`TTS failed: ${response.status} - ${errorText}`);
      }
    } catch (err) {
      console.error("Backend TTS error:", err);
      console.error("Error message:", err.message);
      throw err; // Re-throw to fall back to browser TTS
    }
  }
  
  // Keep old function for backwards compatibility
  function speakQuestion(text) {
    speakQuestionWithCaptions(text);
  }

  // ========== CAMERA & MOTION TRACKING ==========

  const cameraBtn = document.getElementById("cameraBtn");
  const videoEl = document.getElementById("camera");
  const motionCanvas = document.getElementById("motionCanvas");
  const motionScoreEl = document.getElementById("motionScore");

  cameraBtn.addEventListener("click", async () => {
    if (cameraStream) {
      stopCamera();
      return;
    }
    await startCamera();
  });

  async function startCamera() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      alert("getUserMedia not supported. Try Chrome on https/localhost.");
      return;
    }
    try {
      cameraStream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: false
      });
      videoEl.srcObject = cameraStream;
      cameraBtn.textContent = "‚èπ Stop Camera";

      motionCanvas.width = videoEl.clientWidth || 640;
      motionCanvas.height = videoEl.clientHeight || 480;
      motionCtx = motionCanvas.getContext("2d");

      motionSamples = [];
      lastFrameData = null;
      if (motionIntervalId) clearInterval(motionIntervalId);
      // Increased interval and added smoothing to reduce jitter
      motionIntervalId = setInterval(captureMotionSample, 1000);
    } catch (err) {
      console.error(err);
      alert("Could not access camera. Check permissions.");
    }
  }

  function stopCamera() {
    if (cameraStream) {
      cameraStream.getTracks().forEach((t) => t.stop());
      cameraStream = null;
    }
    videoEl.srcObject = null;
    cameraBtn.textContent = "üì∑ Start Camera";
    if (motionIntervalId) {
      clearInterval(motionIntervalId);
      motionIntervalId = null;
    }
    motionSamples = [];
    lastFrameData = null;
    motionScoreEl.textContent = "‚Äì";
  }

  function captureMotionSample() {
    if (!cameraStream || !motionCtx) return;
    const w = motionCanvas.width;
    const h = motionCanvas.height;
    if (!w || !h) return;

    motionCtx.drawImage(videoEl, 0, 0, w, h);
    const frame = motionCtx.getImageData(0, 0, w, h);

    if (!lastFrameData) {
      lastFrameData = frame;
      return;
    }

    let diffSum = 0;
    const step = 4 * 12; // Increased step size to reduce sensitivity
    for (let i = 0; i < frame.data.length; i += step) {
      const r = frame.data[i];
      const g = frame.data[i + 1];
      const b = frame.data[i + 2];
      const r0 = lastFrameData.data[i];
      const g0 = lastFrameData.data[i + 1];
      const b0 = lastFrameData.data[i + 2];
      const delta = Math.abs(r - r0) + Math.abs(g - g0) + Math.abs(b - b0);
      diffSum += delta;
    }
    const avgDiff = diffSum / (frame.data.length / step);
    motionSamples.push(avgDiff);
    // Keep more samples for better smoothing
    if (motionSamples.length > 60) motionSamples.shift();

    // Smooth the display with exponential moving average
    const recentSamples = motionSamples.slice(-10);
    const smoothedScore = recentSamples.reduce((a, b) => a + b, 0) / recentSamples.length;
    const liveScore = Math.round(smoothedScore);
    motionScoreEl.textContent = liveScore;
    lastFrameData = frame;
  }

  function computeMotionScoreForAnswer() {
    if (!motionSamples.length) return null;
    const avg =
      motionSamples.reduce((a, b) => a + b, 0) / motionSamples.length;
    return avg;
  }

  // ========== SPEECH RECOGNITION ==========

  const startAnswerBtn = document.getElementById("startAnswerBtn");
  const stopAnswerBtn = document.getElementById("stopAnswerBtn");
  const micStatusDot = document.getElementById("micStatusDot");
  const micStatusText = document.getElementById("micStatusText");
  const transcriptBox = document.getElementById("transcriptBox");

  initSpeechRecognition();

  function initSpeechRecognition() {
    const SpeechRecognition =
      window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      transcriptBox.textContent =
        "Speech recognition not supported in this browser. You can still type your answer here manually.";
      transcriptBox.contentEditable = "true";
      return;
    }
    recognition = new SpeechRecognition();
    recognition.continuous = true;
    recognition.interimResults = true;
    recognition.lang = "en-US";

    recognition.onstart = () => {
      recognizing = true;
      micStatusDot.classList.remove("off");
      micStatusText.textContent = "Listening‚Ä¶ answer your question.";
    };
    recognition.onerror = (event) => {
      console.warn("Speech recognition error:", event.error);
      if (event.error === "no-speech") {
        // No speech detected, but keep listening
        return;
      }
      if (event.error === "network") {
        // Network error, try to restart
        if (recognizing) {
          setTimeout(() => {
            if (recognizing) {
              try {
                recognition.start();
              } catch (e) {
                console.error("Failed to restart recognition:", e);
              }
            }
          }, 1000);
        }
      }
    };
    
    recognition.onend = () => {
      // Auto-restart if we're still supposed to be recording
      if (recognizing && stopAnswerBtn && !stopAnswerBtn.disabled) {
        console.log("Recognition ended, auto-restarting...");
        setTimeout(() => {
          if (recognizing && stopAnswerBtn && !stopAnswerBtn.disabled) {
            try {
              recognition.start();
            } catch (e) {
              console.error("Failed to auto-restart recognition:", e);
              recognizing = false;
              micStatusDot.classList.add("off");
              micStatusText.textContent = "Mic idle";
            }
          }
        }, 100);
        return;
      }
      
      // Only stop if user actually stopped
      recognizing = false;
      micStatusDot.classList.add("off");
      micStatusText.textContent = "Mic idle";
    };
    
    recognition.onresult = (event) => {
      let interim = "";
      let newFinal = "";
      
      // Only process NEW results (starting from resultIndex)
      // This prevents duplicating text when recognition restarts
      for (let i = event.resultIndex; i < event.results.length; i++) {
        const res = event.results[i];
        if (res.isFinal) {
          newFinal += res[0].transcript + " ";
        } else {
          interim += res[0].transcript + " ";
        }
      }
      
      // Accumulate: existing final transcript + new final results + interim
      lastAnswerTranscript = (lastAnswerTranscript + " " + newFinal).trim();
      liveTranscriptText = (lastAnswerTranscript + " " + interim).trim();
      
      transcriptBox.textContent = liveTranscriptText;
    };

    transcriptBox.contentEditable = "true";
  }

  // Helper to start answer recording, used by both the button and auto-start from Next Question
  function startAnswerRecording(fromAuto = false) {
    if (!recognition) {
      if (transcriptBox) transcriptBox.focus();
      return;
    }
    if (recognizing) return;
    
    // Reset transcript tracking
    lastAnswerTranscript = "";
    liveTranscriptText = "";
    if (transcriptBox) transcriptBox.textContent = "";
    motionSamples = [];
    
    // Reset recognition results
    if (recognition.abort) {
      try {
        recognition.abort();
      } catch (e) {
        console.warn("Error aborting recognition before restart:", e);
      }
    }
    
    recognizing = true;
    try {
      recognition.start();
      if (startAnswerBtn) startAnswerBtn.disabled = true;
      if (stopAnswerBtn) stopAnswerBtn.disabled = false;
      if (fromAuto && micStatusText) {
        micStatusText.textContent = "Listening‚Ä¶ wait for the question to finish, then answer in your own words.";
      }
    } catch (e) {
      console.error("Failed to start recognition:", e);
      recognizing = false;
      if (startAnswerBtn) startAnswerBtn.disabled = false;
      if (stopAnswerBtn) stopAnswerBtn.disabled = true;
    }
  }

  startAnswerBtn.addEventListener("click", () => {
    startAnswerRecording(false);
  });

  stopAnswerBtn.addEventListener("click", () => {
    if (!recognition) return;
    
    // Stop recognizing flag first to prevent auto-restart
    recognizing = false;
    
    // Stop recognition
    try {
      recognition.stop();
    } catch (e) {
      console.error("Error stopping recognition:", e);
    }
    
    // Get final transcript
    lastAnswerTranscript = liveTranscriptText || transcriptBox.textContent || "";
    
    // Update UI
    startAnswerBtn.disabled = false;
    stopAnswerBtn.disabled = true;
    micStatusDot.classList.add("off");
    micStatusText.textContent = "Mic idle";
    
    // Compute motion score
    motionScoreForAnswer = computeMotionScoreForAnswer();
    
    console.log("Recording stopped. Final transcript length:", lastAnswerTranscript.length, "words:", lastAnswerTranscript.split(/\s+/).length);
    
    // Automatically trigger analysis
    if (lastAnswerTranscript.trim()) {
      // Small delay to ensure transcript is finalized
      setTimeout(() => {
        triggerAnalysis();
      }, 500);
    }
  });

  // ========== FEEDBACK & ANALYSIS ==========

  const analyzeBtn = document.getElementById("analyzeBtn");
  const contentScoreEl = document.getElementById("contentScore");
  const voiceScoreEl = document.getElementById("voiceScore");
  const bodyScoreEl = document.getElementById("bodyScore");
  const contentFeedbackEl = document.getElementById("contentFeedback");
  const voiceFeedbackEl = document.getElementById("voiceFeedback");
  const bodyFeedbackEl = document.getElementById("bodyFeedback");
  const fireTipsEl = document.getElementById("fireTips");

  // Extract analysis logic into a reusable function
  async function triggerAnalysis() {
    const text = (transcriptBox.textContent || "").trim();
    if (!text) {
      alert("No transcript found. Answer the question or type your answer first.");
      return;
    }
    lastAnswerTranscript = text;

    // Add to conversation history
    if (currentQuestion) {
      conversationHistory.push({
        question: currentQuestion.template,
        category: currentQuestion.category,
        answer: text,
        timestamp: Date.now()
      });
    }

    // ----- Local (instant) scoring -----
    const content = analyzeContent(text);
    const voice = analyzeVoice(text);
    const body = analyzeBody(motionScoreForAnswer);
    const tips = buildFireTips(content, voice, body);

    applyScoreToPill(contentScoreEl, content.score);
    applyScoreToPill(voiceScoreEl, voice.score);
    applyScoreToPill(bodyScoreEl, body.score);

    contentFeedbackEl.textContent = content.feedback;
    voiceFeedbackEl.textContent = voice.feedback;
    bodyFeedbackEl.textContent = body.feedback;
    fireTipsEl.textContent = tips;

    // ====== POPUP + AI LOADING BAR ======
    if (analyzeBtn) {
      analyzeBtn.disabled = true;
      analyzeBtn.textContent = APP_CONFIG ? APP_CONFIG.status.analyzing : "ü§ñ Analyzing with AI...";
    }

    // Open the AI modal immediately
    openAIModal();

    // Build loading UI inside the modal
    const modalContentEl = document.getElementById("aiModalContent");
    if (modalContentEl) {
      modalContentEl.innerHTML = `
        <div style="margin-bottom: 12px; font-size: 0.9rem; color: #e5e7eb;">
          Analyzing your answer and body language. This can take a few seconds...
        </div>
        <div style="margin-bottom: 8px; display:flex; justify-content:space-between; align-items:center;">
          <span style="font-size: 0.85rem; color:#cbd5e1;">Contacting AI Interview Coach</span>
          <span id="aiModalProgressPercent" style="font-size:0.85rem; color:#f97316; font-weight:600;">0%</span>
        </div>
        <div style="width:100%; height:8px; background:#111827; border-radius:999px; overflow:hidden;">
          <div id="aiModalProgressBar" style="width:0%; height:100%; background:linear-gradient(90deg,#f97316,#ef4444); transition:width 0.2s;"></div>
        </div>
      `;
    }

    const progressBar = document.getElementById("aiModalProgressBar");
    const progressPercent = document.getElementById("aiModalProgressPercent");
    let progress = 0;
    const progressInterval = setInterval(() => {
      progress += Math.random() * 15;
      if (progress > 90) progress = 90;
      if (progressBar) progressBar.style.width = progress + "%";
      if (progressPercent) progressPercent.textContent = Math.round(progress) + "%";
    }, 200);

    try {
      const response = await fetch(`${BACKEND_URL}/api/analyze-answer`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          question: currentQuestion ? currentQuestion.template : "Unknown",
          answer: text,
          motionScore: motionScoreForAnswer,
          resumeAnalysis: resumeAnalysis,
          resumeText: resumeText,
          conversationHistory: conversationHistory,
          cityResearch: onboardingData?.cityResearch || null,
          category: currentQuestion?.category || null
        })
      });

      if (!response.ok) {
        throw new Error(`Backend error: ${response.status}`);
      }

      const data = await response.json();
      const aiFeedback = data.feedback;

      // Finish progress bar
      clearInterval(progressInterval);
      if (progressBar) progressBar.style.width = "100%";
      if (progressPercent) progressPercent.textContent = "100%";

      if (aiFeedback) {
        // Small preview in right-hand card
        formatAIFeedback(fireTipsEl, aiFeedback, true);
        // Full formatted feedback into the modal
        formatAIFeedbackForModal(aiFeedback);

        const viewBtn = document.getElementById("viewAIFeedbackBtn");
        if (viewBtn) {
          viewBtn.style.display = "block";
        }

        addFollowupButton();
      } else if (modalContentEl) {
        modalContentEl.innerHTML = `
          <p style="color:#fecaca;">AI didn't return any feedback. Please try again.</p>
        `;
      }
    } catch (err) {
      console.error("Backend analysis error:", err);
      clearInterval(progressInterval);
      if (modalContentEl) {
        modalContentEl.innerHTML = `
          <p style="color:#fecaca; margin-bottom:4px;">AI analysis failed.</p>
          <p style="color:#9ca3af; font-size:0.85rem;">Check your connection and try again.</p>
        `;
      }
    } finally {
      if (analyzeBtn) {
        analyzeBtn.disabled = false;
        analyzeBtn.textContent = "ü§ñ Analyze Answer";
      }
    }
  }

  
  // Note: The analyze button is now hidden/removed from UI, but we keep the function for auto-triggering

  // Format AI feedback with proper HTML structure (for small preview)
  function formatAIFeedback(container, text, showPreview = false) {
    container.innerHTML = ""; // Clear existing content
    
    if (showPreview) {
      // Show just a brief preview in the small box
      const preview = text.split("\n").slice(0, 3).join(" ").slice(0, 150) + "...";
      container.textContent = preview;
      container.style.cssText = "font-size: 0.75rem; color: #9ca3af; margin: 0;";
    } else {
      // Full formatting for modal
      formatAIFeedbackForModal(text);
    }
  }
  
  // Format AI feedback for the modal (wide, readable format)
  function formatAIFeedbackForModal(text) {
    const modalContent = document.getElementById("aiModalContent");
    if (!modalContent) return;
    
    // Helper function to convert markdown bold (**text**) to HTML bold
    function convertMarkdownBold(str) {
      // Replace **text** with <strong>text</strong>
      return str.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    }
    
    // Parse markdown-style formatting
    const lines = text.split("\n");
    let html = "";
    
    lines.forEach(line => {
      const trimmed = line.trim();
      
      // Main sections (##)
      if (trimmed.startsWith("## ")) {
        const sectionTitle = trimmed.substring(3);
        html += `<h4>${convertMarkdownBold(sectionTitle)}</h4>`;
      }
      // Bullet points
      else if (trimmed.startsWith("- ") || trimmed.startsWith("* ")) {
        const content = trimmed.substring(2);
        html += `<div class="bullet-point">‚Ä¢ ${convertMarkdownBold(content)}</div>`;
      }
      // Regular paragraphs
      else if (trimmed.length > 0) {
        // Check if it's a score line
        if (trimmed.match(/^\d+\/10/)) {
          html += `<div class="score-highlight">${convertMarkdownBold(trimmed)}</div>`;
        } else {
          html += `<div>${convertMarkdownBold(trimmed)}</div>`;
        }
      }
      // Empty lines
      else {
        html += "<br>";
      }
    });
    
    modalContent.innerHTML = html;
  }
  
  // Modal functionality
  const aiModalOverlay = document.getElementById("aiModalOverlay");
  const closeAIModalBtn = document.getElementById("closeAIModal");
  const viewAIFeedbackBtn = document.getElementById("viewAIFeedbackBtn");
  
  function openAIModal() {
    const modal = document.getElementById("aiModalOverlay");
    if (modal) {
      modal.classList.add("active");
      modal.style.display = "flex"; // Force display
      document.body.style.overflow = "hidden"; // Prevent background scrolling
      console.log("AI Modal opened - display set to flex");
    } else {
      console.error("aiModalOverlay element not found!");
    }
  }
  
  function closeAIModal() {
    if (aiModalOverlay) {
      aiModalOverlay.classList.remove("active");
      document.body.style.overflow = ""; // Restore scrolling
    }
  }
  
  if (closeAIModalBtn) {
    closeAIModalBtn.addEventListener("click", closeAIModal);
  }
  
  if (viewAIFeedbackBtn) {
    viewAIFeedbackBtn.addEventListener("click", openAIModal);
  }
  
  // Close modal when clicking outside
  if (aiModalOverlay) {
    aiModalOverlay.addEventListener("click", (e) => {
      if (e.target === aiModalOverlay) {
        closeAIModal();
      }
    });
  }
  
  // Close modal with Escape key
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && aiModalOverlay && aiModalOverlay.classList.contains("active")) {
      closeAIModal();
    }
  });
  
  // Add followup button near question area
  function addFollowupButton() {
    // Remove existing followup button if any
    const existingBtn = document.getElementById("followupQuestionBtn");
    if (existingBtn) existingBtn.remove();
    
    const followupBtn = document.createElement("button");
    followupBtn.id = "followupQuestionBtn";
    followupBtn.textContent = "üí¨ Ask Followup Question";
    followupBtn.style.cssText = "margin-top: 12px; padding: 12px 20px; border-radius: 8px; border: none; background: #ef4444; color: #fff; cursor: pointer; font-size: 0.95rem; font-weight: 600; width: 100%; transition: background 0.2s;";
    followupBtn.onmouseover = () => followupBtn.style.background = "#dc2626";
    followupBtn.onmouseout = () => followupBtn.style.background = "#ef4444";
    
    followupBtn.onclick = async () => {
      followupBtn.disabled = true;
      followupBtn.textContent = "ü§ñ Generating followup...";
      try {
        currentQuestion = await generateFollowupQuestion();
        questionCount++;
        renderQuestion(currentQuestion);
        speakQuestionWithCaptions(currentQuestion.template);
        followupBtn.remove();
      } catch (err) {
        console.error("Followup generation error:", err);
        followupBtn.textContent = "Error generating followup";
        followupBtn.disabled = false;
      }
    };
    
    // Insert into the dedicated container
    const container = document.getElementById("followupButtonContainer");
    if (container) {
      container.innerHTML = "";
      container.appendChild(followupBtn);
    } else {
      // Fallback: add after question meta
      const questionMeta = document.querySelector(".question-meta");
      if (questionMeta && questionMeta.parentNode) {
        questionMeta.parentNode.insertBefore(followupBtn, questionMeta.nextSibling);
      }
    }
  }

  function analyzeContent(text) {
    const words = text.split(/\s+/).filter(Boolean);
    const length = words.length;

    const structureKeywords = [
      "situation",
      "call",
      "scene",
      "task",
      "problem",
      "action",
      "then",
      "after",
      "result",
      "outcome",
      "learned"
    ];
    const lower = text.toLowerCase();
    let structureHits = 0;
    structureKeywords.forEach((k) => {
      if (lower.includes(k)) structureHits++;
    });

    let keywordHits = 0;
    const allKeywords = new Set([
      ...firefighterKeywords.map((k) => k.toLowerCase()),
      ...resumeKeywords.map((k) => k.word.toLowerCase())
    ]);
    allKeywords.forEach((k) => {
      const regex = new RegExp("\\b" + escapeRegExp(k) + "\\b", "g");
      const matches = lower.match(regex);
      if (matches) keywordHits += matches.length;
    });

    let score = 0;
    if (length >= 80 && length <= 250) score += 3;
    else if (length >= 50 && length < 80) score += 2;
    else if (length < 50) score += 1;

    if (structureHits >= 6) score += 3;
    else if (structureHits >= 3) score += 2;
    else if (structureHits >= 1) score += 1;

    if (keywordHits >= 5) score += 3;
    else if (keywordHits >= 2) score += 2;
    else if (keywordHits >= 1) score += 1;

    const feedbackParts = [];
    feedbackParts.push(
      `Length: about ${length} words. Target 90‚Äì180 words for most panel answers.`
    );
    if (structureHits >= 6) {
      feedbackParts.push(
        "You naturally walked through the situation, actions, and outcome. Structure was clear."
      );
    } else if (structureHits >= 3) {
      feedbackParts.push(
        "Structure was decent but you could sharpen it with a clear beginning (call setup), middle (actions), and end (results/learning)."
      );
    } else {
      feedbackParts.push(
        "Try using a clear flow: brief scene setup ‚Üí what you did ‚Üí what happened ‚Üí what you learned."
      );
    }

    if (keywordHits >= 5) {
      feedbackParts.push(
        "You tied in strong role-specific details (gear, EMR, training, teamwork) which panels like to hear."
      );
    } else if (keywordHits >= 2) {
      feedbackParts.push(
        "You referenced some relevant experience. You could still anchor more to firefighter tasks and your resume (EMR, call types, training)."
      );
    } else {
      feedbackParts.push(
        "You kept things very general. Link the story directly to fire/medical or physical/crew work you actually do."
      );
    }

    return {
      score,
      feedback: feedbackParts.join(" ")
    };
  }

  function analyzeVoice(text) {
    const lower = text.toLowerCase();
    const fillerWords = ["um", "uh", "like", "you know", "sort of", "kind of"];
    let fillerCount = 0;
    fillerWords.forEach((w) => {
      const regex = new RegExp("\\b" + escapeRegExp(w) + "\\b", "g");
      const matches = lower.match(regex);
      if (matches) fillerCount += matches.length;
    });

    const sentences = text.split(/[.!?]+/).filter(Boolean);
    const avgSentenceLength = sentences.length
      ? text.split(/\s+/).filter(Boolean).length / sentences.length
      : 0;

    let score = 0;
    if (fillerCount === 0) score += 4;
    else if (fillerCount <= 2) score += 3;
    else if (fillerCount <= 5) score += 2;
    else score += 1;

    if (avgSentenceLength > 8 && avgSentenceLength < 25) score += 3;
    else if (avgSentenceLength >= 5 && avgSentenceLength <= 30) score += 2;
    else score += 1;

    const feedbackParts = [];
    if (fillerCount === 0) {
      feedbackParts.push("Nice work‚Äîno obvious filler words detected.");
    } else {
      feedbackParts.push(
        `Detected about ${fillerCount} filler words (e.g., ‚Äúum‚Äù, ‚Äúlike‚Äù). Try pausing silently instead of filling space.`
      );
    }

    if (avgSentenceLength > 8 && avgSentenceLength < 25) {
      feedbackParts.push("Your sentences are a good length‚Äîclear but not choppy.");
    } else if (avgSentenceLength <= 8) {
      feedbackParts.push(
        "Some sentences are very short. You may sound choppy; try linking ideas together slightly more."
      );
    } else {
      feedbackParts.push(
        "Some sentences are quite long. Break them up so the panel can follow key points."
      );
    }

    return {
      score,
      fillerCount,
      feedback: feedbackParts.join(" ")
    };
  }

  function analyzeBody(motionScore) {
    if (motionScore == null || isNaN(motionScore)) {
      return {
        score: 2,
        feedback:
          "Camera motion data wasn‚Äôt available for this answer. Make sure your camera is running before you start speaking."
      };
    }

    let score;
    let label;
    if (motionScore < 12) {
      score = 4;
      label = "Very steady ‚Äì little extra movement visible.";
    } else if (motionScore < 25) {
      score = 3;
      label = "Moderate, natural movement ‚Äì likely fine for a real panel.";
    } else if (motionScore < 50) {
      score = 2;
      label = "Noticeable movement ‚Äì may read as a bit fidgety or restless.";
    } else {
      score = 1;
      label =
        "High movement ‚Äì could distract from your answer. Practice keeping your posture steady.";
    }

    return {
      score,
      feedback: `${label} (motion score ‚âà ${motionScore.toFixed(0)} on this answer).`
    };
  }

  function buildFireTips(content, voice, body) {
    const tips = [];

    if (content.score < 7) {
      tips.push(
        "Practice giving answers in a clear fire-call flow: what the call was, what you saw, what you did, how it ended, and what you learned."
      );
    }

    if (voice.fillerCount && voice.fillerCount > 2) {
      tips.push(
        "Try mock answers where you deliberately pause for one full breath before speaking. That pause cuts out a lot of ‚Äúums‚Äù."
      );
    }

    if (body.score < 3) {
      tips.push(
        "Set the camera at eye level, plant your feet, and keep your hands rested on the table or in your lap between gestures."
      );
    }

    if (tips.length === 0) {
      tips.push(
        "This answer is close to panel-ready. Next step: practice 3‚Äì5 questions in a row so you build stamina and consistency."
      );
    }

    return tips.join(" ");
  }

  function applyScoreToPill(el, score) {
    el.classList.remove("low", "mid");
    if (score >= 7) {
      el.textContent = `${score}/10`;
    } else if (score >= 5) {
      el.textContent = `${score}/10`;
      el.classList.add("mid");
    } else {
      el.textContent = `${score}/10`;
      el.classList.add("low");
    }
  }

  function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
</script>
</body>
</html>
